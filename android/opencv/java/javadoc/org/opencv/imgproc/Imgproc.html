<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_312) on Wed Jun 28 12:47:25 UTC 2023 -->
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Imgproc (OpenCV 4.8.0 Java documentation)</title>
<meta name="date" content="2023-06-28">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Imgproc (OpenCV 4.8.0 Java documentation)";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":9,"i1":9,"i2":9,"i3":9,"i4":9,"i5":9,"i6":9,"i7":9,"i8":9,"i9":9,"i10":9,"i11":9,"i12":9,"i13":9,"i14":9,"i15":9,"i16":9,"i17":9,"i18":9,"i19":9,"i20":9,"i21":9,"i22":9,"i23":9,"i24":9,"i25":9,"i26":9,"i27":9,"i28":9,"i29":9,"i30":9,"i31":9,"i32":9,"i33":9,"i34":9,"i35":9,"i36":9,"i37":9,"i38":9,"i39":9,"i40":9,"i41":9,"i42":9,"i43":9,"i44":9,"i45":9,"i46":9,"i47":9,"i48":9,"i49":9,"i50":9,"i51":9,"i52":9,"i53":9,"i54":9,"i55":9,"i56":9,"i57":9,"i58":9,"i59":9,"i60":9,"i61":9,"i62":9,"i63":9,"i64":9,"i65":9,"i66":9,"i67":9,"i68":9,"i69":9,"i70":9,"i71":9,"i72":9,"i73":9,"i74":9,"i75":9,"i76":9,"i77":9,"i78":9,"i79":9,"i80":9,"i81":9,"i82":9,"i83":9,"i84":9,"i85":9,"i86":9,"i87":9,"i88":9,"i89":9,"i90":9,"i91":9,"i92":9,"i93":9,"i94":9,"i95":9,"i96":9,"i97":9,"i98":9,"i99":9,"i100":9,"i101":9,"i102":9,"i103":9,"i104":9,"i105":9,"i106":9,"i107":9,"i108":9,"i109":9,"i110":9,"i111":9,"i112":9,"i113":9,"i114":9,"i115":9,"i116":9,"i117":9,"i118":9,"i119":9,"i120":9,"i121":9,"i122":9,"i123":9,"i124":9,"i125":9,"i126":9,"i127":9,"i128":9,"i129":9,"i130":9,"i131":9,"i132":9,"i133":9,"i134":9,"i135":9,"i136":9,"i137":9,"i138":9,"i139":9,"i140":9,"i141":9,"i142":9,"i143":9,"i144":9,"i145":9,"i146":9,"i147":9,"i148":9,"i149":9,"i150":9,"i151":9,"i152":9,"i153":9,"i154":9,"i155":9,"i156":9,"i157":9,"i158":9,"i159":9,"i160":9,"i161":9,"i162":9,"i163":9,"i164":9,"i165":9,"i166":9,"i167":9,"i168":9,"i169":9,"i170":9,"i171":9,"i172":9,"i173":9,"i174":9,"i175":9,"i176":9,"i177":9,"i178":9,"i179":9,"i180":9,"i181":9,"i182":9,"i183":9,"i184":9,"i185":9,"i186":9,"i187":9,"i188":9,"i189":9,"i190":9,"i191":9,"i192":9,"i193":9,"i194":9,"i195":9,"i196":9,"i197":9,"i198":9,"i199":9,"i200":9,"i201":9,"i202":9,"i203":9,"i204":9,"i205":9,"i206":9,"i207":9,"i208":9,"i209":9,"i210":9,"i211":9,"i212":9,"i213":9,"i214":9,"i215":9,"i216":9,"i217":9,"i218":9,"i219":9,"i220":9,"i221":9,"i222":9,"i223":9,"i224":9,"i225":9,"i226":9,"i227":9,"i228":9,"i229":9,"i230":9,"i231":9,"i232":9,"i233":9,"i234":9,"i235":9,"i236":9,"i237":9,"i238":9,"i239":9,"i240":9,"i241":9,"i242":9,"i243":9,"i244":9,"i245":9,"i246":9,"i247":9,"i248":9,"i249":9,"i250":9,"i251":9,"i252":9,"i253":9,"i254":9,"i255":9,"i256":9,"i257":9,"i258":9,"i259":9,"i260":9,"i261":9,"i262":9,"i263":9,"i264":9,"i265":9,"i266":9,"i267":9,"i268":9,"i269":9,"i270":9,"i271":9,"i272":9,"i273":9,"i274":9,"i275":9,"i276":9,"i277":9,"i278":9,"i279":9,"i280":9,"i281":9,"i282":9,"i283":9,"i284":9,"i285":9,"i286":9,"i287":9,"i288":9,"i289":9,"i290":9,"i291":9,"i292":9,"i293":9,"i294":9,"i295":9,"i296":9,"i297":9,"i298":9,"i299":9,"i300":9,"i301":9,"i302":9,"i303":9,"i304":9,"i305":9,"i306":9,"i307":9,"i308":9,"i309":9,"i310":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
<div class="aboutLanguage">
            <script>
              var url = window.location.href;
              var pos = url.lastIndexOf('/javadoc/');
              url = pos >= 0 ? (url.substring(0, pos) + '/javadoc/mymath.js') : (window.location.origin + '/mymath.js');
              var script = document.createElement('script');
              script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML,' + url;
              document.getElementsByTagName('head')[0].appendChild(script);
            </script>
</div>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../org/opencv/imgproc/GeneralizedHoughGuil.html" title="class in org.opencv.imgproc"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../org/opencv/imgproc/IntelligentScissorsMB.html" title="class in org.opencv.imgproc"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?org/opencv/imgproc/Imgproc.html" target="_top">Frames</a></li>
<li><a href="Imgproc.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">org.opencv.imgproc</div>
<h2 title="Class Imgproc" class="title">Class Imgproc</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>org.opencv.imgproc.Imgproc</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public class <span class="typeNameLabel">Imgproc</span>
extends java.lang.Object</pre>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#ADAPTIVE_THRESH_GAUSSIAN_C">ADAPTIVE_THRESH_GAUSSIAN_C</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#ADAPTIVE_THRESH_MEAN_C">ADAPTIVE_THRESH_MEAN_C</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CC_STAT_AREA">CC_STAT_AREA</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CC_STAT_HEIGHT">CC_STAT_HEIGHT</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CC_STAT_LEFT">CC_STAT_LEFT</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CC_STAT_MAX">CC_STAT_MAX</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CC_STAT_TOP">CC_STAT_TOP</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CC_STAT_WIDTH">CC_STAT_WIDTH</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CCL_BBDT">CCL_BBDT</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CCL_BOLELLI">CCL_BOLELLI</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CCL_DEFAULT">CCL_DEFAULT</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CCL_GRANA">CCL_GRANA</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CCL_SAUF">CCL_SAUF</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CCL_SPAGHETTI">CCL_SPAGHETTI</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CCL_WU">CCL_WU</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CHAIN_APPROX_NONE">CHAIN_APPROX_NONE</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CHAIN_APPROX_SIMPLE">CHAIN_APPROX_SIMPLE</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CHAIN_APPROX_TC89_KCOS">CHAIN_APPROX_TC89_KCOS</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CHAIN_APPROX_TC89_L1">CHAIN_APPROX_TC89_L1</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerBG2BGR">COLOR_BayerBG2BGR</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerBG2BGR_EA">COLOR_BayerBG2BGR_EA</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerBG2BGR_VNG">COLOR_BayerBG2BGR_VNG</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerBG2BGRA">COLOR_BayerBG2BGRA</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerBG2GRAY">COLOR_BayerBG2GRAY</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerBG2RGB">COLOR_BayerBG2RGB</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerBG2RGB_EA">COLOR_BayerBG2RGB_EA</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerBG2RGB_VNG">COLOR_BayerBG2RGB_VNG</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerBG2RGBA">COLOR_BayerBG2RGBA</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerBGGR2BGR">COLOR_BayerBGGR2BGR</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerBGGR2BGR_EA">COLOR_BayerBGGR2BGR_EA</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerBGGR2BGR_VNG">COLOR_BayerBGGR2BGR_VNG</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerBGGR2BGRA">COLOR_BayerBGGR2BGRA</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerBGGR2GRAY">COLOR_BayerBGGR2GRAY</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerBGGR2RGB">COLOR_BayerBGGR2RGB</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerBGGR2RGB_EA">COLOR_BayerBGGR2RGB_EA</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerBGGR2RGB_VNG">COLOR_BayerBGGR2RGB_VNG</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerBGGR2RGBA">COLOR_BayerBGGR2RGBA</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerGB2BGR">COLOR_BayerGB2BGR</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerGB2BGR_EA">COLOR_BayerGB2BGR_EA</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerGB2BGR_VNG">COLOR_BayerGB2BGR_VNG</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerGB2BGRA">COLOR_BayerGB2BGRA</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerGB2GRAY">COLOR_BayerGB2GRAY</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerGB2RGB">COLOR_BayerGB2RGB</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerGB2RGB_EA">COLOR_BayerGB2RGB_EA</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerGB2RGB_VNG">COLOR_BayerGB2RGB_VNG</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerGB2RGBA">COLOR_BayerGB2RGBA</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerGBRG2BGR">COLOR_BayerGBRG2BGR</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerGBRG2BGR_EA">COLOR_BayerGBRG2BGR_EA</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerGBRG2BGR_VNG">COLOR_BayerGBRG2BGR_VNG</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerGBRG2BGRA">COLOR_BayerGBRG2BGRA</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerGBRG2GRAY">COLOR_BayerGBRG2GRAY</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerGBRG2RGB">COLOR_BayerGBRG2RGB</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerGBRG2RGB_EA">COLOR_BayerGBRG2RGB_EA</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerGBRG2RGB_VNG">COLOR_BayerGBRG2RGB_VNG</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerGBRG2RGBA">COLOR_BayerGBRG2RGBA</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerGR2BGR">COLOR_BayerGR2BGR</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerGR2BGR_EA">COLOR_BayerGR2BGR_EA</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerGR2BGR_VNG">COLOR_BayerGR2BGR_VNG</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerGR2BGRA">COLOR_BayerGR2BGRA</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerGR2GRAY">COLOR_BayerGR2GRAY</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerGR2RGB">COLOR_BayerGR2RGB</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerGR2RGB_EA">COLOR_BayerGR2RGB_EA</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerGR2RGB_VNG">COLOR_BayerGR2RGB_VNG</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerGR2RGBA">COLOR_BayerGR2RGBA</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerGRBG2BGR">COLOR_BayerGRBG2BGR</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerGRBG2BGR_EA">COLOR_BayerGRBG2BGR_EA</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerGRBG2BGR_VNG">COLOR_BayerGRBG2BGR_VNG</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerGRBG2BGRA">COLOR_BayerGRBG2BGRA</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerGRBG2GRAY">COLOR_BayerGRBG2GRAY</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerGRBG2RGB">COLOR_BayerGRBG2RGB</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerGRBG2RGB_EA">COLOR_BayerGRBG2RGB_EA</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerGRBG2RGB_VNG">COLOR_BayerGRBG2RGB_VNG</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerGRBG2RGBA">COLOR_BayerGRBG2RGBA</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerRG2BGR">COLOR_BayerRG2BGR</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerRG2BGR_EA">COLOR_BayerRG2BGR_EA</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerRG2BGR_VNG">COLOR_BayerRG2BGR_VNG</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerRG2BGRA">COLOR_BayerRG2BGRA</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerRG2GRAY">COLOR_BayerRG2GRAY</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerRG2RGB">COLOR_BayerRG2RGB</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerRG2RGB_EA">COLOR_BayerRG2RGB_EA</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerRG2RGB_VNG">COLOR_BayerRG2RGB_VNG</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerRG2RGBA">COLOR_BayerRG2RGBA</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerRGGB2BGR">COLOR_BayerRGGB2BGR</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerRGGB2BGR_EA">COLOR_BayerRGGB2BGR_EA</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerRGGB2BGR_VNG">COLOR_BayerRGGB2BGR_VNG</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerRGGB2BGRA">COLOR_BayerRGGB2BGRA</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerRGGB2GRAY">COLOR_BayerRGGB2GRAY</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerRGGB2RGB">COLOR_BayerRGGB2RGB</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerRGGB2RGB_EA">COLOR_BayerRGGB2RGB_EA</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerRGGB2RGB_VNG">COLOR_BayerRGGB2RGB_VNG</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BayerRGGB2RGBA">COLOR_BayerRGGB2RGBA</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR2BGR555">COLOR_BGR2BGR555</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR2BGR565">COLOR_BGR2BGR565</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR2BGRA">COLOR_BGR2BGRA</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR2GRAY">COLOR_BGR2GRAY</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR2HLS">COLOR_BGR2HLS</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR2HLS_FULL">COLOR_BGR2HLS_FULL</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR2HSV">COLOR_BGR2HSV</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR2HSV_FULL">COLOR_BGR2HSV_FULL</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR2Lab">COLOR_BGR2Lab</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR2Luv">COLOR_BGR2Luv</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR2RGB">COLOR_BGR2RGB</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR2RGBA">COLOR_BGR2RGBA</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR2XYZ">COLOR_BGR2XYZ</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR2YCrCb">COLOR_BGR2YCrCb</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR2YUV">COLOR_BGR2YUV</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR2YUV_I420">COLOR_BGR2YUV_I420</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR2YUV_IYUV">COLOR_BGR2YUV_IYUV</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR2YUV_YV12">COLOR_BGR2YUV_YV12</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR5552BGR">COLOR_BGR5552BGR</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR5552BGRA">COLOR_BGR5552BGRA</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR5552GRAY">COLOR_BGR5552GRAY</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR5552RGB">COLOR_BGR5552RGB</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR5552RGBA">COLOR_BGR5552RGBA</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR5652BGR">COLOR_BGR5652BGR</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR5652BGRA">COLOR_BGR5652BGRA</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR5652GRAY">COLOR_BGR5652GRAY</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR5652RGB">COLOR_BGR5652RGB</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGR5652RGBA">COLOR_BGR5652RGBA</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGRA2BGR">COLOR_BGRA2BGR</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGRA2BGR555">COLOR_BGRA2BGR555</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGRA2BGR565">COLOR_BGRA2BGR565</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGRA2GRAY">COLOR_BGRA2GRAY</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGRA2RGB">COLOR_BGRA2RGB</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGRA2RGBA">COLOR_BGRA2RGBA</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGRA2YUV_I420">COLOR_BGRA2YUV_I420</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGRA2YUV_IYUV">COLOR_BGRA2YUV_IYUV</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_BGRA2YUV_YV12">COLOR_BGRA2YUV_YV12</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_COLORCVT_MAX">COLOR_COLORCVT_MAX</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_GRAY2BGR">COLOR_GRAY2BGR</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_GRAY2BGR555">COLOR_GRAY2BGR555</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_GRAY2BGR565">COLOR_GRAY2BGR565</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_GRAY2BGRA">COLOR_GRAY2BGRA</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_GRAY2RGB">COLOR_GRAY2RGB</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_GRAY2RGBA">COLOR_GRAY2RGBA</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_HLS2BGR">COLOR_HLS2BGR</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_HLS2BGR_FULL">COLOR_HLS2BGR_FULL</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_HLS2RGB">COLOR_HLS2RGB</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_HLS2RGB_FULL">COLOR_HLS2RGB_FULL</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_HSV2BGR">COLOR_HSV2BGR</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_HSV2BGR_FULL">COLOR_HSV2BGR_FULL</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_HSV2RGB">COLOR_HSV2RGB</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_HSV2RGB_FULL">COLOR_HSV2RGB_FULL</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_Lab2BGR">COLOR_Lab2BGR</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_Lab2LBGR">COLOR_Lab2LBGR</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_Lab2LRGB">COLOR_Lab2LRGB</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_Lab2RGB">COLOR_Lab2RGB</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_LBGR2Lab">COLOR_LBGR2Lab</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_LBGR2Luv">COLOR_LBGR2Luv</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_LRGB2Lab">COLOR_LRGB2Lab</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_LRGB2Luv">COLOR_LRGB2Luv</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_Luv2BGR">COLOR_Luv2BGR</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_Luv2LBGR">COLOR_Luv2LBGR</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_Luv2LRGB">COLOR_Luv2LRGB</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_Luv2RGB">COLOR_Luv2RGB</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_mRGBA2RGBA">COLOR_mRGBA2RGBA</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGB2BGR">COLOR_RGB2BGR</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGB2BGR555">COLOR_RGB2BGR555</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGB2BGR565">COLOR_RGB2BGR565</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGB2BGRA">COLOR_RGB2BGRA</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGB2GRAY">COLOR_RGB2GRAY</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGB2HLS">COLOR_RGB2HLS</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGB2HLS_FULL">COLOR_RGB2HLS_FULL</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGB2HSV">COLOR_RGB2HSV</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGB2HSV_FULL">COLOR_RGB2HSV_FULL</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGB2Lab">COLOR_RGB2Lab</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGB2Luv">COLOR_RGB2Luv</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGB2RGBA">COLOR_RGB2RGBA</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGB2XYZ">COLOR_RGB2XYZ</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGB2YCrCb">COLOR_RGB2YCrCb</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGB2YUV">COLOR_RGB2YUV</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGB2YUV_I420">COLOR_RGB2YUV_I420</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGB2YUV_IYUV">COLOR_RGB2YUV_IYUV</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGB2YUV_YV12">COLOR_RGB2YUV_YV12</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGBA2BGR">COLOR_RGBA2BGR</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGBA2BGR555">COLOR_RGBA2BGR555</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGBA2BGR565">COLOR_RGBA2BGR565</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGBA2BGRA">COLOR_RGBA2BGRA</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGBA2GRAY">COLOR_RGBA2GRAY</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGBA2mRGBA">COLOR_RGBA2mRGBA</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGBA2RGB">COLOR_RGBA2RGB</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGBA2YUV_I420">COLOR_RGBA2YUV_I420</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGBA2YUV_IYUV">COLOR_RGBA2YUV_IYUV</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_RGBA2YUV_YV12">COLOR_RGBA2YUV_YV12</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_XYZ2BGR">COLOR_XYZ2BGR</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_XYZ2RGB">COLOR_XYZ2RGB</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YCrCb2BGR">COLOR_YCrCb2BGR</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YCrCb2RGB">COLOR_YCrCb2RGB</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGR">COLOR_YUV2BGR</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGR_I420">COLOR_YUV2BGR_I420</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGR_IYUV">COLOR_YUV2BGR_IYUV</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGR_NV12">COLOR_YUV2BGR_NV12</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGR_NV21">COLOR_YUV2BGR_NV21</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGR_UYNV">COLOR_YUV2BGR_UYNV</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGR_UYVY">COLOR_YUV2BGR_UYVY</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGR_Y422">COLOR_YUV2BGR_Y422</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGR_YUNV">COLOR_YUV2BGR_YUNV</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGR_YUY2">COLOR_YUV2BGR_YUY2</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGR_YUYV">COLOR_YUV2BGR_YUYV</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGR_YV12">COLOR_YUV2BGR_YV12</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGR_YVYU">COLOR_YUV2BGR_YVYU</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGRA_I420">COLOR_YUV2BGRA_I420</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGRA_IYUV">COLOR_YUV2BGRA_IYUV</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGRA_NV12">COLOR_YUV2BGRA_NV12</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGRA_NV21">COLOR_YUV2BGRA_NV21</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGRA_UYNV">COLOR_YUV2BGRA_UYNV</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGRA_UYVY">COLOR_YUV2BGRA_UYVY</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGRA_Y422">COLOR_YUV2BGRA_Y422</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGRA_YUNV">COLOR_YUV2BGRA_YUNV</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGRA_YUY2">COLOR_YUV2BGRA_YUY2</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGRA_YUYV">COLOR_YUV2BGRA_YUYV</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGRA_YV12">COLOR_YUV2BGRA_YV12</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2BGRA_YVYU">COLOR_YUV2BGRA_YVYU</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2GRAY_420">COLOR_YUV2GRAY_420</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2GRAY_I420">COLOR_YUV2GRAY_I420</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2GRAY_IYUV">COLOR_YUV2GRAY_IYUV</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2GRAY_NV12">COLOR_YUV2GRAY_NV12</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2GRAY_NV21">COLOR_YUV2GRAY_NV21</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2GRAY_UYNV">COLOR_YUV2GRAY_UYNV</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2GRAY_UYVY">COLOR_YUV2GRAY_UYVY</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2GRAY_Y422">COLOR_YUV2GRAY_Y422</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2GRAY_YUNV">COLOR_YUV2GRAY_YUNV</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2GRAY_YUY2">COLOR_YUV2GRAY_YUY2</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2GRAY_YUYV">COLOR_YUV2GRAY_YUYV</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2GRAY_YV12">COLOR_YUV2GRAY_YV12</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2GRAY_YVYU">COLOR_YUV2GRAY_YVYU</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGB">COLOR_YUV2RGB</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGB_I420">COLOR_YUV2RGB_I420</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGB_IYUV">COLOR_YUV2RGB_IYUV</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGB_NV12">COLOR_YUV2RGB_NV12</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGB_NV21">COLOR_YUV2RGB_NV21</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGB_UYNV">COLOR_YUV2RGB_UYNV</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGB_UYVY">COLOR_YUV2RGB_UYVY</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGB_Y422">COLOR_YUV2RGB_Y422</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGB_YUNV">COLOR_YUV2RGB_YUNV</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGB_YUY2">COLOR_YUV2RGB_YUY2</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGB_YUYV">COLOR_YUV2RGB_YUYV</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGB_YV12">COLOR_YUV2RGB_YV12</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGB_YVYU">COLOR_YUV2RGB_YVYU</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGBA_I420">COLOR_YUV2RGBA_I420</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGBA_IYUV">COLOR_YUV2RGBA_IYUV</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGBA_NV12">COLOR_YUV2RGBA_NV12</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGBA_NV21">COLOR_YUV2RGBA_NV21</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGBA_UYNV">COLOR_YUV2RGBA_UYNV</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGBA_UYVY">COLOR_YUV2RGBA_UYVY</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGBA_Y422">COLOR_YUV2RGBA_Y422</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGBA_YUNV">COLOR_YUV2RGBA_YUNV</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGBA_YUY2">COLOR_YUV2RGBA_YUY2</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGBA_YUYV">COLOR_YUV2RGBA_YUYV</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGBA_YV12">COLOR_YUV2RGBA_YV12</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV2RGBA_YVYU">COLOR_YUV2RGBA_YVYU</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV420p2BGR">COLOR_YUV420p2BGR</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV420p2BGRA">COLOR_YUV420p2BGRA</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV420p2GRAY">COLOR_YUV420p2GRAY</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV420p2RGB">COLOR_YUV420p2RGB</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV420p2RGBA">COLOR_YUV420p2RGBA</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV420sp2BGR">COLOR_YUV420sp2BGR</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV420sp2BGRA">COLOR_YUV420sp2BGRA</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV420sp2GRAY">COLOR_YUV420sp2GRAY</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV420sp2RGB">COLOR_YUV420sp2RGB</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLOR_YUV420sp2RGBA">COLOR_YUV420sp2RGBA</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLORMAP_AUTUMN">COLORMAP_AUTUMN</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLORMAP_BONE">COLORMAP_BONE</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLORMAP_CIVIDIS">COLORMAP_CIVIDIS</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLORMAP_COOL">COLORMAP_COOL</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLORMAP_DEEPGREEN">COLORMAP_DEEPGREEN</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLORMAP_HOT">COLORMAP_HOT</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLORMAP_HSV">COLORMAP_HSV</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLORMAP_INFERNO">COLORMAP_INFERNO</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLORMAP_JET">COLORMAP_JET</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLORMAP_MAGMA">COLORMAP_MAGMA</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLORMAP_OCEAN">COLORMAP_OCEAN</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLORMAP_PARULA">COLORMAP_PARULA</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLORMAP_PINK">COLORMAP_PINK</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLORMAP_PLASMA">COLORMAP_PLASMA</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLORMAP_RAINBOW">COLORMAP_RAINBOW</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLORMAP_SPRING">COLORMAP_SPRING</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLORMAP_SUMMER">COLORMAP_SUMMER</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLORMAP_TURBO">COLORMAP_TURBO</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLORMAP_TWILIGHT">COLORMAP_TWILIGHT</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLORMAP_TWILIGHT_SHIFTED">COLORMAP_TWILIGHT_SHIFTED</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLORMAP_VIRIDIS">COLORMAP_VIRIDIS</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#COLORMAP_WINTER">COLORMAP_WINTER</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CONTOURS_MATCH_I1">CONTOURS_MATCH_I1</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CONTOURS_MATCH_I2">CONTOURS_MATCH_I2</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CONTOURS_MATCH_I3">CONTOURS_MATCH_I3</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_BILATERAL">CV_BILATERAL</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_BLUR">CV_BLUR</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_BLUR_NO_SCALE">CV_BLUR_NO_SCALE</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_CANNY_L2_GRADIENT">CV_CANNY_L2_GRADIENT</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_CHAIN_CODE">CV_CHAIN_CODE</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_CLOCKWISE">CV_CLOCKWISE</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_COMP_BHATTACHARYYA">CV_COMP_BHATTACHARYYA</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_COMP_CHISQR">CV_COMP_CHISQR</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_COMP_CHISQR_ALT">CV_COMP_CHISQR_ALT</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_COMP_CORREL">CV_COMP_CORREL</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_COMP_HELLINGER">CV_COMP_HELLINGER</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_COMP_INTERSECT">CV_COMP_INTERSECT</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_COMP_KL_DIV">CV_COMP_KL_DIV</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_CONTOURS_MATCH_I1">CV_CONTOURS_MATCH_I1</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_CONTOURS_MATCH_I2">CV_CONTOURS_MATCH_I2</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_CONTOURS_MATCH_I3">CV_CONTOURS_MATCH_I3</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_COUNTER_CLOCKWISE">CV_COUNTER_CLOCKWISE</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_DIST_C">CV_DIST_C</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_DIST_FAIR">CV_DIST_FAIR</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_DIST_HUBER">CV_DIST_HUBER</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_DIST_L1">CV_DIST_L1</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_DIST_L12">CV_DIST_L12</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_DIST_L2">CV_DIST_L2</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_DIST_LABEL_CCOMP">CV_DIST_LABEL_CCOMP</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_DIST_LABEL_PIXEL">CV_DIST_LABEL_PIXEL</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_DIST_MASK_3">CV_DIST_MASK_3</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_DIST_MASK_5">CV_DIST_MASK_5</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_DIST_MASK_PRECISE">CV_DIST_MASK_PRECISE</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_DIST_USER">CV_DIST_USER</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_DIST_WELSCH">CV_DIST_WELSCH</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_GAUSSIAN">CV_GAUSSIAN</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_GAUSSIAN_5x5">CV_GAUSSIAN_5x5</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_HOUGH_GRADIENT">CV_HOUGH_GRADIENT</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_HOUGH_MULTI_SCALE">CV_HOUGH_MULTI_SCALE</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_HOUGH_PROBABILISTIC">CV_HOUGH_PROBABILISTIC</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_HOUGH_STANDARD">CV_HOUGH_STANDARD</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_LINK_RUNS">CV_LINK_RUNS</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_MAX_SOBEL_KSIZE">CV_MAX_SOBEL_KSIZE</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_MEDIAN">CV_MEDIAN</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_mRGBA2RGBA">CV_mRGBA2RGBA</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_POLY_APPROX_DP">CV_POLY_APPROX_DP</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_RGBA2mRGBA">CV_RGBA2mRGBA</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_SCHARR">CV_SCHARR</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_SHAPE_CROSS">CV_SHAPE_CROSS</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_SHAPE_CUSTOM">CV_SHAPE_CUSTOM</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_SHAPE_ELLIPSE">CV_SHAPE_ELLIPSE</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_SHAPE_RECT">CV_SHAPE_RECT</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_WARP_FILL_OUTLIERS">CV_WARP_FILL_OUTLIERS</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#CV_WARP_INVERSE_MAP">CV_WARP_INVERSE_MAP</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#DIST_C">DIST_C</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#DIST_FAIR">DIST_FAIR</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#DIST_HUBER">DIST_HUBER</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#DIST_L1">DIST_L1</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#DIST_L12">DIST_L12</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#DIST_L2">DIST_L2</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#DIST_LABEL_CCOMP">DIST_LABEL_CCOMP</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#DIST_LABEL_PIXEL">DIST_LABEL_PIXEL</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#DIST_MASK_3">DIST_MASK_3</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#DIST_MASK_5">DIST_MASK_5</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#DIST_MASK_PRECISE">DIST_MASK_PRECISE</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#DIST_USER">DIST_USER</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#DIST_WELSCH">DIST_WELSCH</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#FILLED">FILLED</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#FILTER_SCHARR">FILTER_SCHARR</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#FLOODFILL_FIXED_RANGE">FLOODFILL_FIXED_RANGE</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#FLOODFILL_MASK_ONLY">FLOODFILL_MASK_ONLY</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#FONT_HERSHEY_COMPLEX">FONT_HERSHEY_COMPLEX</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#FONT_HERSHEY_COMPLEX_SMALL">FONT_HERSHEY_COMPLEX_SMALL</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#FONT_HERSHEY_DUPLEX">FONT_HERSHEY_DUPLEX</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#FONT_HERSHEY_PLAIN">FONT_HERSHEY_PLAIN</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#FONT_HERSHEY_SCRIPT_COMPLEX">FONT_HERSHEY_SCRIPT_COMPLEX</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#FONT_HERSHEY_SCRIPT_SIMPLEX">FONT_HERSHEY_SCRIPT_SIMPLEX</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#FONT_HERSHEY_SIMPLEX">FONT_HERSHEY_SIMPLEX</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#FONT_HERSHEY_TRIPLEX">FONT_HERSHEY_TRIPLEX</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#FONT_ITALIC">FONT_ITALIC</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#GC_BGD">GC_BGD</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#GC_EVAL">GC_EVAL</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#GC_EVAL_FREEZE_MODEL">GC_EVAL_FREEZE_MODEL</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#GC_FGD">GC_FGD</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#GC_INIT_WITH_MASK">GC_INIT_WITH_MASK</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#GC_INIT_WITH_RECT">GC_INIT_WITH_RECT</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#GC_PR_BGD">GC_PR_BGD</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#GC_PR_FGD">GC_PR_FGD</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#HISTCMP_BHATTACHARYYA">HISTCMP_BHATTACHARYYA</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#HISTCMP_CHISQR">HISTCMP_CHISQR</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#HISTCMP_CHISQR_ALT">HISTCMP_CHISQR_ALT</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#HISTCMP_CORREL">HISTCMP_CORREL</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#HISTCMP_HELLINGER">HISTCMP_HELLINGER</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#HISTCMP_INTERSECT">HISTCMP_INTERSECT</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#HISTCMP_KL_DIV">HISTCMP_KL_DIV</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#HOUGH_GRADIENT">HOUGH_GRADIENT</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#HOUGH_GRADIENT_ALT">HOUGH_GRADIENT_ALT</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#HOUGH_MULTI_SCALE">HOUGH_MULTI_SCALE</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#HOUGH_PROBABILISTIC">HOUGH_PROBABILISTIC</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#HOUGH_STANDARD">HOUGH_STANDARD</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#INTER_AREA">INTER_AREA</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#INTER_BITS">INTER_BITS</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#INTER_BITS2">INTER_BITS2</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#INTER_CUBIC">INTER_CUBIC</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#INTER_LANCZOS4">INTER_LANCZOS4</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#INTER_LINEAR">INTER_LINEAR</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#INTER_LINEAR_EXACT">INTER_LINEAR_EXACT</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#INTER_MAX">INTER_MAX</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#INTER_NEAREST">INTER_NEAREST</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#INTER_NEAREST_EXACT">INTER_NEAREST_EXACT</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#INTER_TAB_SIZE">INTER_TAB_SIZE</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#INTER_TAB_SIZE2">INTER_TAB_SIZE2</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#INTERSECT_FULL">INTERSECT_FULL</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#INTERSECT_NONE">INTERSECT_NONE</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#INTERSECT_PARTIAL">INTERSECT_PARTIAL</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#LINE_4">LINE_4</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#LINE_8">LINE_8</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#LINE_AA">LINE_AA</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#LSD_REFINE_ADV">LSD_REFINE_ADV</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#LSD_REFINE_NONE">LSD_REFINE_NONE</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#LSD_REFINE_STD">LSD_REFINE_STD</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#MARKER_CROSS">MARKER_CROSS</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#MARKER_DIAMOND">MARKER_DIAMOND</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#MARKER_SQUARE">MARKER_SQUARE</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#MARKER_STAR">MARKER_STAR</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#MARKER_TILTED_CROSS">MARKER_TILTED_CROSS</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#MARKER_TRIANGLE_DOWN">MARKER_TRIANGLE_DOWN</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#MARKER_TRIANGLE_UP">MARKER_TRIANGLE_UP</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#MORPH_BLACKHAT">MORPH_BLACKHAT</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#MORPH_CLOSE">MORPH_CLOSE</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#MORPH_CROSS">MORPH_CROSS</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#MORPH_DILATE">MORPH_DILATE</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#MORPH_ELLIPSE">MORPH_ELLIPSE</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#MORPH_ERODE">MORPH_ERODE</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#MORPH_GRADIENT">MORPH_GRADIENT</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#MORPH_HITMISS">MORPH_HITMISS</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#MORPH_OPEN">MORPH_OPEN</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#MORPH_RECT">MORPH_RECT</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#MORPH_TOPHAT">MORPH_TOPHAT</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#RETR_CCOMP">RETR_CCOMP</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#RETR_EXTERNAL">RETR_EXTERNAL</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#RETR_FLOODFILL">RETR_FLOODFILL</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#RETR_LIST">RETR_LIST</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#RETR_TREE">RETR_TREE</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#THRESH_BINARY">THRESH_BINARY</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#THRESH_BINARY_INV">THRESH_BINARY_INV</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#THRESH_MASK">THRESH_MASK</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#THRESH_OTSU">THRESH_OTSU</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#THRESH_TOZERO">THRESH_TOZERO</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#THRESH_TOZERO_INV">THRESH_TOZERO_INV</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#THRESH_TRIANGLE">THRESH_TRIANGLE</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#THRESH_TRUNC">THRESH_TRUNC</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#TM_CCOEFF">TM_CCOEFF</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#TM_CCOEFF_NORMED">TM_CCOEFF_NORMED</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#TM_CCORR">TM_CCORR</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#TM_CCORR_NORMED">TM_CCORR_NORMED</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#TM_SQDIFF">TM_SQDIFF</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#TM_SQDIFF_NORMED">TM_SQDIFF_NORMED</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#WARP_FILL_OUTLIERS">WARP_FILL_OUTLIERS</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#WARP_INVERSE_MAP">WARP_INVERSE_MAP</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#WARP_POLAR_LINEAR">WARP_POLAR_LINEAR</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#WARP_POLAR_LOG">WARP_POLAR_LOG</a></span></code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#Imgproc--">Imgproc</a></span>()</code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#accumulate-org.opencv.core.Mat-org.opencv.core.Mat-">accumulate</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block">Adds an image to the accumulator image.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#accumulate-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">accumulate</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>
<div class="block">Adds an image to the accumulator image.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#accumulateProduct-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">accumulateProduct</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block">Adds the per-element product of two input images to the accumulator image.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#accumulateProduct-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">accumulateProduct</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>
<div class="block">Adds the per-element product of two input images to the accumulator image.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#accumulateSquare-org.opencv.core.Mat-org.opencv.core.Mat-">accumulateSquare</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block">Adds the square of a source image to the accumulator image.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#accumulateSquare-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">accumulateSquare</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>
<div class="block">Adds the square of a source image to the accumulator image.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#accumulateWeighted-org.opencv.core.Mat-org.opencv.core.Mat-double-">accumulateWeighted</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                  double&nbsp;alpha)</code>
<div class="block">Updates a running average.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#accumulateWeighted-org.opencv.core.Mat-org.opencv.core.Mat-double-org.opencv.core.Mat-">accumulateWeighted</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                  double&nbsp;alpha,
                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>
<div class="block">Updates a running average.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#adaptiveThreshold-org.opencv.core.Mat-org.opencv.core.Mat-double-int-int-int-double-">adaptiveThreshold</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                 double&nbsp;maxValue,
                 int&nbsp;adaptiveMethod,
                 int&nbsp;thresholdType,
                 int&nbsp;blockSize,
                 double&nbsp;C)</code>
<div class="block">Applies an adaptive threshold to an array.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#applyColorMap-org.opencv.core.Mat-org.opencv.core.Mat-int-">applyColorMap</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
             int&nbsp;colormap)</code>
<div class="block">Applies a GNU Octave/MATLAB equivalent colormap on a given image.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#applyColorMap-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">applyColorMap</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;userColor)</code>
<div class="block">Applies a user colormap on a given image.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#approxPolyDP-org.opencv.core.MatOfPoint2f-org.opencv.core.MatOfPoint2f-double-boolean-">approxPolyDP</a></span>(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;curve,
            <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;approxCurve,
            double&nbsp;epsilon,
            boolean&nbsp;closed)</code>
<div class="block">Approximates a polygonal curve(s) with the specified precision.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#arcLength-org.opencv.core.MatOfPoint2f-boolean-">arcLength</a></span>(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;curve,
         boolean&nbsp;closed)</code>
<div class="block">Calculates a contour perimeter or a curve length.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#arrowedLine-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Point-org.opencv.core.Scalar-">arrowedLine</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
           <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt1,
           <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt2,
           <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color)</code>
<div class="block">Draws an arrow segment pointing from the first point to the second one.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#arrowedLine-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Point-org.opencv.core.Scalar-int-">arrowedLine</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
           <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt1,
           <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt2,
           <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
           int&nbsp;thickness)</code>
<div class="block">Draws an arrow segment pointing from the first point to the second one.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#arrowedLine-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Point-org.opencv.core.Scalar-int-int-">arrowedLine</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
           <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt1,
           <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt2,
           <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
           int&nbsp;thickness,
           int&nbsp;line_type)</code>
<div class="block">Draws an arrow segment pointing from the first point to the second one.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#arrowedLine-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Point-org.opencv.core.Scalar-int-int-int-">arrowedLine</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
           <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt1,
           <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt2,
           <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
           int&nbsp;thickness,
           int&nbsp;line_type,
           int&nbsp;shift)</code>
<div class="block">Draws an arrow segment pointing from the first point to the second one.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#arrowedLine-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Point-org.opencv.core.Scalar-int-int-int-double-">arrowedLine</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
           <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt1,
           <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt2,
           <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
           int&nbsp;thickness,
           int&nbsp;line_type,
           int&nbsp;shift,
           double&nbsp;tipLength)</code>
<div class="block">Draws an arrow segment pointing from the first point to the second one.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#bilateralFilter-org.opencv.core.Mat-org.opencv.core.Mat-int-double-double-">bilateralFilter</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
               int&nbsp;d,
               double&nbsp;sigmaColor,
               double&nbsp;sigmaSpace)</code>
<div class="block">Applies the bilateral filter to an image.</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#bilateralFilter-org.opencv.core.Mat-org.opencv.core.Mat-int-double-double-int-">bilateralFilter</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
               int&nbsp;d,
               double&nbsp;sigmaColor,
               double&nbsp;sigmaSpace,
               int&nbsp;borderType)</code>
<div class="block">Applies the bilateral filter to an image.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#blendLinear-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">blendLinear</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;weights1,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;weights2,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block">variant without <code>mask</code> parameter</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#blur-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-">blur</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
    <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize)</code>
<div class="block">Blurs an image using the normalized box filter.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#blur-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-org.opencv.core.Point-">blur</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
    <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
    <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor)</code>
<div class="block">Blurs an image using the normalized box filter.</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#blur-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-org.opencv.core.Point-int-">blur</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
    <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
    <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
    int&nbsp;borderType)</code>
<div class="block">Blurs an image using the normalized box filter.</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#boundingRect-org.opencv.core.Mat-">boundingRect</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;array)</code>
<div class="block">Calculates the up-right bounding rectangle of a point set or non-zero pixels of gray-scale image.</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#boxFilter-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Size-">boxFilter</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
         int&nbsp;ddepth,
         <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize)</code>
<div class="block">Blurs an image using the box filter.</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#boxFilter-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Size-org.opencv.core.Point-">boxFilter</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
         int&nbsp;ddepth,
         <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
         <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor)</code>
<div class="block">Blurs an image using the box filter.</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#boxFilter-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Size-org.opencv.core.Point-boolean-">boxFilter</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
         int&nbsp;ddepth,
         <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
         <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
         boolean&nbsp;normalize)</code>
<div class="block">Blurs an image using the box filter.</div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#boxFilter-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Size-org.opencv.core.Point-boolean-int-">boxFilter</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
         int&nbsp;ddepth,
         <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
         <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
         boolean&nbsp;normalize,
         int&nbsp;borderType)</code>
<div class="block">Blurs an image using the box filter.</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#boxPoints-org.opencv.core.RotatedRect-org.opencv.core.Mat-">boxPoints</a></span>(<a href="../../../org/opencv/core/RotatedRect.html" title="class in org.opencv.core">RotatedRect</a>&nbsp;box,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points)</code>
<div class="block">Finds the four vertices of a rotated rect.</div>
</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#calcBackProject-java.util.List-org.opencv.core.MatOfInt-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.MatOfFloat-double-">calcBackProject</a></span>(java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;images,
               <a href="../../../org/opencv/core/MatOfInt.html" title="class in org.opencv.core">MatOfInt</a>&nbsp;channels,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;hist,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
               <a href="../../../org/opencv/core/MatOfFloat.html" title="class in org.opencv.core">MatOfFloat</a>&nbsp;ranges,
               double&nbsp;scale)</code>&nbsp;</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#calcHist-java.util.List-org.opencv.core.MatOfInt-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.MatOfInt-org.opencv.core.MatOfFloat-">calcHist</a></span>(java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;images,
        <a href="../../../org/opencv/core/MatOfInt.html" title="class in org.opencv.core">MatOfInt</a>&nbsp;channels,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;hist,
        <a href="../../../org/opencv/core/MatOfInt.html" title="class in org.opencv.core">MatOfInt</a>&nbsp;histSize,
        <a href="../../../org/opencv/core/MatOfFloat.html" title="class in org.opencv.core">MatOfFloat</a>&nbsp;ranges)</code>
<div class="block">this variant supports only uniform histograms.</div>
</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#calcHist-java.util.List-org.opencv.core.MatOfInt-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.MatOfInt-org.opencv.core.MatOfFloat-boolean-">calcHist</a></span>(java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;images,
        <a href="../../../org/opencv/core/MatOfInt.html" title="class in org.opencv.core">MatOfInt</a>&nbsp;channels,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;hist,
        <a href="../../../org/opencv/core/MatOfInt.html" title="class in org.opencv.core">MatOfInt</a>&nbsp;histSize,
        <a href="../../../org/opencv/core/MatOfFloat.html" title="class in org.opencv.core">MatOfFloat</a>&nbsp;ranges,
        boolean&nbsp;accumulate)</code>
<div class="block">this variant supports only uniform histograms.</div>
</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#Canny-org.opencv.core.Mat-org.opencv.core.Mat-double-double-">Canny</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;edges,
     double&nbsp;threshold1,
     double&nbsp;threshold2)</code>
<div class="block">Finds edges in an image using the Canny algorithm CITE: Canny86 .</div>
</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#Canny-org.opencv.core.Mat-org.opencv.core.Mat-double-double-int-">Canny</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;edges,
     double&nbsp;threshold1,
     double&nbsp;threshold2,
     int&nbsp;apertureSize)</code>
<div class="block">Finds edges in an image using the Canny algorithm CITE: Canny86 .</div>
</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#Canny-org.opencv.core.Mat-org.opencv.core.Mat-double-double-int-boolean-">Canny</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;edges,
     double&nbsp;threshold1,
     double&nbsp;threshold2,
     int&nbsp;apertureSize,
     boolean&nbsp;L2gradient)</code>
<div class="block">Finds edges in an image using the Canny algorithm CITE: Canny86 .</div>
</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#Canny-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-double-">Canny</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dx,
     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dy,
     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;edges,
     double&nbsp;threshold1,
     double&nbsp;threshold2)</code>
<div class="block">\overload

 Finds edges in an image using the Canny algorithm with custom image gradient.</div>
</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#Canny-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-double-boolean-">Canny</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dx,
     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dy,
     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;edges,
     double&nbsp;threshold1,
     double&nbsp;threshold2,
     boolean&nbsp;L2gradient)</code>
<div class="block">\overload

 Finds edges in an image using the Canny algorithm with custom image gradient.</div>
</td>
</tr>
<tr id="i38" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#circle-org.opencv.core.Mat-org.opencv.core.Point-int-org.opencv.core.Scalar-">circle</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
      <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
      int&nbsp;radius,
      <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color)</code>
<div class="block">Draws a circle.</div>
</td>
</tr>
<tr id="i39" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#circle-org.opencv.core.Mat-org.opencv.core.Point-int-org.opencv.core.Scalar-int-">circle</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
      <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
      int&nbsp;radius,
      <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
      int&nbsp;thickness)</code>
<div class="block">Draws a circle.</div>
</td>
</tr>
<tr id="i40" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#circle-org.opencv.core.Mat-org.opencv.core.Point-int-org.opencv.core.Scalar-int-int-">circle</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
      <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
      int&nbsp;radius,
      <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
      int&nbsp;thickness,
      int&nbsp;lineType)</code>
<div class="block">Draws a circle.</div>
</td>
</tr>
<tr id="i41" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#circle-org.opencv.core.Mat-org.opencv.core.Point-int-org.opencv.core.Scalar-int-int-int-">circle</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
      <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
      int&nbsp;radius,
      <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
      int&nbsp;thickness,
      int&nbsp;lineType,
      int&nbsp;shift)</code>
<div class="block">Draws a circle.</div>
</td>
</tr>
<tr id="i42" class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#clipLine-org.opencv.core.Rect-org.opencv.core.Point-org.opencv.core.Point-">clipLine</a></span>(<a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;imgRect,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt1,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt2)</code>&nbsp;</td>
</tr>
<tr id="i43" class="rowColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#compareHist-org.opencv.core.Mat-org.opencv.core.Mat-int-">compareHist</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;H1,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;H2,
           int&nbsp;method)</code>
<div class="block">Compares two histograms.</div>
</td>
</tr>
<tr id="i44" class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#connectedComponents-org.opencv.core.Mat-org.opencv.core.Mat-">connectedComponents</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;labels)</code>&nbsp;</td>
</tr>
<tr id="i45" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#connectedComponents-org.opencv.core.Mat-org.opencv.core.Mat-int-">connectedComponents</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;labels,
                   int&nbsp;connectivity)</code>&nbsp;</td>
</tr>
<tr id="i46" class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#connectedComponents-org.opencv.core.Mat-org.opencv.core.Mat-int-int-">connectedComponents</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;labels,
                   int&nbsp;connectivity,
                   int&nbsp;ltype)</code>&nbsp;</td>
</tr>
<tr id="i47" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#connectedComponentsWithAlgorithm-org.opencv.core.Mat-org.opencv.core.Mat-int-int-int-">connectedComponentsWithAlgorithm</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;labels,
                                int&nbsp;connectivity,
                                int&nbsp;ltype,
                                int&nbsp;ccltype)</code>
<div class="block">computes the connected components labeled image of boolean image

 image with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0
 represents the background label.</div>
</td>
</tr>
<tr id="i48" class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#connectedComponentsWithStats-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">connectedComponentsWithStats</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;labels,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;stats,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;centroids)</code>&nbsp;</td>
</tr>
<tr id="i49" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#connectedComponentsWithStats-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">connectedComponentsWithStats</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;labels,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;stats,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;centroids,
                            int&nbsp;connectivity)</code>&nbsp;</td>
</tr>
<tr id="i50" class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#connectedComponentsWithStats-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-int-">connectedComponentsWithStats</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;labels,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;stats,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;centroids,
                            int&nbsp;connectivity,
                            int&nbsp;ltype)</code>&nbsp;</td>
</tr>
<tr id="i51" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#connectedComponentsWithStatsWithAlgorithm-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-int-int-">connectedComponentsWithStatsWithAlgorithm</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;labels,
                                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;stats,
                                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;centroids,
                                         int&nbsp;connectivity,
                                         int&nbsp;ltype,
                                         int&nbsp;ccltype)</code>
<div class="block">computes the connected components labeled image of boolean image and also produces a statistics output for each label

 image with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0
 represents the background label.</div>
</td>
</tr>
<tr id="i52" class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#contourArea-org.opencv.core.Mat-">contourArea</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;contour)</code>
<div class="block">Calculates a contour area.</div>
</td>
</tr>
<tr id="i53" class="rowColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#contourArea-org.opencv.core.Mat-boolean-">contourArea</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;contour,
           boolean&nbsp;oriented)</code>
<div class="block">Calculates a contour area.</div>
</td>
</tr>
<tr id="i54" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#convertMaps-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">convertMaps</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map1,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map2,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dstmap1,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dstmap2,
           int&nbsp;dstmap1type)</code>
<div class="block">Converts image transformation maps from one representation to another.</div>
</td>
</tr>
<tr id="i55" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#convertMaps-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-boolean-">convertMaps</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map1,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map2,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dstmap1,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dstmap2,
           int&nbsp;dstmap1type,
           boolean&nbsp;nninterpolation)</code>
<div class="block">Converts image transformation maps from one representation to another.</div>
</td>
</tr>
<tr id="i56" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#convexHull-org.opencv.core.MatOfPoint-org.opencv.core.MatOfInt-">convexHull</a></span>(<a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&nbsp;points,
          <a href="../../../org/opencv/core/MatOfInt.html" title="class in org.opencv.core">MatOfInt</a>&nbsp;hull)</code>
<div class="block">Finds the convex hull of a point set.</div>
</td>
</tr>
<tr id="i57" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#convexHull-org.opencv.core.MatOfPoint-org.opencv.core.MatOfInt-boolean-">convexHull</a></span>(<a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&nbsp;points,
          <a href="../../../org/opencv/core/MatOfInt.html" title="class in org.opencv.core">MatOfInt</a>&nbsp;hull,
          boolean&nbsp;clockwise)</code>
<div class="block">Finds the convex hull of a point set.</div>
</td>
</tr>
<tr id="i58" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#convexityDefects-org.opencv.core.MatOfPoint-org.opencv.core.MatOfInt-org.opencv.core.MatOfInt4-">convexityDefects</a></span>(<a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&nbsp;contour,
                <a href="../../../org/opencv/core/MatOfInt.html" title="class in org.opencv.core">MatOfInt</a>&nbsp;convexhull,
                <a href="../../../org/opencv/core/MatOfInt4.html" title="class in org.opencv.core">MatOfInt4</a>&nbsp;convexityDefects)</code>
<div class="block">Finds the convexity defects of a contour.</div>
</td>
</tr>
<tr id="i59" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#cornerEigenValsAndVecs-org.opencv.core.Mat-org.opencv.core.Mat-int-int-">cornerEigenValsAndVecs</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                      int&nbsp;blockSize,
                      int&nbsp;ksize)</code>
<div class="block">Calculates eigenvalues and eigenvectors of image blocks for corner detection.</div>
</td>
</tr>
<tr id="i60" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#cornerEigenValsAndVecs-org.opencv.core.Mat-org.opencv.core.Mat-int-int-int-">cornerEigenValsAndVecs</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                      int&nbsp;blockSize,
                      int&nbsp;ksize,
                      int&nbsp;borderType)</code>
<div class="block">Calculates eigenvalues and eigenvectors of image blocks for corner detection.</div>
</td>
</tr>
<tr id="i61" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#cornerHarris-org.opencv.core.Mat-org.opencv.core.Mat-int-int-double-">cornerHarris</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
            int&nbsp;blockSize,
            int&nbsp;ksize,
            double&nbsp;k)</code>
<div class="block">Harris corner detector.</div>
</td>
</tr>
<tr id="i62" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#cornerHarris-org.opencv.core.Mat-org.opencv.core.Mat-int-int-double-int-">cornerHarris</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
            int&nbsp;blockSize,
            int&nbsp;ksize,
            double&nbsp;k,
            int&nbsp;borderType)</code>
<div class="block">Harris corner detector.</div>
</td>
</tr>
<tr id="i63" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#cornerMinEigenVal-org.opencv.core.Mat-org.opencv.core.Mat-int-">cornerMinEigenVal</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                 int&nbsp;blockSize)</code>
<div class="block">Calculates the minimal eigenvalue of gradient matrices for corner detection.</div>
</td>
</tr>
<tr id="i64" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#cornerMinEigenVal-org.opencv.core.Mat-org.opencv.core.Mat-int-int-">cornerMinEigenVal</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                 int&nbsp;blockSize,
                 int&nbsp;ksize)</code>
<div class="block">Calculates the minimal eigenvalue of gradient matrices for corner detection.</div>
</td>
</tr>
<tr id="i65" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#cornerMinEigenVal-org.opencv.core.Mat-org.opencv.core.Mat-int-int-int-">cornerMinEigenVal</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                 int&nbsp;blockSize,
                 int&nbsp;ksize,
                 int&nbsp;borderType)</code>
<div class="block">Calculates the minimal eigenvalue of gradient matrices for corner detection.</div>
</td>
</tr>
<tr id="i66" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#cornerSubPix-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-org.opencv.core.Size-org.opencv.core.TermCriteria-">cornerSubPix</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;corners,
            <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;winSize,
            <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;zeroZone,
            <a href="../../../org/opencv/core/TermCriteria.html" title="class in org.opencv.core">TermCriteria</a>&nbsp;criteria)</code>
<div class="block">Refines the corner locations.</div>
</td>
</tr>
<tr id="i67" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/imgproc/CLAHE.html" title="class in org.opencv.imgproc">CLAHE</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#createCLAHE--">createCLAHE</a></span>()</code>
<div class="block">Creates a smart pointer to a cv::CLAHE class and initializes it.</div>
</td>
</tr>
<tr id="i68" class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/imgproc/CLAHE.html" title="class in org.opencv.imgproc">CLAHE</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#createCLAHE-double-">createCLAHE</a></span>(double&nbsp;clipLimit)</code>
<div class="block">Creates a smart pointer to a cv::CLAHE class and initializes it.</div>
</td>
</tr>
<tr id="i69" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/imgproc/CLAHE.html" title="class in org.opencv.imgproc">CLAHE</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#createCLAHE-double-org.opencv.core.Size-">createCLAHE</a></span>(double&nbsp;clipLimit,
           <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;tileGridSize)</code>
<div class="block">Creates a smart pointer to a cv::CLAHE class and initializes it.</div>
</td>
</tr>
<tr id="i70" class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/imgproc/GeneralizedHoughBallard.html" title="class in org.opencv.imgproc">GeneralizedHoughBallard</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#createGeneralizedHoughBallard--">createGeneralizedHoughBallard</a></span>()</code>
<div class="block">Creates a smart pointer to a cv::GeneralizedHoughBallard class and initializes it.</div>
</td>
</tr>
<tr id="i71" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/imgproc/GeneralizedHoughGuil.html" title="class in org.opencv.imgproc">GeneralizedHoughGuil</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#createGeneralizedHoughGuil--">createGeneralizedHoughGuil</a></span>()</code>
<div class="block">Creates a smart pointer to a cv::GeneralizedHoughGuil class and initializes it.</div>
</td>
</tr>
<tr id="i72" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#createHanningWindow-org.opencv.core.Mat-org.opencv.core.Size-int-">createHanningWindow</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                   <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;winSize,
                   int&nbsp;type)</code>
<div class="block">This function computes a Hanning window coefficients in two dimensions.</div>
</td>
</tr>
<tr id="i73" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/imgproc/LineSegmentDetector.html" title="class in org.opencv.imgproc">LineSegmentDetector</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#createLineSegmentDetector--">createLineSegmentDetector</a></span>()</code>
<div class="block">Creates a smart pointer to a LineSegmentDetector object and initializes it.</div>
</td>
</tr>
<tr id="i74" class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/imgproc/LineSegmentDetector.html" title="class in org.opencv.imgproc">LineSegmentDetector</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#createLineSegmentDetector-int-">createLineSegmentDetector</a></span>(int&nbsp;refine)</code>
<div class="block">Creates a smart pointer to a LineSegmentDetector object and initializes it.</div>
</td>
</tr>
<tr id="i75" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/imgproc/LineSegmentDetector.html" title="class in org.opencv.imgproc">LineSegmentDetector</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#createLineSegmentDetector-int-double-">createLineSegmentDetector</a></span>(int&nbsp;refine,
                         double&nbsp;scale)</code>
<div class="block">Creates a smart pointer to a LineSegmentDetector object and initializes it.</div>
</td>
</tr>
<tr id="i76" class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/imgproc/LineSegmentDetector.html" title="class in org.opencv.imgproc">LineSegmentDetector</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#createLineSegmentDetector-int-double-double-">createLineSegmentDetector</a></span>(int&nbsp;refine,
                         double&nbsp;scale,
                         double&nbsp;sigma_scale)</code>
<div class="block">Creates a smart pointer to a LineSegmentDetector object and initializes it.</div>
</td>
</tr>
<tr id="i77" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/imgproc/LineSegmentDetector.html" title="class in org.opencv.imgproc">LineSegmentDetector</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#createLineSegmentDetector-int-double-double-double-">createLineSegmentDetector</a></span>(int&nbsp;refine,
                         double&nbsp;scale,
                         double&nbsp;sigma_scale,
                         double&nbsp;quant)</code>
<div class="block">Creates a smart pointer to a LineSegmentDetector object and initializes it.</div>
</td>
</tr>
<tr id="i78" class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/imgproc/LineSegmentDetector.html" title="class in org.opencv.imgproc">LineSegmentDetector</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#createLineSegmentDetector-int-double-double-double-double-">createLineSegmentDetector</a></span>(int&nbsp;refine,
                         double&nbsp;scale,
                         double&nbsp;sigma_scale,
                         double&nbsp;quant,
                         double&nbsp;ang_th)</code>
<div class="block">Creates a smart pointer to a LineSegmentDetector object and initializes it.</div>
</td>
</tr>
<tr id="i79" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/imgproc/LineSegmentDetector.html" title="class in org.opencv.imgproc">LineSegmentDetector</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#createLineSegmentDetector-int-double-double-double-double-double-">createLineSegmentDetector</a></span>(int&nbsp;refine,
                         double&nbsp;scale,
                         double&nbsp;sigma_scale,
                         double&nbsp;quant,
                         double&nbsp;ang_th,
                         double&nbsp;log_eps)</code>
<div class="block">Creates a smart pointer to a LineSegmentDetector object and initializes it.</div>
</td>
</tr>
<tr id="i80" class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/imgproc/LineSegmentDetector.html" title="class in org.opencv.imgproc">LineSegmentDetector</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#createLineSegmentDetector-int-double-double-double-double-double-double-">createLineSegmentDetector</a></span>(int&nbsp;refine,
                         double&nbsp;scale,
                         double&nbsp;sigma_scale,
                         double&nbsp;quant,
                         double&nbsp;ang_th,
                         double&nbsp;log_eps,
                         double&nbsp;density_th)</code>
<div class="block">Creates a smart pointer to a LineSegmentDetector object and initializes it.</div>
</td>
</tr>
<tr id="i81" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/imgproc/LineSegmentDetector.html" title="class in org.opencv.imgproc">LineSegmentDetector</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#createLineSegmentDetector-int-double-double-double-double-double-double-int-">createLineSegmentDetector</a></span>(int&nbsp;refine,
                         double&nbsp;scale,
                         double&nbsp;sigma_scale,
                         double&nbsp;quant,
                         double&nbsp;ang_th,
                         double&nbsp;log_eps,
                         double&nbsp;density_th,
                         int&nbsp;n_bins)</code>
<div class="block">Creates a smart pointer to a LineSegmentDetector object and initializes it.</div>
</td>
</tr>
<tr id="i82" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#cvtColor-org.opencv.core.Mat-org.opencv.core.Mat-int-">cvtColor</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;code)</code>
<div class="block">Converts an image from one color space to another.</div>
</td>
</tr>
<tr id="i83" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#cvtColor-org.opencv.core.Mat-org.opencv.core.Mat-int-int-">cvtColor</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;code,
        int&nbsp;dstCn)</code>
<div class="block">Converts an image from one color space to another.</div>
</td>
</tr>
<tr id="i84" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#cvtColorTwoPlane-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">cvtColorTwoPlane</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                int&nbsp;code)</code>
<div class="block">Converts an image from one color space to another where the source image is
 stored in two planes.</div>
</td>
</tr>
<tr id="i85" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#demosaicing-org.opencv.core.Mat-org.opencv.core.Mat-int-">demosaicing</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
           int&nbsp;code)</code>
<div class="block">main function for all demosaicing processes</div>
</td>
</tr>
<tr id="i86" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#demosaicing-org.opencv.core.Mat-org.opencv.core.Mat-int-int-">demosaicing</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
           int&nbsp;code,
           int&nbsp;dstCn)</code>
<div class="block">main function for all demosaicing processes</div>
</td>
</tr>
<tr id="i87" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#dilate-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">dilate</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel)</code>
<div class="block">Dilates an image by using a specific structuring element.</div>
</td>
</tr>
<tr id="i88" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#dilate-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Point-">dilate</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel,
      <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor)</code>
<div class="block">Dilates an image by using a specific structuring element.</div>
</td>
</tr>
<tr id="i89" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#dilate-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Point-int-">dilate</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel,
      <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
      int&nbsp;iterations)</code>
<div class="block">Dilates an image by using a specific structuring element.</div>
</td>
</tr>
<tr id="i90" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#dilate-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Point-int-int-">dilate</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel,
      <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
      int&nbsp;iterations,
      int&nbsp;borderType)</code>
<div class="block">Dilates an image by using a specific structuring element.</div>
</td>
</tr>
<tr id="i91" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#dilate-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Point-int-int-org.opencv.core.Scalar-">dilate</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel,
      <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
      int&nbsp;iterations,
      int&nbsp;borderType,
      <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;borderValue)</code>
<div class="block">Dilates an image by using a specific structuring element.</div>
</td>
</tr>
<tr id="i92" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#distanceTransform-org.opencv.core.Mat-org.opencv.core.Mat-int-int-">distanceTransform</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                 int&nbsp;distanceType,
                 int&nbsp;maskSize)</code>&nbsp;</td>
</tr>
<tr id="i93" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#distanceTransform-org.opencv.core.Mat-org.opencv.core.Mat-int-int-int-">distanceTransform</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                 int&nbsp;distanceType,
                 int&nbsp;maskSize,
                 int&nbsp;dstType)</code>&nbsp;</td>
</tr>
<tr id="i94" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#distanceTransformWithLabels-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-int-">distanceTransformWithLabels</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;labels,
                           int&nbsp;distanceType,
                           int&nbsp;maskSize)</code>
<div class="block">Calculates the distance to the closest zero pixel for each pixel of the source image.</div>
</td>
</tr>
<tr id="i95" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#distanceTransformWithLabels-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-int-int-">distanceTransformWithLabels</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;labels,
                           int&nbsp;distanceType,
                           int&nbsp;maskSize,
                           int&nbsp;labelType)</code>
<div class="block">Calculates the distance to the closest zero pixel for each pixel of the source image.</div>
</td>
</tr>
<tr id="i96" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#divSpectrums-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">divSpectrums</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;a,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;b,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;c,
            int&nbsp;flags)</code>
<div class="block">Performs the per-element division of the first Fourier spectrum by the second Fourier spectrum.</div>
</td>
</tr>
<tr id="i97" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#divSpectrums-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-boolean-">divSpectrums</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;a,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;b,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;c,
            int&nbsp;flags,
            boolean&nbsp;conjB)</code>
<div class="block">Performs the per-element division of the first Fourier spectrum by the second Fourier spectrum.</div>
</td>
</tr>
<tr id="i98" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#drawContours-org.opencv.core.Mat-java.util.List-int-org.opencv.core.Scalar-">drawContours</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
            java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;contours,
            int&nbsp;contourIdx,
            <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color)</code>
<div class="block">Draws contours outlines or filled contours.</div>
</td>
</tr>
<tr id="i99" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#drawContours-org.opencv.core.Mat-java.util.List-int-org.opencv.core.Scalar-int-">drawContours</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
            java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;contours,
            int&nbsp;contourIdx,
            <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
            int&nbsp;thickness)</code>
<div class="block">Draws contours outlines or filled contours.</div>
</td>
</tr>
<tr id="i100" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#drawContours-org.opencv.core.Mat-java.util.List-int-org.opencv.core.Scalar-int-int-">drawContours</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
            java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;contours,
            int&nbsp;contourIdx,
            <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
            int&nbsp;thickness,
            int&nbsp;lineType)</code>
<div class="block">Draws contours outlines or filled contours.</div>
</td>
</tr>
<tr id="i101" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#drawContours-org.opencv.core.Mat-java.util.List-int-org.opencv.core.Scalar-int-int-org.opencv.core.Mat-">drawContours</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
            java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;contours,
            int&nbsp;contourIdx,
            <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
            int&nbsp;thickness,
            int&nbsp;lineType,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;hierarchy)</code>
<div class="block">Draws contours outlines or filled contours.</div>
</td>
</tr>
<tr id="i102" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#drawContours-org.opencv.core.Mat-java.util.List-int-org.opencv.core.Scalar-int-int-org.opencv.core.Mat-int-">drawContours</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
            java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;contours,
            int&nbsp;contourIdx,
            <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
            int&nbsp;thickness,
            int&nbsp;lineType,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;hierarchy,
            int&nbsp;maxLevel)</code>
<div class="block">Draws contours outlines or filled contours.</div>
</td>
</tr>
<tr id="i103" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#drawContours-org.opencv.core.Mat-java.util.List-int-org.opencv.core.Scalar-int-int-org.opencv.core.Mat-int-org.opencv.core.Point-">drawContours</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
            java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;contours,
            int&nbsp;contourIdx,
            <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
            int&nbsp;thickness,
            int&nbsp;lineType,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;hierarchy,
            int&nbsp;maxLevel,
            <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;offset)</code>
<div class="block">Draws contours outlines or filled contours.</div>
</td>
</tr>
<tr id="i104" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#drawMarker-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Scalar-">drawMarker</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
          <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;position,
          <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color)</code>
<div class="block">Draws a marker on a predefined position in an image.</div>
</td>
</tr>
<tr id="i105" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#drawMarker-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Scalar-int-">drawMarker</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
          <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;position,
          <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
          int&nbsp;markerType)</code>
<div class="block">Draws a marker on a predefined position in an image.</div>
</td>
</tr>
<tr id="i106" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#drawMarker-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Scalar-int-int-">drawMarker</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
          <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;position,
          <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
          int&nbsp;markerType,
          int&nbsp;markerSize)</code>
<div class="block">Draws a marker on a predefined position in an image.</div>
</td>
</tr>
<tr id="i107" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#drawMarker-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Scalar-int-int-int-">drawMarker</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
          <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;position,
          <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
          int&nbsp;markerType,
          int&nbsp;markerSize,
          int&nbsp;thickness)</code>
<div class="block">Draws a marker on a predefined position in an image.</div>
</td>
</tr>
<tr id="i108" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#drawMarker-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Scalar-int-int-int-int-">drawMarker</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
          <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;position,
          <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
          int&nbsp;markerType,
          int&nbsp;markerSize,
          int&nbsp;thickness,
          int&nbsp;line_type)</code>
<div class="block">Draws a marker on a predefined position in an image.</div>
</td>
</tr>
<tr id="i109" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#ellipse-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Size-double-double-double-org.opencv.core.Scalar-">ellipse</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
       <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
       <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;axes,
       double&nbsp;angle,
       double&nbsp;startAngle,
       double&nbsp;endAngle,
       <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color)</code>
<div class="block">Draws a simple or thick elliptic arc or fills an ellipse sector.</div>
</td>
</tr>
<tr id="i110" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#ellipse-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Size-double-double-double-org.opencv.core.Scalar-int-">ellipse</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
       <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
       <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;axes,
       double&nbsp;angle,
       double&nbsp;startAngle,
       double&nbsp;endAngle,
       <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
       int&nbsp;thickness)</code>
<div class="block">Draws a simple or thick elliptic arc or fills an ellipse sector.</div>
</td>
</tr>
<tr id="i111" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#ellipse-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Size-double-double-double-org.opencv.core.Scalar-int-int-">ellipse</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
       <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
       <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;axes,
       double&nbsp;angle,
       double&nbsp;startAngle,
       double&nbsp;endAngle,
       <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
       int&nbsp;thickness,
       int&nbsp;lineType)</code>
<div class="block">Draws a simple or thick elliptic arc or fills an ellipse sector.</div>
</td>
</tr>
<tr id="i112" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#ellipse-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Size-double-double-double-org.opencv.core.Scalar-int-int-int-">ellipse</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
       <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
       <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;axes,
       double&nbsp;angle,
       double&nbsp;startAngle,
       double&nbsp;endAngle,
       <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
       int&nbsp;thickness,
       int&nbsp;lineType,
       int&nbsp;shift)</code>
<div class="block">Draws a simple or thick elliptic arc or fills an ellipse sector.</div>
</td>
</tr>
<tr id="i113" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#ellipse-org.opencv.core.Mat-org.opencv.core.RotatedRect-org.opencv.core.Scalar-">ellipse</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
       <a href="../../../org/opencv/core/RotatedRect.html" title="class in org.opencv.core">RotatedRect</a>&nbsp;box,
       <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color)</code>&nbsp;</td>
</tr>
<tr id="i114" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#ellipse-org.opencv.core.Mat-org.opencv.core.RotatedRect-org.opencv.core.Scalar-int-">ellipse</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
       <a href="../../../org/opencv/core/RotatedRect.html" title="class in org.opencv.core">RotatedRect</a>&nbsp;box,
       <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
       int&nbsp;thickness)</code>&nbsp;</td>
</tr>
<tr id="i115" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#ellipse-org.opencv.core.Mat-org.opencv.core.RotatedRect-org.opencv.core.Scalar-int-int-">ellipse</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
       <a href="../../../org/opencv/core/RotatedRect.html" title="class in org.opencv.core">RotatedRect</a>&nbsp;box,
       <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
       int&nbsp;thickness,
       int&nbsp;lineType)</code>&nbsp;</td>
</tr>
<tr id="i116" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#ellipse2Poly-org.opencv.core.Point-org.opencv.core.Size-int-int-int-int-org.opencv.core.MatOfPoint-">ellipse2Poly</a></span>(<a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
            <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;axes,
            int&nbsp;angle,
            int&nbsp;arcStart,
            int&nbsp;arcEnd,
            int&nbsp;delta,
            <a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&nbsp;pts)</code>
<div class="block">Approximates an elliptic arc with a polyline.</div>
</td>
</tr>
<tr id="i117" class="rowColor">
<td class="colFirst"><code>static float</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#EMD-org.opencv.core.Mat-org.opencv.core.Mat-int-">EMD</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;signature1,
   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;signature2,
   int&nbsp;distType)</code>
<div class="block">Computes the "minimal work" distance between two weighted point configurations.</div>
</td>
</tr>
<tr id="i118" class="altColor">
<td class="colFirst"><code>static float</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#EMD-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Mat-">EMD</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;signature1,
   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;signature2,
   int&nbsp;distType,
   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cost)</code>
<div class="block">Computes the "minimal work" distance between two weighted point configurations.</div>
</td>
</tr>
<tr id="i119" class="rowColor">
<td class="colFirst"><code>static float</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#EMD-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Mat-org.opencv.core.Mat-">EMD</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;signature1,
   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;signature2,
   int&nbsp;distType,
   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cost,
   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;flow)</code>
<div class="block">Computes the "minimal work" distance between two weighted point configurations.</div>
</td>
</tr>
<tr id="i120" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#equalizeHist-org.opencv.core.Mat-org.opencv.core.Mat-">equalizeHist</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block">Equalizes the histogram of a grayscale image.</div>
</td>
</tr>
<tr id="i121" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#erode-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">erode</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel)</code>
<div class="block">Erodes an image by using a specific structuring element.</div>
</td>
</tr>
<tr id="i122" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#erode-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Point-">erode</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel,
     <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor)</code>
<div class="block">Erodes an image by using a specific structuring element.</div>
</td>
</tr>
<tr id="i123" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#erode-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Point-int-">erode</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel,
     <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
     int&nbsp;iterations)</code>
<div class="block">Erodes an image by using a specific structuring element.</div>
</td>
</tr>
<tr id="i124" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#erode-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Point-int-int-">erode</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel,
     <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
     int&nbsp;iterations,
     int&nbsp;borderType)</code>
<div class="block">Erodes an image by using a specific structuring element.</div>
</td>
</tr>
<tr id="i125" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#erode-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Point-int-int-org.opencv.core.Scalar-">erode</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel,
     <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
     int&nbsp;iterations,
     int&nbsp;borderType,
     <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;borderValue)</code>
<div class="block">Erodes an image by using a specific structuring element.</div>
</td>
</tr>
<tr id="i126" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#fillConvexPoly-org.opencv.core.Mat-org.opencv.core.MatOfPoint-org.opencv.core.Scalar-">fillConvexPoly</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
              <a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&nbsp;points,
              <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color)</code>
<div class="block">Fills a convex polygon.</div>
</td>
</tr>
<tr id="i127" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#fillConvexPoly-org.opencv.core.Mat-org.opencv.core.MatOfPoint-org.opencv.core.Scalar-int-">fillConvexPoly</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
              <a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&nbsp;points,
              <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
              int&nbsp;lineType)</code>
<div class="block">Fills a convex polygon.</div>
</td>
</tr>
<tr id="i128" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#fillConvexPoly-org.opencv.core.Mat-org.opencv.core.MatOfPoint-org.opencv.core.Scalar-int-int-">fillConvexPoly</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
              <a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&nbsp;points,
              <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
              int&nbsp;lineType,
              int&nbsp;shift)</code>
<div class="block">Fills a convex polygon.</div>
</td>
</tr>
<tr id="i129" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#fillPoly-org.opencv.core.Mat-java.util.List-org.opencv.core.Scalar-">fillPoly</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
        java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;pts,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color)</code>
<div class="block">Fills the area bounded by one or more polygons.</div>
</td>
</tr>
<tr id="i130" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#fillPoly-org.opencv.core.Mat-java.util.List-org.opencv.core.Scalar-int-">fillPoly</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
        java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;pts,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
        int&nbsp;lineType)</code>
<div class="block">Fills the area bounded by one or more polygons.</div>
</td>
</tr>
<tr id="i131" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#fillPoly-org.opencv.core.Mat-java.util.List-org.opencv.core.Scalar-int-int-">fillPoly</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
        java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;pts,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
        int&nbsp;lineType,
        int&nbsp;shift)</code>
<div class="block">Fills the area bounded by one or more polygons.</div>
</td>
</tr>
<tr id="i132" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#fillPoly-org.opencv.core.Mat-java.util.List-org.opencv.core.Scalar-int-int-org.opencv.core.Point-">fillPoly</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
        java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;pts,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
        int&nbsp;lineType,
        int&nbsp;shift,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;offset)</code>
<div class="block">Fills the area bounded by one or more polygons.</div>
</td>
</tr>
<tr id="i133" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#filter2D-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Mat-">filter2D</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;ddepth,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel)</code>
<div class="block">Convolves an image with the kernel.</div>
</td>
</tr>
<tr id="i134" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#filter2D-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Mat-org.opencv.core.Point-">filter2D</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;ddepth,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor)</code>
<div class="block">Convolves an image with the kernel.</div>
</td>
</tr>
<tr id="i135" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#filter2D-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Mat-org.opencv.core.Point-double-">filter2D</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;ddepth,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
        double&nbsp;delta)</code>
<div class="block">Convolves an image with the kernel.</div>
</td>
</tr>
<tr id="i136" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#filter2D-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Mat-org.opencv.core.Point-double-int-">filter2D</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        int&nbsp;ddepth,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel,
        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
        double&nbsp;delta,
        int&nbsp;borderType)</code>
<div class="block">Convolves an image with the kernel.</div>
</td>
</tr>
<tr id="i137" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#findContours-org.opencv.core.Mat-java.util.List-org.opencv.core.Mat-int-int-">findContours</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
            java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;contours,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;hierarchy,
            int&nbsp;mode,
            int&nbsp;method)</code>
<div class="block">Finds contours in a binary image.</div>
</td>
</tr>
<tr id="i138" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#findContours-org.opencv.core.Mat-java.util.List-org.opencv.core.Mat-int-int-org.opencv.core.Point-">findContours</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
            java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;contours,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;hierarchy,
            int&nbsp;mode,
            int&nbsp;method,
            <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;offset)</code>
<div class="block">Finds contours in a binary image.</div>
</td>
</tr>
<tr id="i139" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/RotatedRect.html" title="class in org.opencv.core">RotatedRect</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#fitEllipse-org.opencv.core.MatOfPoint2f-">fitEllipse</a></span>(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points)</code>
<div class="block">Fits an ellipse around a set of 2D points.</div>
</td>
</tr>
<tr id="i140" class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/RotatedRect.html" title="class in org.opencv.core">RotatedRect</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#fitEllipseAMS-org.opencv.core.Mat-">fitEllipseAMS</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points)</code>
<div class="block">Fits an ellipse around a set of 2D points.</div>
</td>
</tr>
<tr id="i141" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/RotatedRect.html" title="class in org.opencv.core">RotatedRect</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#fitEllipseDirect-org.opencv.core.Mat-">fitEllipseDirect</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points)</code>
<div class="block">Fits an ellipse around a set of 2D points.</div>
</td>
</tr>
<tr id="i142" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#fitLine-org.opencv.core.Mat-org.opencv.core.Mat-int-double-double-double-">fitLine</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;line,
       int&nbsp;distType,
       double&nbsp;param,
       double&nbsp;reps,
       double&nbsp;aeps)</code>
<div class="block">Fits a line to a 2D or 3D point set.</div>
</td>
</tr>
<tr id="i143" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#floodFill-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Scalar-">floodFill</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
         <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;seedPoint,
         <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;newVal)</code>
<div class="block">Fills a connected component with the given color.</div>
</td>
</tr>
<tr id="i144" class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#floodFill-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Scalar-org.opencv.core.Rect-">floodFill</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
         <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;seedPoint,
         <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;newVal,
         <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;rect)</code>
<div class="block">Fills a connected component with the given color.</div>
</td>
</tr>
<tr id="i145" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#floodFill-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Scalar-org.opencv.core.Rect-org.opencv.core.Scalar-">floodFill</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
         <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;seedPoint,
         <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;newVal,
         <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;rect,
         <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;loDiff)</code>
<div class="block">Fills a connected component with the given color.</div>
</td>
</tr>
<tr id="i146" class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#floodFill-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Scalar-org.opencv.core.Rect-org.opencv.core.Scalar-org.opencv.core.Scalar-">floodFill</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
         <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;seedPoint,
         <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;newVal,
         <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;rect,
         <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;loDiff,
         <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;upDiff)</code>
<div class="block">Fills a connected component with the given color.</div>
</td>
</tr>
<tr id="i147" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#floodFill-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Scalar-org.opencv.core.Rect-org.opencv.core.Scalar-org.opencv.core.Scalar-int-">floodFill</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
         <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;seedPoint,
         <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;newVal,
         <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;rect,
         <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;loDiff,
         <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;upDiff,
         int&nbsp;flags)</code>
<div class="block">Fills a connected component with the given color.</div>
</td>
</tr>
<tr id="i148" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#GaussianBlur-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-double-">GaussianBlur</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
            <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
            double&nbsp;sigmaX)</code>
<div class="block">Blurs an image using a Gaussian filter.</div>
</td>
</tr>
<tr id="i149" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#GaussianBlur-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-double-double-">GaussianBlur</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
            <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
            double&nbsp;sigmaX,
            double&nbsp;sigmaY)</code>
<div class="block">Blurs an image using a Gaussian filter.</div>
</td>
</tr>
<tr id="i150" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#GaussianBlur-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-double-double-int-">GaussianBlur</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
            <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
            double&nbsp;sigmaX,
            double&nbsp;sigmaY,
            int&nbsp;borderType)</code>
<div class="block">Blurs an image using a Gaussian filter.</div>
</td>
</tr>
<tr id="i151" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#getAffineTransform-org.opencv.core.MatOfPoint2f-org.opencv.core.MatOfPoint2f-">getAffineTransform</a></span>(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;src,
                  <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;dst)</code>&nbsp;</td>
</tr>
<tr id="i152" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#getDerivKernels-org.opencv.core.Mat-org.opencv.core.Mat-int-int-int-">getDerivKernels</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kx,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;ky,
               int&nbsp;dx,
               int&nbsp;dy,
               int&nbsp;ksize)</code>
<div class="block">Returns filter coefficients for computing spatial image derivatives.</div>
</td>
</tr>
<tr id="i153" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#getDerivKernels-org.opencv.core.Mat-org.opencv.core.Mat-int-int-int-boolean-">getDerivKernels</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kx,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;ky,
               int&nbsp;dx,
               int&nbsp;dy,
               int&nbsp;ksize,
               boolean&nbsp;normalize)</code>
<div class="block">Returns filter coefficients for computing spatial image derivatives.</div>
</td>
</tr>
<tr id="i154" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#getDerivKernels-org.opencv.core.Mat-org.opencv.core.Mat-int-int-int-boolean-int-">getDerivKernels</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kx,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;ky,
               int&nbsp;dx,
               int&nbsp;dy,
               int&nbsp;ksize,
               boolean&nbsp;normalize,
               int&nbsp;ktype)</code>
<div class="block">Returns filter coefficients for computing spatial image derivatives.</div>
</td>
</tr>
<tr id="i155" class="rowColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#getFontScaleFromHeight-int-int-">getFontScaleFromHeight</a></span>(int&nbsp;fontFace,
                      int&nbsp;pixelHeight)</code>
<div class="block">Calculates the font-specific size to use to achieve a given height in pixels.</div>
</td>
</tr>
<tr id="i156" class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#getFontScaleFromHeight-int-int-int-">getFontScaleFromHeight</a></span>(int&nbsp;fontFace,
                      int&nbsp;pixelHeight,
                      int&nbsp;thickness)</code>
<div class="block">Calculates the font-specific size to use to achieve a given height in pixels.</div>
</td>
</tr>
<tr id="i157" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#getGaborKernel-org.opencv.core.Size-double-double-double-double-">getGaborKernel</a></span>(<a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
              double&nbsp;sigma,
              double&nbsp;theta,
              double&nbsp;lambd,
              double&nbsp;gamma)</code>
<div class="block">Returns Gabor filter coefficients.</div>
</td>
</tr>
<tr id="i158" class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#getGaborKernel-org.opencv.core.Size-double-double-double-double-double-">getGaborKernel</a></span>(<a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
              double&nbsp;sigma,
              double&nbsp;theta,
              double&nbsp;lambd,
              double&nbsp;gamma,
              double&nbsp;psi)</code>
<div class="block">Returns Gabor filter coefficients.</div>
</td>
</tr>
<tr id="i159" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#getGaborKernel-org.opencv.core.Size-double-double-double-double-double-int-">getGaborKernel</a></span>(<a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
              double&nbsp;sigma,
              double&nbsp;theta,
              double&nbsp;lambd,
              double&nbsp;gamma,
              double&nbsp;psi,
              int&nbsp;ktype)</code>
<div class="block">Returns Gabor filter coefficients.</div>
</td>
</tr>
<tr id="i160" class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#getGaussianKernel-int-double-">getGaussianKernel</a></span>(int&nbsp;ksize,
                 double&nbsp;sigma)</code>
<div class="block">Returns Gaussian filter coefficients.</div>
</td>
</tr>
<tr id="i161" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#getGaussianKernel-int-double-int-">getGaussianKernel</a></span>(int&nbsp;ksize,
                 double&nbsp;sigma,
                 int&nbsp;ktype)</code>
<div class="block">Returns Gaussian filter coefficients.</div>
</td>
</tr>
<tr id="i162" class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#getPerspectiveTransform-org.opencv.core.Mat-org.opencv.core.Mat-">getPerspectiveTransform</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block">Calculates a perspective transform from four pairs of the corresponding points.</div>
</td>
</tr>
<tr id="i163" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#getPerspectiveTransform-org.opencv.core.Mat-org.opencv.core.Mat-int-">getPerspectiveTransform</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                       int&nbsp;solveMethod)</code>
<div class="block">Calculates a perspective transform from four pairs of the corresponding points.</div>
</td>
</tr>
<tr id="i164" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#getRectSubPix-org.opencv.core.Mat-org.opencv.core.Size-org.opencv.core.Point-org.opencv.core.Mat-">getRectSubPix</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
             <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;patchSize,
             <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;patch)</code>
<div class="block">Retrieves a pixel rectangle from an image with sub-pixel accuracy.</div>
</td>
</tr>
<tr id="i165" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#getRectSubPix-org.opencv.core.Mat-org.opencv.core.Size-org.opencv.core.Point-org.opencv.core.Mat-int-">getRectSubPix</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
             <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;patchSize,
             <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;patch,
             int&nbsp;patchType)</code>
<div class="block">Retrieves a pixel rectangle from an image with sub-pixel accuracy.</div>
</td>
</tr>
<tr id="i166" class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#getRotationMatrix2D-org.opencv.core.Point-double-double-">getRotationMatrix2D</a></span>(<a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
                   double&nbsp;angle,
                   double&nbsp;scale)</code>
<div class="block">Calculates an affine matrix of 2D rotation.</div>
</td>
</tr>
<tr id="i167" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#getStructuringElement-int-org.opencv.core.Size-">getStructuringElement</a></span>(int&nbsp;shape,
                     <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize)</code>
<div class="block">Returns a structuring element of the specified size and shape for morphological operations.</div>
</td>
</tr>
<tr id="i168" class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#getStructuringElement-int-org.opencv.core.Size-org.opencv.core.Point-">getStructuringElement</a></span>(int&nbsp;shape,
                     <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
                     <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor)</code>
<div class="block">Returns a structuring element of the specified size and shape for morphological operations.</div>
</td>
</tr>
<tr id="i169" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#getTextSize-java.lang.String-int-double-int-int:A-">getTextSize</a></span>(java.lang.String&nbsp;text,
           int&nbsp;fontFace,
           double&nbsp;fontScale,
           int&nbsp;thickness,
           int[]&nbsp;baseLine)</code>&nbsp;</td>
</tr>
<tr id="i170" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#goodFeaturesToTrack-org.opencv.core.Mat-org.opencv.core.MatOfPoint-int-double-double-">goodFeaturesToTrack</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                   <a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&nbsp;corners,
                   int&nbsp;maxCorners,
                   double&nbsp;qualityLevel,
                   double&nbsp;minDistance)</code>
<div class="block">Determines strong corners on an image.</div>
</td>
</tr>
<tr id="i171" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#goodFeaturesToTrack-org.opencv.core.Mat-org.opencv.core.MatOfPoint-int-double-double-org.opencv.core.Mat-">goodFeaturesToTrack</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                   <a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&nbsp;corners,
                   int&nbsp;maxCorners,
                   double&nbsp;qualityLevel,
                   double&nbsp;minDistance,
                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>
<div class="block">Determines strong corners on an image.</div>
</td>
</tr>
<tr id="i172" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#goodFeaturesToTrack-org.opencv.core.Mat-org.opencv.core.MatOfPoint-int-double-double-org.opencv.core.Mat-int-">goodFeaturesToTrack</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                   <a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&nbsp;corners,
                   int&nbsp;maxCorners,
                   double&nbsp;qualityLevel,
                   double&nbsp;minDistance,
                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                   int&nbsp;blockSize)</code>
<div class="block">Determines strong corners on an image.</div>
</td>
</tr>
<tr id="i173" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#goodFeaturesToTrack-org.opencv.core.Mat-org.opencv.core.MatOfPoint-int-double-double-org.opencv.core.Mat-int-boolean-">goodFeaturesToTrack</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                   <a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&nbsp;corners,
                   int&nbsp;maxCorners,
                   double&nbsp;qualityLevel,
                   double&nbsp;minDistance,
                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                   int&nbsp;blockSize,
                   boolean&nbsp;useHarrisDetector)</code>
<div class="block">Determines strong corners on an image.</div>
</td>
</tr>
<tr id="i174" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#goodFeaturesToTrack-org.opencv.core.Mat-org.opencv.core.MatOfPoint-int-double-double-org.opencv.core.Mat-int-boolean-double-">goodFeaturesToTrack</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                   <a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&nbsp;corners,
                   int&nbsp;maxCorners,
                   double&nbsp;qualityLevel,
                   double&nbsp;minDistance,
                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                   int&nbsp;blockSize,
                   boolean&nbsp;useHarrisDetector,
                   double&nbsp;k)</code>
<div class="block">Determines strong corners on an image.</div>
</td>
</tr>
<tr id="i175" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#goodFeaturesToTrack-org.opencv.core.Mat-org.opencv.core.MatOfPoint-int-double-double-org.opencv.core.Mat-int-int-">goodFeaturesToTrack</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                   <a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&nbsp;corners,
                   int&nbsp;maxCorners,
                   double&nbsp;qualityLevel,
                   double&nbsp;minDistance,
                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                   int&nbsp;blockSize,
                   int&nbsp;gradientSize)</code>&nbsp;</td>
</tr>
<tr id="i176" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#goodFeaturesToTrack-org.opencv.core.Mat-org.opencv.core.MatOfPoint-int-double-double-org.opencv.core.Mat-int-int-boolean-">goodFeaturesToTrack</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                   <a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&nbsp;corners,
                   int&nbsp;maxCorners,
                   double&nbsp;qualityLevel,
                   double&nbsp;minDistance,
                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                   int&nbsp;blockSize,
                   int&nbsp;gradientSize,
                   boolean&nbsp;useHarrisDetector)</code>&nbsp;</td>
</tr>
<tr id="i177" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#goodFeaturesToTrack-org.opencv.core.Mat-org.opencv.core.MatOfPoint-int-double-double-org.opencv.core.Mat-int-int-boolean-double-">goodFeaturesToTrack</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                   <a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&nbsp;corners,
                   int&nbsp;maxCorners,
                   double&nbsp;qualityLevel,
                   double&nbsp;minDistance,
                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                   int&nbsp;blockSize,
                   int&nbsp;gradientSize,
                   boolean&nbsp;useHarrisDetector,
                   double&nbsp;k)</code>&nbsp;</td>
</tr>
<tr id="i178" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#goodFeaturesToTrackWithQuality-org.opencv.core.Mat-org.opencv.core.Mat-int-double-double-org.opencv.core.Mat-org.opencv.core.Mat-">goodFeaturesToTrackWithQuality</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;corners,
                              int&nbsp;maxCorners,
                              double&nbsp;qualityLevel,
                              double&nbsp;minDistance,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cornersQuality)</code>
<div class="block">Same as above, but returns also quality measure of the detected corners.</div>
</td>
</tr>
<tr id="i179" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#goodFeaturesToTrackWithQuality-org.opencv.core.Mat-org.opencv.core.Mat-int-double-double-org.opencv.core.Mat-org.opencv.core.Mat-int-">goodFeaturesToTrackWithQuality</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;corners,
                              int&nbsp;maxCorners,
                              double&nbsp;qualityLevel,
                              double&nbsp;minDistance,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cornersQuality,
                              int&nbsp;blockSize)</code>
<div class="block">Same as above, but returns also quality measure of the detected corners.</div>
</td>
</tr>
<tr id="i180" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#goodFeaturesToTrackWithQuality-org.opencv.core.Mat-org.opencv.core.Mat-int-double-double-org.opencv.core.Mat-org.opencv.core.Mat-int-int-">goodFeaturesToTrackWithQuality</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;corners,
                              int&nbsp;maxCorners,
                              double&nbsp;qualityLevel,
                              double&nbsp;minDistance,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cornersQuality,
                              int&nbsp;blockSize,
                              int&nbsp;gradientSize)</code>
<div class="block">Same as above, but returns also quality measure of the detected corners.</div>
</td>
</tr>
<tr id="i181" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#goodFeaturesToTrackWithQuality-org.opencv.core.Mat-org.opencv.core.Mat-int-double-double-org.opencv.core.Mat-org.opencv.core.Mat-int-int-boolean-">goodFeaturesToTrackWithQuality</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;corners,
                              int&nbsp;maxCorners,
                              double&nbsp;qualityLevel,
                              double&nbsp;minDistance,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cornersQuality,
                              int&nbsp;blockSize,
                              int&nbsp;gradientSize,
                              boolean&nbsp;useHarrisDetector)</code>
<div class="block">Same as above, but returns also quality measure of the detected corners.</div>
</td>
</tr>
<tr id="i182" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#goodFeaturesToTrackWithQuality-org.opencv.core.Mat-org.opencv.core.Mat-int-double-double-org.opencv.core.Mat-org.opencv.core.Mat-int-int-boolean-double-">goodFeaturesToTrackWithQuality</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;corners,
                              int&nbsp;maxCorners,
                              double&nbsp;qualityLevel,
                              double&nbsp;minDistance,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cornersQuality,
                              int&nbsp;blockSize,
                              int&nbsp;gradientSize,
                              boolean&nbsp;useHarrisDetector,
                              double&nbsp;k)</code>
<div class="block">Same as above, but returns also quality measure of the detected corners.</div>
</td>
</tr>
<tr id="i183" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#grabCut-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Rect-org.opencv.core.Mat-org.opencv.core.Mat-int-">grabCut</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
       <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;rect,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;bgdModel,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;fgdModel,
       int&nbsp;iterCount)</code>
<div class="block">Runs the GrabCut algorithm.</div>
</td>
</tr>
<tr id="i184" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#grabCut-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Rect-org.opencv.core.Mat-org.opencv.core.Mat-int-int-">grabCut</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
       <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;rect,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;bgdModel,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;fgdModel,
       int&nbsp;iterCount,
       int&nbsp;mode)</code>
<div class="block">Runs the GrabCut algorithm.</div>
</td>
</tr>
<tr id="i185" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#HoughCircles-org.opencv.core.Mat-org.opencv.core.Mat-int-double-double-">HoughCircles</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;circles,
            int&nbsp;method,
            double&nbsp;dp,
            double&nbsp;minDist)</code>
<div class="block">Finds circles in a grayscale image using the Hough transform.</div>
</td>
</tr>
<tr id="i186" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#HoughCircles-org.opencv.core.Mat-org.opencv.core.Mat-int-double-double-double-">HoughCircles</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;circles,
            int&nbsp;method,
            double&nbsp;dp,
            double&nbsp;minDist,
            double&nbsp;param1)</code>
<div class="block">Finds circles in a grayscale image using the Hough transform.</div>
</td>
</tr>
<tr id="i187" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#HoughCircles-org.opencv.core.Mat-org.opencv.core.Mat-int-double-double-double-double-">HoughCircles</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;circles,
            int&nbsp;method,
            double&nbsp;dp,
            double&nbsp;minDist,
            double&nbsp;param1,
            double&nbsp;param2)</code>
<div class="block">Finds circles in a grayscale image using the Hough transform.</div>
</td>
</tr>
<tr id="i188" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#HoughCircles-org.opencv.core.Mat-org.opencv.core.Mat-int-double-double-double-double-int-">HoughCircles</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;circles,
            int&nbsp;method,
            double&nbsp;dp,
            double&nbsp;minDist,
            double&nbsp;param1,
            double&nbsp;param2,
            int&nbsp;minRadius)</code>
<div class="block">Finds circles in a grayscale image using the Hough transform.</div>
</td>
</tr>
<tr id="i189" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#HoughCircles-org.opencv.core.Mat-org.opencv.core.Mat-int-double-double-double-double-int-int-">HoughCircles</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;circles,
            int&nbsp;method,
            double&nbsp;dp,
            double&nbsp;minDist,
            double&nbsp;param1,
            double&nbsp;param2,
            int&nbsp;minRadius,
            int&nbsp;maxRadius)</code>
<div class="block">Finds circles in a grayscale image using the Hough transform.</div>
</td>
</tr>
<tr id="i190" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#HoughLines-org.opencv.core.Mat-org.opencv.core.Mat-double-double-int-">HoughLines</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;lines,
          double&nbsp;rho,
          double&nbsp;theta,
          int&nbsp;threshold)</code>
<div class="block">Finds lines in a binary image using the standard Hough transform.</div>
</td>
</tr>
<tr id="i191" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#HoughLines-org.opencv.core.Mat-org.opencv.core.Mat-double-double-int-double-">HoughLines</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;lines,
          double&nbsp;rho,
          double&nbsp;theta,
          int&nbsp;threshold,
          double&nbsp;srn)</code>
<div class="block">Finds lines in a binary image using the standard Hough transform.</div>
</td>
</tr>
<tr id="i192" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#HoughLines-org.opencv.core.Mat-org.opencv.core.Mat-double-double-int-double-double-">HoughLines</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;lines,
          double&nbsp;rho,
          double&nbsp;theta,
          int&nbsp;threshold,
          double&nbsp;srn,
          double&nbsp;stn)</code>
<div class="block">Finds lines in a binary image using the standard Hough transform.</div>
</td>
</tr>
<tr id="i193" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#HoughLines-org.opencv.core.Mat-org.opencv.core.Mat-double-double-int-double-double-double-">HoughLines</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;lines,
          double&nbsp;rho,
          double&nbsp;theta,
          int&nbsp;threshold,
          double&nbsp;srn,
          double&nbsp;stn,
          double&nbsp;min_theta)</code>
<div class="block">Finds lines in a binary image using the standard Hough transform.</div>
</td>
</tr>
<tr id="i194" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#HoughLines-org.opencv.core.Mat-org.opencv.core.Mat-double-double-int-double-double-double-double-">HoughLines</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;lines,
          double&nbsp;rho,
          double&nbsp;theta,
          int&nbsp;threshold,
          double&nbsp;srn,
          double&nbsp;stn,
          double&nbsp;min_theta,
          double&nbsp;max_theta)</code>
<div class="block">Finds lines in a binary image using the standard Hough transform.</div>
</td>
</tr>
<tr id="i195" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#HoughLinesP-org.opencv.core.Mat-org.opencv.core.Mat-double-double-int-">HoughLinesP</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;lines,
           double&nbsp;rho,
           double&nbsp;theta,
           int&nbsp;threshold)</code>
<div class="block">Finds line segments in a binary image using the probabilistic Hough transform.</div>
</td>
</tr>
<tr id="i196" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#HoughLinesP-org.opencv.core.Mat-org.opencv.core.Mat-double-double-int-double-">HoughLinesP</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;lines,
           double&nbsp;rho,
           double&nbsp;theta,
           int&nbsp;threshold,
           double&nbsp;minLineLength)</code>
<div class="block">Finds line segments in a binary image using the probabilistic Hough transform.</div>
</td>
</tr>
<tr id="i197" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#HoughLinesP-org.opencv.core.Mat-org.opencv.core.Mat-double-double-int-double-double-">HoughLinesP</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;lines,
           double&nbsp;rho,
           double&nbsp;theta,
           int&nbsp;threshold,
           double&nbsp;minLineLength,
           double&nbsp;maxLineGap)</code>
<div class="block">Finds line segments in a binary image using the probabilistic Hough transform.</div>
</td>
</tr>
<tr id="i198" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#HoughLinesPointSet-org.opencv.core.Mat-org.opencv.core.Mat-int-int-double-double-double-double-double-double-">HoughLinesPointSet</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;point,
                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;lines,
                  int&nbsp;lines_max,
                  int&nbsp;threshold,
                  double&nbsp;min_rho,
                  double&nbsp;max_rho,
                  double&nbsp;rho_step,
                  double&nbsp;min_theta,
                  double&nbsp;max_theta,
                  double&nbsp;theta_step)</code>
<div class="block">Finds lines in a set of points using the standard Hough transform.</div>
</td>
</tr>
<tr id="i199" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#HoughLinesWithAccumulator-org.opencv.core.Mat-org.opencv.core.Mat-double-double-int-">HoughLinesWithAccumulator</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;lines,
                         double&nbsp;rho,
                         double&nbsp;theta,
                         int&nbsp;threshold)</code>
<div class="block">Finds lines in a binary image using the standard Hough transform and get accumulator.</div>
</td>
</tr>
<tr id="i200" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#HoughLinesWithAccumulator-org.opencv.core.Mat-org.opencv.core.Mat-double-double-int-double-">HoughLinesWithAccumulator</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;lines,
                         double&nbsp;rho,
                         double&nbsp;theta,
                         int&nbsp;threshold,
                         double&nbsp;srn)</code>
<div class="block">Finds lines in a binary image using the standard Hough transform and get accumulator.</div>
</td>
</tr>
<tr id="i201" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#HoughLinesWithAccumulator-org.opencv.core.Mat-org.opencv.core.Mat-double-double-int-double-double-">HoughLinesWithAccumulator</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;lines,
                         double&nbsp;rho,
                         double&nbsp;theta,
                         int&nbsp;threshold,
                         double&nbsp;srn,
                         double&nbsp;stn)</code>
<div class="block">Finds lines in a binary image using the standard Hough transform and get accumulator.</div>
</td>
</tr>
<tr id="i202" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#HoughLinesWithAccumulator-org.opencv.core.Mat-org.opencv.core.Mat-double-double-int-double-double-double-">HoughLinesWithAccumulator</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;lines,
                         double&nbsp;rho,
                         double&nbsp;theta,
                         int&nbsp;threshold,
                         double&nbsp;srn,
                         double&nbsp;stn,
                         double&nbsp;min_theta)</code>
<div class="block">Finds lines in a binary image using the standard Hough transform and get accumulator.</div>
</td>
</tr>
<tr id="i203" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#HoughLinesWithAccumulator-org.opencv.core.Mat-org.opencv.core.Mat-double-double-int-double-double-double-double-">HoughLinesWithAccumulator</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;lines,
                         double&nbsp;rho,
                         double&nbsp;theta,
                         int&nbsp;threshold,
                         double&nbsp;srn,
                         double&nbsp;stn,
                         double&nbsp;min_theta,
                         double&nbsp;max_theta)</code>
<div class="block">Finds lines in a binary image using the standard Hough transform and get accumulator.</div>
</td>
</tr>
<tr id="i204" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#HuMoments-org.opencv.imgproc.Moments-org.opencv.core.Mat-">HuMoments</a></span>(<a href="../../../org/opencv/imgproc/Moments.html" title="class in org.opencv.imgproc">Moments</a>&nbsp;m,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;hu)</code>&nbsp;</td>
</tr>
<tr id="i205" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#integral-org.opencv.core.Mat-org.opencv.core.Mat-">integral</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sum)</code>&nbsp;</td>
</tr>
<tr id="i206" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#integral-org.opencv.core.Mat-org.opencv.core.Mat-int-">integral</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sum,
        int&nbsp;sdepth)</code>&nbsp;</td>
</tr>
<tr id="i207" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#integral2-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">integral2</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sum,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sqsum)</code>&nbsp;</td>
</tr>
<tr id="i208" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#integral2-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">integral2</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sum,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sqsum,
         int&nbsp;sdepth)</code>&nbsp;</td>
</tr>
<tr id="i209" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#integral2-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-int-">integral2</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sum,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sqsum,
         int&nbsp;sdepth,
         int&nbsp;sqdepth)</code>&nbsp;</td>
</tr>
<tr id="i210" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#integral3-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">integral3</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sum,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sqsum,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tilted)</code>
<div class="block">Calculates the integral of an image.</div>
</td>
</tr>
<tr id="i211" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#integral3-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">integral3</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sum,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sqsum,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tilted,
         int&nbsp;sdepth)</code>
<div class="block">Calculates the integral of an image.</div>
</td>
</tr>
<tr id="i212" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#integral3-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-int-">integral3</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sum,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sqsum,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tilted,
         int&nbsp;sdepth,
         int&nbsp;sqdepth)</code>
<div class="block">Calculates the integral of an image.</div>
</td>
</tr>
<tr id="i213" class="rowColor">
<td class="colFirst"><code>static float</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#intersectConvexConvex-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">intersectConvexConvex</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;p1,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;p2,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;p12)</code>
<div class="block">Finds intersection of two convex polygons</div>
</td>
</tr>
<tr id="i214" class="altColor">
<td class="colFirst"><code>static float</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#intersectConvexConvex-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-boolean-">intersectConvexConvex</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;p1,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;p2,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;p12,
                     boolean&nbsp;handleNested)</code>
<div class="block">Finds intersection of two convex polygons</div>
</td>
</tr>
<tr id="i215" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#invertAffineTransform-org.opencv.core.Mat-org.opencv.core.Mat-">invertAffineTransform</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;M,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;iM)</code>
<div class="block">Inverts an affine transformation.</div>
</td>
</tr>
<tr id="i216" class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#isContourConvex-org.opencv.core.MatOfPoint-">isContourConvex</a></span>(<a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&nbsp;contour)</code>
<div class="block">Tests a contour convexity.</div>
</td>
</tr>
<tr id="i217" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#Laplacian-org.opencv.core.Mat-org.opencv.core.Mat-int-">Laplacian</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
         int&nbsp;ddepth)</code>
<div class="block">Calculates the Laplacian of an image.</div>
</td>
</tr>
<tr id="i218" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#Laplacian-org.opencv.core.Mat-org.opencv.core.Mat-int-int-">Laplacian</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
         int&nbsp;ddepth,
         int&nbsp;ksize)</code>
<div class="block">Calculates the Laplacian of an image.</div>
</td>
</tr>
<tr id="i219" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#Laplacian-org.opencv.core.Mat-org.opencv.core.Mat-int-int-double-">Laplacian</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
         int&nbsp;ddepth,
         int&nbsp;ksize,
         double&nbsp;scale)</code>
<div class="block">Calculates the Laplacian of an image.</div>
</td>
</tr>
<tr id="i220" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#Laplacian-org.opencv.core.Mat-org.opencv.core.Mat-int-int-double-double-">Laplacian</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
         int&nbsp;ddepth,
         int&nbsp;ksize,
         double&nbsp;scale,
         double&nbsp;delta)</code>
<div class="block">Calculates the Laplacian of an image.</div>
</td>
</tr>
<tr id="i221" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#Laplacian-org.opencv.core.Mat-org.opencv.core.Mat-int-int-double-double-int-">Laplacian</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
         int&nbsp;ddepth,
         int&nbsp;ksize,
         double&nbsp;scale,
         double&nbsp;delta,
         int&nbsp;borderType)</code>
<div class="block">Calculates the Laplacian of an image.</div>
</td>
</tr>
<tr id="i222" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#line-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Point-org.opencv.core.Scalar-">line</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
    <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt1,
    <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt2,
    <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color)</code>
<div class="block">Draws a line segment connecting two points.</div>
</td>
</tr>
<tr id="i223" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#line-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Point-org.opencv.core.Scalar-int-">line</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
    <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt1,
    <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt2,
    <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
    int&nbsp;thickness)</code>
<div class="block">Draws a line segment connecting two points.</div>
</td>
</tr>
<tr id="i224" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#line-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Point-org.opencv.core.Scalar-int-int-">line</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
    <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt1,
    <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt2,
    <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
    int&nbsp;thickness,
    int&nbsp;lineType)</code>
<div class="block">Draws a line segment connecting two points.</div>
</td>
</tr>
<tr id="i225" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#line-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Point-org.opencv.core.Scalar-int-int-int-">line</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
    <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt1,
    <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt2,
    <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
    int&nbsp;thickness,
    int&nbsp;lineType,
    int&nbsp;shift)</code>
<div class="block">Draws a line segment connecting two points.</div>
</td>
</tr>
<tr id="i226" class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#matchShapes-org.opencv.core.Mat-org.opencv.core.Mat-int-double-">matchShapes</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;contour1,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;contour2,
           int&nbsp;method,
           double&nbsp;parameter)</code>
<div class="block">Compares two shapes.</div>
</td>
</tr>
<tr id="i227" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#matchTemplate-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">matchTemplate</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;templ,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;result,
             int&nbsp;method)</code>
<div class="block">Compares a template against overlapped image regions.</div>
</td>
</tr>
<tr id="i228" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#matchTemplate-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Mat-">matchTemplate</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;templ,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;result,
             int&nbsp;method,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>
<div class="block">Compares a template against overlapped image regions.</div>
</td>
</tr>
<tr id="i229" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#medianBlur-org.opencv.core.Mat-org.opencv.core.Mat-int-">medianBlur</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
          int&nbsp;ksize)</code>
<div class="block">Blurs an image using the median filter.</div>
</td>
</tr>
<tr id="i230" class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/RotatedRect.html" title="class in org.opencv.core">RotatedRect</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#minAreaRect-org.opencv.core.MatOfPoint2f-">minAreaRect</a></span>(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points)</code>
<div class="block">Finds a rotated rectangle of the minimum area enclosing the input 2D point set.</div>
</td>
</tr>
<tr id="i231" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#minEnclosingCircle-org.opencv.core.MatOfPoint2f-org.opencv.core.Point-float:A-">minEnclosingCircle</a></span>(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points,
                  <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
                  float[]&nbsp;radius)</code>
<div class="block">Finds a circle of the minimum area enclosing a 2D point set.</div>
</td>
</tr>
<tr id="i232" class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#minEnclosingTriangle-org.opencv.core.Mat-org.opencv.core.Mat-">minEnclosingTriangle</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points,
                    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;triangle)</code>
<div class="block">Finds a triangle of minimum area enclosing a 2D point set and returns its area.</div>
</td>
</tr>
<tr id="i233" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/imgproc/Moments.html" title="class in org.opencv.imgproc">Moments</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#moments-org.opencv.core.Mat-">moments</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;array)</code>
<div class="block">Calculates all of the moments up to the third order of a polygon or rasterized shape.</div>
</td>
</tr>
<tr id="i234" class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/imgproc/Moments.html" title="class in org.opencv.imgproc">Moments</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#moments-org.opencv.core.Mat-boolean-">moments</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;array,
       boolean&nbsp;binaryImage)</code>
<div class="block">Calculates all of the moments up to the third order of a polygon or rasterized shape.</div>
</td>
</tr>
<tr id="i235" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#morphologyEx-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Mat-">morphologyEx</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
            int&nbsp;op,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel)</code>
<div class="block">Performs advanced morphological transformations.</div>
</td>
</tr>
<tr id="i236" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#morphologyEx-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Mat-org.opencv.core.Point-">morphologyEx</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
            int&nbsp;op,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel,
            <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor)</code>
<div class="block">Performs advanced morphological transformations.</div>
</td>
</tr>
<tr id="i237" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#morphologyEx-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Mat-org.opencv.core.Point-int-">morphologyEx</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
            int&nbsp;op,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel,
            <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
            int&nbsp;iterations)</code>
<div class="block">Performs advanced morphological transformations.</div>
</td>
</tr>
<tr id="i238" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#morphologyEx-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Mat-org.opencv.core.Point-int-int-">morphologyEx</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
            int&nbsp;op,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel,
            <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
            int&nbsp;iterations,
            int&nbsp;borderType)</code>
<div class="block">Performs advanced morphological transformations.</div>
</td>
</tr>
<tr id="i239" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#morphologyEx-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Mat-org.opencv.core.Point-int-int-org.opencv.core.Scalar-">morphologyEx</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
            int&nbsp;op,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel,
            <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
            int&nbsp;iterations,
            int&nbsp;borderType,
            <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;borderValue)</code>
<div class="block">Performs advanced morphological transformations.</div>
</td>
</tr>
<tr id="i240" class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#phaseCorrelate-org.opencv.core.Mat-org.opencv.core.Mat-">phaseCorrelate</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2)</code>
<div class="block">The function is used to detect translational shifts that occur between two images.</div>
</td>
</tr>
<tr id="i241" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#phaseCorrelate-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">phaseCorrelate</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;window)</code>
<div class="block">The function is used to detect translational shifts that occur between two images.</div>
</td>
</tr>
<tr id="i242" class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#phaseCorrelate-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double:A-">phaseCorrelate</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;window,
              double[]&nbsp;response)</code>
<div class="block">The function is used to detect translational shifts that occur between two images.</div>
</td>
</tr>
<tr id="i243" class="rowColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#pointPolygonTest-org.opencv.core.MatOfPoint2f-org.opencv.core.Point-boolean-">pointPolygonTest</a></span>(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;contour,
                <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt,
                boolean&nbsp;measureDist)</code>
<div class="block">Performs a point-in-contour test.</div>
</td>
</tr>
<tr id="i244" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#polylines-org.opencv.core.Mat-java.util.List-boolean-org.opencv.core.Scalar-">polylines</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
         java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;pts,
         boolean&nbsp;isClosed,
         <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color)</code>
<div class="block">Draws several polygonal curves.</div>
</td>
</tr>
<tr id="i245" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#polylines-org.opencv.core.Mat-java.util.List-boolean-org.opencv.core.Scalar-int-">polylines</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
         java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;pts,
         boolean&nbsp;isClosed,
         <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
         int&nbsp;thickness)</code>
<div class="block">Draws several polygonal curves.</div>
</td>
</tr>
<tr id="i246" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#polylines-org.opencv.core.Mat-java.util.List-boolean-org.opencv.core.Scalar-int-int-">polylines</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
         java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;pts,
         boolean&nbsp;isClosed,
         <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
         int&nbsp;thickness,
         int&nbsp;lineType)</code>
<div class="block">Draws several polygonal curves.</div>
</td>
</tr>
<tr id="i247" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#polylines-org.opencv.core.Mat-java.util.List-boolean-org.opencv.core.Scalar-int-int-int-">polylines</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
         java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;pts,
         boolean&nbsp;isClosed,
         <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
         int&nbsp;thickness,
         int&nbsp;lineType,
         int&nbsp;shift)</code>
<div class="block">Draws several polygonal curves.</div>
</td>
</tr>
<tr id="i248" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#preCornerDetect-org.opencv.core.Mat-org.opencv.core.Mat-int-">preCornerDetect</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
               int&nbsp;ksize)</code>
<div class="block">Calculates a feature map for corner detection.</div>
</td>
</tr>
<tr id="i249" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#preCornerDetect-org.opencv.core.Mat-org.opencv.core.Mat-int-int-">preCornerDetect</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
               int&nbsp;ksize,
               int&nbsp;borderType)</code>
<div class="block">Calculates a feature map for corner detection.</div>
</td>
</tr>
<tr id="i250" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#putText-org.opencv.core.Mat-java.lang.String-org.opencv.core.Point-int-double-org.opencv.core.Scalar-">putText</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
       java.lang.String&nbsp;text,
       <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;org,
       int&nbsp;fontFace,
       double&nbsp;fontScale,
       <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color)</code>
<div class="block">Draws a text string.</div>
</td>
</tr>
<tr id="i251" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#putText-org.opencv.core.Mat-java.lang.String-org.opencv.core.Point-int-double-org.opencv.core.Scalar-int-">putText</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
       java.lang.String&nbsp;text,
       <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;org,
       int&nbsp;fontFace,
       double&nbsp;fontScale,
       <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
       int&nbsp;thickness)</code>
<div class="block">Draws a text string.</div>
</td>
</tr>
<tr id="i252" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#putText-org.opencv.core.Mat-java.lang.String-org.opencv.core.Point-int-double-org.opencv.core.Scalar-int-int-">putText</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
       java.lang.String&nbsp;text,
       <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;org,
       int&nbsp;fontFace,
       double&nbsp;fontScale,
       <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
       int&nbsp;thickness,
       int&nbsp;lineType)</code>
<div class="block">Draws a text string.</div>
</td>
</tr>
<tr id="i253" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#putText-org.opencv.core.Mat-java.lang.String-org.opencv.core.Point-int-double-org.opencv.core.Scalar-int-int-boolean-">putText</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
       java.lang.String&nbsp;text,
       <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;org,
       int&nbsp;fontFace,
       double&nbsp;fontScale,
       <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
       int&nbsp;thickness,
       int&nbsp;lineType,
       boolean&nbsp;bottomLeftOrigin)</code>
<div class="block">Draws a text string.</div>
</td>
</tr>
<tr id="i254" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#pyrDown-org.opencv.core.Mat-org.opencv.core.Mat-">pyrDown</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block">Blurs an image and downsamples it.</div>
</td>
</tr>
<tr id="i255" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#pyrDown-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-">pyrDown</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
       <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dstsize)</code>
<div class="block">Blurs an image and downsamples it.</div>
</td>
</tr>
<tr id="i256" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#pyrDown-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-int-">pyrDown</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
       <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dstsize,
       int&nbsp;borderType)</code>
<div class="block">Blurs an image and downsamples it.</div>
</td>
</tr>
<tr id="i257" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#pyrMeanShiftFiltering-org.opencv.core.Mat-org.opencv.core.Mat-double-double-">pyrMeanShiftFiltering</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                     double&nbsp;sp,
                     double&nbsp;sr)</code>
<div class="block">Performs initial step of meanshift segmentation of an image.</div>
</td>
</tr>
<tr id="i258" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#pyrMeanShiftFiltering-org.opencv.core.Mat-org.opencv.core.Mat-double-double-int-">pyrMeanShiftFiltering</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                     double&nbsp;sp,
                     double&nbsp;sr,
                     int&nbsp;maxLevel)</code>
<div class="block">Performs initial step of meanshift segmentation of an image.</div>
</td>
</tr>
<tr id="i259" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#pyrMeanShiftFiltering-org.opencv.core.Mat-org.opencv.core.Mat-double-double-int-org.opencv.core.TermCriteria-">pyrMeanShiftFiltering</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                     double&nbsp;sp,
                     double&nbsp;sr,
                     int&nbsp;maxLevel,
                     <a href="../../../org/opencv/core/TermCriteria.html" title="class in org.opencv.core">TermCriteria</a>&nbsp;termcrit)</code>
<div class="block">Performs initial step of meanshift segmentation of an image.</div>
</td>
</tr>
<tr id="i260" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#pyrUp-org.opencv.core.Mat-org.opencv.core.Mat-">pyrUp</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block">Upsamples an image and then blurs it.</div>
</td>
</tr>
<tr id="i261" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#pyrUp-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-">pyrUp</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
     <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dstsize)</code>
<div class="block">Upsamples an image and then blurs it.</div>
</td>
</tr>
<tr id="i262" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#pyrUp-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-int-">pyrUp</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
     <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dstsize,
     int&nbsp;borderType)</code>
<div class="block">Upsamples an image and then blurs it.</div>
</td>
</tr>
<tr id="i263" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#rectangle-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Point-org.opencv.core.Scalar-">rectangle</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
         <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt1,
         <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt2,
         <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color)</code>
<div class="block">Draws a simple, thick, or filled up-right rectangle.</div>
</td>
</tr>
<tr id="i264" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#rectangle-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Point-org.opencv.core.Scalar-int-">rectangle</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
         <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt1,
         <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt2,
         <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
         int&nbsp;thickness)</code>
<div class="block">Draws a simple, thick, or filled up-right rectangle.</div>
</td>
</tr>
<tr id="i265" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#rectangle-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Point-org.opencv.core.Scalar-int-int-">rectangle</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
         <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt1,
         <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt2,
         <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
         int&nbsp;thickness,
         int&nbsp;lineType)</code>
<div class="block">Draws a simple, thick, or filled up-right rectangle.</div>
</td>
</tr>
<tr id="i266" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#rectangle-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Point-org.opencv.core.Scalar-int-int-int-">rectangle</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
         <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt1,
         <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt2,
         <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
         int&nbsp;thickness,
         int&nbsp;lineType,
         int&nbsp;shift)</code>
<div class="block">Draws a simple, thick, or filled up-right rectangle.</div>
</td>
</tr>
<tr id="i267" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#rectangle-org.opencv.core.Mat-org.opencv.core.Rect-org.opencv.core.Scalar-">rectangle</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
         <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;rec,
         <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color)</code>
<div class="block">use <code>rec</code> parameter as alternative specification of the drawn rectangle: `r.tl() and
 r.br()-Point(1,1)` are opposite corners</div>
</td>
</tr>
<tr id="i268" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#rectangle-org.opencv.core.Mat-org.opencv.core.Rect-org.opencv.core.Scalar-int-">rectangle</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
         <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;rec,
         <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
         int&nbsp;thickness)</code>
<div class="block">use <code>rec</code> parameter as alternative specification of the drawn rectangle: `r.tl() and
 r.br()-Point(1,1)` are opposite corners</div>
</td>
</tr>
<tr id="i269" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#rectangle-org.opencv.core.Mat-org.opencv.core.Rect-org.opencv.core.Scalar-int-int-">rectangle</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
         <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;rec,
         <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
         int&nbsp;thickness,
         int&nbsp;lineType)</code>
<div class="block">use <code>rec</code> parameter as alternative specification of the drawn rectangle: `r.tl() and
 r.br()-Point(1,1)` are opposite corners</div>
</td>
</tr>
<tr id="i270" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#rectangle-org.opencv.core.Mat-org.opencv.core.Rect-org.opencv.core.Scalar-int-int-int-">rectangle</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
         <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;rec,
         <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
         int&nbsp;thickness,
         int&nbsp;lineType,
         int&nbsp;shift)</code>
<div class="block">use <code>rec</code> parameter as alternative specification of the drawn rectangle: `r.tl() and
 r.br()-Point(1,1)` are opposite corners</div>
</td>
</tr>
<tr id="i271" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#remap-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">remap</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map1,
     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map2,
     int&nbsp;interpolation)</code>
<div class="block">Applies a generic geometrical transformation to an image.</div>
</td>
</tr>
<tr id="i272" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#remap-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-int-">remap</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map1,
     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map2,
     int&nbsp;interpolation,
     int&nbsp;borderMode)</code>
<div class="block">Applies a generic geometrical transformation to an image.</div>
</td>
</tr>
<tr id="i273" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#remap-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-int-org.opencv.core.Scalar-">remap</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map1,
     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map2,
     int&nbsp;interpolation,
     int&nbsp;borderMode,
     <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;borderValue)</code>
<div class="block">Applies a generic geometrical transformation to an image.</div>
</td>
</tr>
<tr id="i274" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#resize-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-">resize</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
      <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dsize)</code>
<div class="block">Resizes an image.</div>
</td>
</tr>
<tr id="i275" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#resize-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-double-">resize</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
      <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dsize,
      double&nbsp;fx)</code>
<div class="block">Resizes an image.</div>
</td>
</tr>
<tr id="i276" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#resize-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-double-double-">resize</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
      <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dsize,
      double&nbsp;fx,
      double&nbsp;fy)</code>
<div class="block">Resizes an image.</div>
</td>
</tr>
<tr id="i277" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#resize-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-double-double-int-">resize</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
      <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dsize,
      double&nbsp;fx,
      double&nbsp;fy,
      int&nbsp;interpolation)</code>
<div class="block">Resizes an image.</div>
</td>
</tr>
<tr id="i278" class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#rotatedRectangleIntersection-org.opencv.core.RotatedRect-org.opencv.core.RotatedRect-org.opencv.core.Mat-">rotatedRectangleIntersection</a></span>(<a href="../../../org/opencv/core/RotatedRect.html" title="class in org.opencv.core">RotatedRect</a>&nbsp;rect1,
                            <a href="../../../org/opencv/core/RotatedRect.html" title="class in org.opencv.core">RotatedRect</a>&nbsp;rect2,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;intersectingRegion)</code>
<div class="block">Finds out if there is any intersection between two rotated rectangles.</div>
</td>
</tr>
<tr id="i279" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#Scharr-org.opencv.core.Mat-org.opencv.core.Mat-int-int-int-">Scharr</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
      int&nbsp;ddepth,
      int&nbsp;dx,
      int&nbsp;dy)</code>
<div class="block">Calculates the first x- or y- image derivative using Scharr operator.</div>
</td>
</tr>
<tr id="i280" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#Scharr-org.opencv.core.Mat-org.opencv.core.Mat-int-int-int-double-">Scharr</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
      int&nbsp;ddepth,
      int&nbsp;dx,
      int&nbsp;dy,
      double&nbsp;scale)</code>
<div class="block">Calculates the first x- or y- image derivative using Scharr operator.</div>
</td>
</tr>
<tr id="i281" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#Scharr-org.opencv.core.Mat-org.opencv.core.Mat-int-int-int-double-double-">Scharr</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
      int&nbsp;ddepth,
      int&nbsp;dx,
      int&nbsp;dy,
      double&nbsp;scale,
      double&nbsp;delta)</code>
<div class="block">Calculates the first x- or y- image derivative using Scharr operator.</div>
</td>
</tr>
<tr id="i282" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#Scharr-org.opencv.core.Mat-org.opencv.core.Mat-int-int-int-double-double-int-">Scharr</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
      int&nbsp;ddepth,
      int&nbsp;dx,
      int&nbsp;dy,
      double&nbsp;scale,
      double&nbsp;delta,
      int&nbsp;borderType)</code>
<div class="block">Calculates the first x- or y- image derivative using Scharr operator.</div>
</td>
</tr>
<tr id="i283" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#sepFilter2D-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Mat-org.opencv.core.Mat-">sepFilter2D</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
           int&nbsp;ddepth,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernelX,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernelY)</code>
<div class="block">Applies a separable linear filter to an image.</div>
</td>
</tr>
<tr id="i284" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#sepFilter2D-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Point-">sepFilter2D</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
           int&nbsp;ddepth,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernelX,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernelY,
           <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor)</code>
<div class="block">Applies a separable linear filter to an image.</div>
</td>
</tr>
<tr id="i285" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#sepFilter2D-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Point-double-">sepFilter2D</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
           int&nbsp;ddepth,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernelX,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernelY,
           <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
           double&nbsp;delta)</code>
<div class="block">Applies a separable linear filter to an image.</div>
</td>
</tr>
<tr id="i286" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#sepFilter2D-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Point-double-int-">sepFilter2D</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
           int&nbsp;ddepth,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernelX,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernelY,
           <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
           double&nbsp;delta,
           int&nbsp;borderType)</code>
<div class="block">Applies a separable linear filter to an image.</div>
</td>
</tr>
<tr id="i287" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#Sobel-org.opencv.core.Mat-org.opencv.core.Mat-int-int-int-">Sobel</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
     int&nbsp;ddepth,
     int&nbsp;dx,
     int&nbsp;dy)</code>
<div class="block">Calculates the first, second, third, or mixed image derivatives using an extended Sobel operator.</div>
</td>
</tr>
<tr id="i288" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#Sobel-org.opencv.core.Mat-org.opencv.core.Mat-int-int-int-int-">Sobel</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
     int&nbsp;ddepth,
     int&nbsp;dx,
     int&nbsp;dy,
     int&nbsp;ksize)</code>
<div class="block">Calculates the first, second, third, or mixed image derivatives using an extended Sobel operator.</div>
</td>
</tr>
<tr id="i289" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#Sobel-org.opencv.core.Mat-org.opencv.core.Mat-int-int-int-int-double-">Sobel</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
     int&nbsp;ddepth,
     int&nbsp;dx,
     int&nbsp;dy,
     int&nbsp;ksize,
     double&nbsp;scale)</code>
<div class="block">Calculates the first, second, third, or mixed image derivatives using an extended Sobel operator.</div>
</td>
</tr>
<tr id="i290" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#Sobel-org.opencv.core.Mat-org.opencv.core.Mat-int-int-int-int-double-double-">Sobel</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
     int&nbsp;ddepth,
     int&nbsp;dx,
     int&nbsp;dy,
     int&nbsp;ksize,
     double&nbsp;scale,
     double&nbsp;delta)</code>
<div class="block">Calculates the first, second, third, or mixed image derivatives using an extended Sobel operator.</div>
</td>
</tr>
<tr id="i291" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#Sobel-org.opencv.core.Mat-org.opencv.core.Mat-int-int-int-int-double-double-int-">Sobel</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
     int&nbsp;ddepth,
     int&nbsp;dx,
     int&nbsp;dy,
     int&nbsp;ksize,
     double&nbsp;scale,
     double&nbsp;delta,
     int&nbsp;borderType)</code>
<div class="block">Calculates the first, second, third, or mixed image derivatives using an extended Sobel operator.</div>
</td>
</tr>
<tr id="i292" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#spatialGradient-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">spatialGradient</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dx,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dy)</code>
<div class="block">Calculates the first order image derivative in both x and y using a Sobel operator

 Equivalent to calling:

 <code>
 Sobel( src, dx, CV_16SC1, 1, 0, 3 );
 Sobel( src, dy, CV_16SC1, 0, 1, 3 );
 </code></div>
</td>
</tr>
<tr id="i293" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#spatialGradient-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">spatialGradient</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dx,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dy,
               int&nbsp;ksize)</code>
<div class="block">Calculates the first order image derivative in both x and y using a Sobel operator

 Equivalent to calling:

 <code>
 Sobel( src, dx, CV_16SC1, 1, 0, 3 );
 Sobel( src, dy, CV_16SC1, 0, 1, 3 );
 </code></div>
</td>
</tr>
<tr id="i294" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#spatialGradient-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-int-">spatialGradient</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dx,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dy,
               int&nbsp;ksize,
               int&nbsp;borderType)</code>
<div class="block">Calculates the first order image derivative in both x and y using a Sobel operator

 Equivalent to calling:

 <code>
 Sobel( src, dx, CV_16SC1, 1, 0, 3 );
 Sobel( src, dy, CV_16SC1, 0, 1, 3 );
 </code></div>
</td>
</tr>
<tr id="i295" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#sqrBoxFilter-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Size-">sqrBoxFilter</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
            int&nbsp;ddepth,
            <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize)</code>
<div class="block">Calculates the normalized sum of squares of the pixel values overlapping the filter.</div>
</td>
</tr>
<tr id="i296" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#sqrBoxFilter-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Size-org.opencv.core.Point-">sqrBoxFilter</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
            int&nbsp;ddepth,
            <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
            <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor)</code>
<div class="block">Calculates the normalized sum of squares of the pixel values overlapping the filter.</div>
</td>
</tr>
<tr id="i297" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#sqrBoxFilter-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Size-org.opencv.core.Point-boolean-">sqrBoxFilter</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
            int&nbsp;ddepth,
            <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
            <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
            boolean&nbsp;normalize)</code>
<div class="block">Calculates the normalized sum of squares of the pixel values overlapping the filter.</div>
</td>
</tr>
<tr id="i298" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#sqrBoxFilter-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Size-org.opencv.core.Point-boolean-int-">sqrBoxFilter</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
            int&nbsp;ddepth,
            <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
            <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
            boolean&nbsp;normalize,
            int&nbsp;borderType)</code>
<div class="block">Calculates the normalized sum of squares of the pixel values overlapping the filter.</div>
</td>
</tr>
<tr id="i299" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#stackBlur-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-">stackBlur</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
         <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize)</code>
<div class="block">Blurs an image using the stackBlur.</div>
</td>
</tr>
<tr id="i300" class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#threshold-org.opencv.core.Mat-org.opencv.core.Mat-double-double-int-">threshold</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
         double&nbsp;thresh,
         double&nbsp;maxval,
         int&nbsp;type)</code>
<div class="block">Applies a fixed-level threshold to each array element.</div>
</td>
</tr>
<tr id="i301" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#warpAffine-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-">warpAffine</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;M,
          <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dsize)</code>
<div class="block">Applies an affine transformation to an image.</div>
</td>
</tr>
<tr id="i302" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#warpAffine-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-int-">warpAffine</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;M,
          <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dsize,
          int&nbsp;flags)</code>
<div class="block">Applies an affine transformation to an image.</div>
</td>
</tr>
<tr id="i303" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#warpAffine-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-int-int-">warpAffine</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;M,
          <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dsize,
          int&nbsp;flags,
          int&nbsp;borderMode)</code>
<div class="block">Applies an affine transformation to an image.</div>
</td>
</tr>
<tr id="i304" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#warpAffine-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-int-int-org.opencv.core.Scalar-">warpAffine</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;M,
          <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dsize,
          int&nbsp;flags,
          int&nbsp;borderMode,
          <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;borderValue)</code>
<div class="block">Applies an affine transformation to an image.</div>
</td>
</tr>
<tr id="i305" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#warpPerspective-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-">warpPerspective</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;M,
               <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dsize)</code>
<div class="block">Applies a perspective transformation to an image.</div>
</td>
</tr>
<tr id="i306" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#warpPerspective-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-int-">warpPerspective</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;M,
               <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dsize,
               int&nbsp;flags)</code>
<div class="block">Applies a perspective transformation to an image.</div>
</td>
</tr>
<tr id="i307" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#warpPerspective-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-int-int-">warpPerspective</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;M,
               <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dsize,
               int&nbsp;flags,
               int&nbsp;borderMode)</code>
<div class="block">Applies a perspective transformation to an image.</div>
</td>
</tr>
<tr id="i308" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#warpPerspective-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-int-int-org.opencv.core.Scalar-">warpPerspective</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;M,
               <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dsize,
               int&nbsp;flags,
               int&nbsp;borderMode,
               <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;borderValue)</code>
<div class="block">Applies a perspective transformation to an image.</div>
</td>
</tr>
<tr id="i309" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#warpPolar-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-org.opencv.core.Point-double-int-">warpPolar</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
         <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dsize,
         <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
         double&nbsp;maxRadius,
         int&nbsp;flags)</code>
<div class="block">Remaps an image to polar or semilog-polar coordinates space

  polar_remaps_reference_image
 ![Polar remaps reference](pics/polar_remap_doc.png)

 Transform the source image using the following transformation:
 \(
 dst(\rho , \phi ) = src(x,y)
 \)

 where
 \(
 \begin{array}{l}
 \vec{I} = (x - center.x, \;y - center.y) \\
 \phi = Kangle \cdot \texttt{angle} (\vec{I}) \\
 \rho = \left\{\begin{matrix}
 Klin \cdot \texttt{magnitude} (\vec{I}) &amp; default \\
 Klog \cdot log_e(\texttt{magnitude} (\vec{I})) &amp; if \; semilog \\
 \end{matrix}\right.</div>
</td>
</tr>
<tr id="i310" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/imgproc/Imgproc.html#watershed-org.opencv.core.Mat-org.opencv.core.Mat-">watershed</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;markers)</code>
<div class="block">Performs a marker-based image segmentation using the watershed algorithm.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a name="ADAPTIVE_THRESH_GAUSSIAN_C">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ADAPTIVE_THRESH_GAUSSIAN_C</h4>
<pre>public static final&nbsp;int ADAPTIVE_THRESH_GAUSSIAN_C</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.ADAPTIVE_THRESH_GAUSSIAN_C">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="ADAPTIVE_THRESH_MEAN_C">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ADAPTIVE_THRESH_MEAN_C</h4>
<pre>public static final&nbsp;int ADAPTIVE_THRESH_MEAN_C</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.ADAPTIVE_THRESH_MEAN_C">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CC_STAT_AREA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CC_STAT_AREA</h4>
<pre>public static final&nbsp;int CC_STAT_AREA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CC_STAT_AREA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CC_STAT_HEIGHT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CC_STAT_HEIGHT</h4>
<pre>public static final&nbsp;int CC_STAT_HEIGHT</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CC_STAT_HEIGHT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CC_STAT_LEFT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CC_STAT_LEFT</h4>
<pre>public static final&nbsp;int CC_STAT_LEFT</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CC_STAT_LEFT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CC_STAT_MAX">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CC_STAT_MAX</h4>
<pre>public static final&nbsp;int CC_STAT_MAX</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CC_STAT_MAX">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CC_STAT_TOP">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CC_STAT_TOP</h4>
<pre>public static final&nbsp;int CC_STAT_TOP</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CC_STAT_TOP">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CC_STAT_WIDTH">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CC_STAT_WIDTH</h4>
<pre>public static final&nbsp;int CC_STAT_WIDTH</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CC_STAT_WIDTH">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CCL_BBDT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CCL_BBDT</h4>
<pre>public static final&nbsp;int CCL_BBDT</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CCL_BBDT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CCL_BOLELLI">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CCL_BOLELLI</h4>
<pre>public static final&nbsp;int CCL_BOLELLI</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CCL_BOLELLI">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CCL_DEFAULT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CCL_DEFAULT</h4>
<pre>public static final&nbsp;int CCL_DEFAULT</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CCL_DEFAULT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CCL_GRANA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CCL_GRANA</h4>
<pre>public static final&nbsp;int CCL_GRANA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CCL_GRANA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CCL_SAUF">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CCL_SAUF</h4>
<pre>public static final&nbsp;int CCL_SAUF</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CCL_SAUF">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CCL_SPAGHETTI">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CCL_SPAGHETTI</h4>
<pre>public static final&nbsp;int CCL_SPAGHETTI</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CCL_SPAGHETTI">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CCL_WU">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CCL_WU</h4>
<pre>public static final&nbsp;int CCL_WU</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CCL_WU">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CHAIN_APPROX_NONE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CHAIN_APPROX_NONE</h4>
<pre>public static final&nbsp;int CHAIN_APPROX_NONE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CHAIN_APPROX_NONE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CHAIN_APPROX_SIMPLE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CHAIN_APPROX_SIMPLE</h4>
<pre>public static final&nbsp;int CHAIN_APPROX_SIMPLE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CHAIN_APPROX_SIMPLE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CHAIN_APPROX_TC89_KCOS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CHAIN_APPROX_TC89_KCOS</h4>
<pre>public static final&nbsp;int CHAIN_APPROX_TC89_KCOS</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CHAIN_APPROX_TC89_KCOS">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CHAIN_APPROX_TC89_L1">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CHAIN_APPROX_TC89_L1</h4>
<pre>public static final&nbsp;int CHAIN_APPROX_TC89_L1</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CHAIN_APPROX_TC89_L1">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerBG2BGR">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerBG2BGR</h4>
<pre>public static final&nbsp;int COLOR_BayerBG2BGR</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerBG2BGR">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerBG2BGR_EA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerBG2BGR_EA</h4>
<pre>public static final&nbsp;int COLOR_BayerBG2BGR_EA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerBG2BGR_EA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerBG2BGR_VNG">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerBG2BGR_VNG</h4>
<pre>public static final&nbsp;int COLOR_BayerBG2BGR_VNG</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerBG2BGR_VNG">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerBG2BGRA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerBG2BGRA</h4>
<pre>public static final&nbsp;int COLOR_BayerBG2BGRA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerBG2BGRA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerBG2GRAY">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerBG2GRAY</h4>
<pre>public static final&nbsp;int COLOR_BayerBG2GRAY</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerBG2GRAY">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerBG2RGB">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerBG2RGB</h4>
<pre>public static final&nbsp;int COLOR_BayerBG2RGB</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerBG2RGB">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerBG2RGB_EA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerBG2RGB_EA</h4>
<pre>public static final&nbsp;int COLOR_BayerBG2RGB_EA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerBG2RGB_EA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerBG2RGB_VNG">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerBG2RGB_VNG</h4>
<pre>public static final&nbsp;int COLOR_BayerBG2RGB_VNG</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerBG2RGB_VNG">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerBG2RGBA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerBG2RGBA</h4>
<pre>public static final&nbsp;int COLOR_BayerBG2RGBA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerBG2RGBA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerBGGR2BGR">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerBGGR2BGR</h4>
<pre>public static final&nbsp;int COLOR_BayerBGGR2BGR</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerBGGR2BGR">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerBGGR2BGR_EA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerBGGR2BGR_EA</h4>
<pre>public static final&nbsp;int COLOR_BayerBGGR2BGR_EA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerBGGR2BGR_EA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerBGGR2BGR_VNG">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerBGGR2BGR_VNG</h4>
<pre>public static final&nbsp;int COLOR_BayerBGGR2BGR_VNG</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerBGGR2BGR_VNG">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerBGGR2BGRA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerBGGR2BGRA</h4>
<pre>public static final&nbsp;int COLOR_BayerBGGR2BGRA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerBGGR2BGRA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerBGGR2GRAY">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerBGGR2GRAY</h4>
<pre>public static final&nbsp;int COLOR_BayerBGGR2GRAY</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerBGGR2GRAY">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerBGGR2RGB">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerBGGR2RGB</h4>
<pre>public static final&nbsp;int COLOR_BayerBGGR2RGB</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerBGGR2RGB">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerBGGR2RGB_EA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerBGGR2RGB_EA</h4>
<pre>public static final&nbsp;int COLOR_BayerBGGR2RGB_EA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerBGGR2RGB_EA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerBGGR2RGB_VNG">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerBGGR2RGB_VNG</h4>
<pre>public static final&nbsp;int COLOR_BayerBGGR2RGB_VNG</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerBGGR2RGB_VNG">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerBGGR2RGBA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerBGGR2RGBA</h4>
<pre>public static final&nbsp;int COLOR_BayerBGGR2RGBA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerBGGR2RGBA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerGB2BGR">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerGB2BGR</h4>
<pre>public static final&nbsp;int COLOR_BayerGB2BGR</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerGB2BGR">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerGB2BGR_EA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerGB2BGR_EA</h4>
<pre>public static final&nbsp;int COLOR_BayerGB2BGR_EA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerGB2BGR_EA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerGB2BGR_VNG">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerGB2BGR_VNG</h4>
<pre>public static final&nbsp;int COLOR_BayerGB2BGR_VNG</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerGB2BGR_VNG">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerGB2BGRA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerGB2BGRA</h4>
<pre>public static final&nbsp;int COLOR_BayerGB2BGRA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerGB2BGRA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerGB2GRAY">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerGB2GRAY</h4>
<pre>public static final&nbsp;int COLOR_BayerGB2GRAY</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerGB2GRAY">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerGB2RGB">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerGB2RGB</h4>
<pre>public static final&nbsp;int COLOR_BayerGB2RGB</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerGB2RGB">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerGB2RGB_EA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerGB2RGB_EA</h4>
<pre>public static final&nbsp;int COLOR_BayerGB2RGB_EA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerGB2RGB_EA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerGB2RGB_VNG">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerGB2RGB_VNG</h4>
<pre>public static final&nbsp;int COLOR_BayerGB2RGB_VNG</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerGB2RGB_VNG">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerGB2RGBA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerGB2RGBA</h4>
<pre>public static final&nbsp;int COLOR_BayerGB2RGBA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerGB2RGBA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerGBRG2BGR">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerGBRG2BGR</h4>
<pre>public static final&nbsp;int COLOR_BayerGBRG2BGR</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerGBRG2BGR">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerGBRG2BGR_EA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerGBRG2BGR_EA</h4>
<pre>public static final&nbsp;int COLOR_BayerGBRG2BGR_EA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerGBRG2BGR_EA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerGBRG2BGR_VNG">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerGBRG2BGR_VNG</h4>
<pre>public static final&nbsp;int COLOR_BayerGBRG2BGR_VNG</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerGBRG2BGR_VNG">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerGBRG2BGRA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerGBRG2BGRA</h4>
<pre>public static final&nbsp;int COLOR_BayerGBRG2BGRA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerGBRG2BGRA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerGBRG2GRAY">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerGBRG2GRAY</h4>
<pre>public static final&nbsp;int COLOR_BayerGBRG2GRAY</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerGBRG2GRAY">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerGBRG2RGB">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerGBRG2RGB</h4>
<pre>public static final&nbsp;int COLOR_BayerGBRG2RGB</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerGBRG2RGB">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerGBRG2RGB_EA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerGBRG2RGB_EA</h4>
<pre>public static final&nbsp;int COLOR_BayerGBRG2RGB_EA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerGBRG2RGB_EA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerGBRG2RGB_VNG">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerGBRG2RGB_VNG</h4>
<pre>public static final&nbsp;int COLOR_BayerGBRG2RGB_VNG</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerGBRG2RGB_VNG">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerGBRG2RGBA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerGBRG2RGBA</h4>
<pre>public static final&nbsp;int COLOR_BayerGBRG2RGBA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerGBRG2RGBA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerGR2BGR">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerGR2BGR</h4>
<pre>public static final&nbsp;int COLOR_BayerGR2BGR</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerGR2BGR">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerGR2BGR_EA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerGR2BGR_EA</h4>
<pre>public static final&nbsp;int COLOR_BayerGR2BGR_EA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerGR2BGR_EA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerGR2BGR_VNG">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerGR2BGR_VNG</h4>
<pre>public static final&nbsp;int COLOR_BayerGR2BGR_VNG</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerGR2BGR_VNG">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerGR2BGRA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerGR2BGRA</h4>
<pre>public static final&nbsp;int COLOR_BayerGR2BGRA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerGR2BGRA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerGR2GRAY">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerGR2GRAY</h4>
<pre>public static final&nbsp;int COLOR_BayerGR2GRAY</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerGR2GRAY">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerGR2RGB">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerGR2RGB</h4>
<pre>public static final&nbsp;int COLOR_BayerGR2RGB</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerGR2RGB">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerGR2RGB_EA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerGR2RGB_EA</h4>
<pre>public static final&nbsp;int COLOR_BayerGR2RGB_EA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerGR2RGB_EA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerGR2RGB_VNG">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerGR2RGB_VNG</h4>
<pre>public static final&nbsp;int COLOR_BayerGR2RGB_VNG</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerGR2RGB_VNG">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerGR2RGBA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerGR2RGBA</h4>
<pre>public static final&nbsp;int COLOR_BayerGR2RGBA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerGR2RGBA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerGRBG2BGR">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerGRBG2BGR</h4>
<pre>public static final&nbsp;int COLOR_BayerGRBG2BGR</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerGRBG2BGR">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerGRBG2BGR_EA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerGRBG2BGR_EA</h4>
<pre>public static final&nbsp;int COLOR_BayerGRBG2BGR_EA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerGRBG2BGR_EA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerGRBG2BGR_VNG">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerGRBG2BGR_VNG</h4>
<pre>public static final&nbsp;int COLOR_BayerGRBG2BGR_VNG</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerGRBG2BGR_VNG">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerGRBG2BGRA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerGRBG2BGRA</h4>
<pre>public static final&nbsp;int COLOR_BayerGRBG2BGRA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerGRBG2BGRA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerGRBG2GRAY">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerGRBG2GRAY</h4>
<pre>public static final&nbsp;int COLOR_BayerGRBG2GRAY</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerGRBG2GRAY">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerGRBG2RGB">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerGRBG2RGB</h4>
<pre>public static final&nbsp;int COLOR_BayerGRBG2RGB</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerGRBG2RGB">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerGRBG2RGB_EA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerGRBG2RGB_EA</h4>
<pre>public static final&nbsp;int COLOR_BayerGRBG2RGB_EA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerGRBG2RGB_EA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerGRBG2RGB_VNG">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerGRBG2RGB_VNG</h4>
<pre>public static final&nbsp;int COLOR_BayerGRBG2RGB_VNG</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerGRBG2RGB_VNG">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerGRBG2RGBA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerGRBG2RGBA</h4>
<pre>public static final&nbsp;int COLOR_BayerGRBG2RGBA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerGRBG2RGBA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerRG2BGR">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerRG2BGR</h4>
<pre>public static final&nbsp;int COLOR_BayerRG2BGR</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerRG2BGR">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerRG2BGR_EA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerRG2BGR_EA</h4>
<pre>public static final&nbsp;int COLOR_BayerRG2BGR_EA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerRG2BGR_EA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerRG2BGR_VNG">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerRG2BGR_VNG</h4>
<pre>public static final&nbsp;int COLOR_BayerRG2BGR_VNG</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerRG2BGR_VNG">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerRG2BGRA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerRG2BGRA</h4>
<pre>public static final&nbsp;int COLOR_BayerRG2BGRA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerRG2BGRA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerRG2GRAY">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerRG2GRAY</h4>
<pre>public static final&nbsp;int COLOR_BayerRG2GRAY</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerRG2GRAY">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerRG2RGB">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerRG2RGB</h4>
<pre>public static final&nbsp;int COLOR_BayerRG2RGB</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerRG2RGB">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerRG2RGB_EA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerRG2RGB_EA</h4>
<pre>public static final&nbsp;int COLOR_BayerRG2RGB_EA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerRG2RGB_EA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerRG2RGB_VNG">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerRG2RGB_VNG</h4>
<pre>public static final&nbsp;int COLOR_BayerRG2RGB_VNG</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerRG2RGB_VNG">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerRG2RGBA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerRG2RGBA</h4>
<pre>public static final&nbsp;int COLOR_BayerRG2RGBA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerRG2RGBA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerRGGB2BGR">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerRGGB2BGR</h4>
<pre>public static final&nbsp;int COLOR_BayerRGGB2BGR</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerRGGB2BGR">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerRGGB2BGR_EA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerRGGB2BGR_EA</h4>
<pre>public static final&nbsp;int COLOR_BayerRGGB2BGR_EA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerRGGB2BGR_EA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerRGGB2BGR_VNG">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerRGGB2BGR_VNG</h4>
<pre>public static final&nbsp;int COLOR_BayerRGGB2BGR_VNG</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerRGGB2BGR_VNG">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerRGGB2BGRA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerRGGB2BGRA</h4>
<pre>public static final&nbsp;int COLOR_BayerRGGB2BGRA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerRGGB2BGRA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerRGGB2GRAY">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerRGGB2GRAY</h4>
<pre>public static final&nbsp;int COLOR_BayerRGGB2GRAY</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerRGGB2GRAY">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerRGGB2RGB">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerRGGB2RGB</h4>
<pre>public static final&nbsp;int COLOR_BayerRGGB2RGB</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerRGGB2RGB">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerRGGB2RGB_EA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerRGGB2RGB_EA</h4>
<pre>public static final&nbsp;int COLOR_BayerRGGB2RGB_EA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerRGGB2RGB_EA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerRGGB2RGB_VNG">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerRGGB2RGB_VNG</h4>
<pre>public static final&nbsp;int COLOR_BayerRGGB2RGB_VNG</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerRGGB2RGB_VNG">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BayerRGGB2RGBA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BayerRGGB2RGBA</h4>
<pre>public static final&nbsp;int COLOR_BayerRGGB2RGBA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BayerRGGB2RGBA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BGR2BGR555">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BGR2BGR555</h4>
<pre>public static final&nbsp;int COLOR_BGR2BGR555</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR2BGR555">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BGR2BGR565">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BGR2BGR565</h4>
<pre>public static final&nbsp;int COLOR_BGR2BGR565</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR2BGR565">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BGR2BGRA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BGR2BGRA</h4>
<pre>public static final&nbsp;int COLOR_BGR2BGRA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR2BGRA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BGR2GRAY">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BGR2GRAY</h4>
<pre>public static final&nbsp;int COLOR_BGR2GRAY</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR2GRAY">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BGR2HLS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BGR2HLS</h4>
<pre>public static final&nbsp;int COLOR_BGR2HLS</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR2HLS">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BGR2HLS_FULL">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BGR2HLS_FULL</h4>
<pre>public static final&nbsp;int COLOR_BGR2HLS_FULL</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR2HLS_FULL">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BGR2HSV">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BGR2HSV</h4>
<pre>public static final&nbsp;int COLOR_BGR2HSV</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR2HSV">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BGR2HSV_FULL">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BGR2HSV_FULL</h4>
<pre>public static final&nbsp;int COLOR_BGR2HSV_FULL</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR2HSV_FULL">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BGR2Lab">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BGR2Lab</h4>
<pre>public static final&nbsp;int COLOR_BGR2Lab</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR2Lab">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BGR2Luv">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BGR2Luv</h4>
<pre>public static final&nbsp;int COLOR_BGR2Luv</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR2Luv">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BGR2RGB">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BGR2RGB</h4>
<pre>public static final&nbsp;int COLOR_BGR2RGB</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR2RGB">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BGR2RGBA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BGR2RGBA</h4>
<pre>public static final&nbsp;int COLOR_BGR2RGBA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR2RGBA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BGR2XYZ">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BGR2XYZ</h4>
<pre>public static final&nbsp;int COLOR_BGR2XYZ</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR2XYZ">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BGR2YCrCb">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BGR2YCrCb</h4>
<pre>public static final&nbsp;int COLOR_BGR2YCrCb</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR2YCrCb">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BGR2YUV">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BGR2YUV</h4>
<pre>public static final&nbsp;int COLOR_BGR2YUV</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR2YUV">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BGR2YUV_I420">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BGR2YUV_I420</h4>
<pre>public static final&nbsp;int COLOR_BGR2YUV_I420</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR2YUV_I420">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BGR2YUV_IYUV">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BGR2YUV_IYUV</h4>
<pre>public static final&nbsp;int COLOR_BGR2YUV_IYUV</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR2YUV_IYUV">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BGR2YUV_YV12">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BGR2YUV_YV12</h4>
<pre>public static final&nbsp;int COLOR_BGR2YUV_YV12</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR2YUV_YV12">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BGR5552BGR">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BGR5552BGR</h4>
<pre>public static final&nbsp;int COLOR_BGR5552BGR</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR5552BGR">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BGR5552BGRA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BGR5552BGRA</h4>
<pre>public static final&nbsp;int COLOR_BGR5552BGRA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR5552BGRA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BGR5552GRAY">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BGR5552GRAY</h4>
<pre>public static final&nbsp;int COLOR_BGR5552GRAY</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR5552GRAY">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BGR5552RGB">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BGR5552RGB</h4>
<pre>public static final&nbsp;int COLOR_BGR5552RGB</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR5552RGB">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BGR5552RGBA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BGR5552RGBA</h4>
<pre>public static final&nbsp;int COLOR_BGR5552RGBA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR5552RGBA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BGR5652BGR">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BGR5652BGR</h4>
<pre>public static final&nbsp;int COLOR_BGR5652BGR</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR5652BGR">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BGR5652BGRA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BGR5652BGRA</h4>
<pre>public static final&nbsp;int COLOR_BGR5652BGRA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR5652BGRA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BGR5652GRAY">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BGR5652GRAY</h4>
<pre>public static final&nbsp;int COLOR_BGR5652GRAY</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR5652GRAY">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BGR5652RGB">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BGR5652RGB</h4>
<pre>public static final&nbsp;int COLOR_BGR5652RGB</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR5652RGB">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BGR5652RGBA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BGR5652RGBA</h4>
<pre>public static final&nbsp;int COLOR_BGR5652RGBA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGR5652RGBA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BGRA2BGR">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BGRA2BGR</h4>
<pre>public static final&nbsp;int COLOR_BGRA2BGR</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGRA2BGR">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BGRA2BGR555">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BGRA2BGR555</h4>
<pre>public static final&nbsp;int COLOR_BGRA2BGR555</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGRA2BGR555">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BGRA2BGR565">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BGRA2BGR565</h4>
<pre>public static final&nbsp;int COLOR_BGRA2BGR565</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGRA2BGR565">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BGRA2GRAY">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BGRA2GRAY</h4>
<pre>public static final&nbsp;int COLOR_BGRA2GRAY</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGRA2GRAY">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BGRA2RGB">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BGRA2RGB</h4>
<pre>public static final&nbsp;int COLOR_BGRA2RGB</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGRA2RGB">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BGRA2RGBA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BGRA2RGBA</h4>
<pre>public static final&nbsp;int COLOR_BGRA2RGBA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGRA2RGBA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BGRA2YUV_I420">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BGRA2YUV_I420</h4>
<pre>public static final&nbsp;int COLOR_BGRA2YUV_I420</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGRA2YUV_I420">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BGRA2YUV_IYUV">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BGRA2YUV_IYUV</h4>
<pre>public static final&nbsp;int COLOR_BGRA2YUV_IYUV</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGRA2YUV_IYUV">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_BGRA2YUV_YV12">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_BGRA2YUV_YV12</h4>
<pre>public static final&nbsp;int COLOR_BGRA2YUV_YV12</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_BGRA2YUV_YV12">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_COLORCVT_MAX">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_COLORCVT_MAX</h4>
<pre>public static final&nbsp;int COLOR_COLORCVT_MAX</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_COLORCVT_MAX">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_GRAY2BGR">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_GRAY2BGR</h4>
<pre>public static final&nbsp;int COLOR_GRAY2BGR</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_GRAY2BGR">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_GRAY2BGR555">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_GRAY2BGR555</h4>
<pre>public static final&nbsp;int COLOR_GRAY2BGR555</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_GRAY2BGR555">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_GRAY2BGR565">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_GRAY2BGR565</h4>
<pre>public static final&nbsp;int COLOR_GRAY2BGR565</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_GRAY2BGR565">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_GRAY2BGRA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_GRAY2BGRA</h4>
<pre>public static final&nbsp;int COLOR_GRAY2BGRA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_GRAY2BGRA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_GRAY2RGB">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_GRAY2RGB</h4>
<pre>public static final&nbsp;int COLOR_GRAY2RGB</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_GRAY2RGB">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_GRAY2RGBA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_GRAY2RGBA</h4>
<pre>public static final&nbsp;int COLOR_GRAY2RGBA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_GRAY2RGBA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_HLS2BGR">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_HLS2BGR</h4>
<pre>public static final&nbsp;int COLOR_HLS2BGR</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_HLS2BGR">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_HLS2BGR_FULL">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_HLS2BGR_FULL</h4>
<pre>public static final&nbsp;int COLOR_HLS2BGR_FULL</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_HLS2BGR_FULL">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_HLS2RGB">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_HLS2RGB</h4>
<pre>public static final&nbsp;int COLOR_HLS2RGB</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_HLS2RGB">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_HLS2RGB_FULL">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_HLS2RGB_FULL</h4>
<pre>public static final&nbsp;int COLOR_HLS2RGB_FULL</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_HLS2RGB_FULL">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_HSV2BGR">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_HSV2BGR</h4>
<pre>public static final&nbsp;int COLOR_HSV2BGR</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_HSV2BGR">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_HSV2BGR_FULL">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_HSV2BGR_FULL</h4>
<pre>public static final&nbsp;int COLOR_HSV2BGR_FULL</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_HSV2BGR_FULL">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_HSV2RGB">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_HSV2RGB</h4>
<pre>public static final&nbsp;int COLOR_HSV2RGB</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_HSV2RGB">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_HSV2RGB_FULL">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_HSV2RGB_FULL</h4>
<pre>public static final&nbsp;int COLOR_HSV2RGB_FULL</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_HSV2RGB_FULL">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_Lab2BGR">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_Lab2BGR</h4>
<pre>public static final&nbsp;int COLOR_Lab2BGR</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_Lab2BGR">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_Lab2LBGR">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_Lab2LBGR</h4>
<pre>public static final&nbsp;int COLOR_Lab2LBGR</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_Lab2LBGR">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_Lab2LRGB">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_Lab2LRGB</h4>
<pre>public static final&nbsp;int COLOR_Lab2LRGB</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_Lab2LRGB">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_Lab2RGB">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_Lab2RGB</h4>
<pre>public static final&nbsp;int COLOR_Lab2RGB</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_Lab2RGB">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_LBGR2Lab">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_LBGR2Lab</h4>
<pre>public static final&nbsp;int COLOR_LBGR2Lab</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_LBGR2Lab">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_LBGR2Luv">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_LBGR2Luv</h4>
<pre>public static final&nbsp;int COLOR_LBGR2Luv</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_LBGR2Luv">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_LRGB2Lab">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_LRGB2Lab</h4>
<pre>public static final&nbsp;int COLOR_LRGB2Lab</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_LRGB2Lab">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_LRGB2Luv">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_LRGB2Luv</h4>
<pre>public static final&nbsp;int COLOR_LRGB2Luv</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_LRGB2Luv">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_Luv2BGR">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_Luv2BGR</h4>
<pre>public static final&nbsp;int COLOR_Luv2BGR</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_Luv2BGR">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_Luv2LBGR">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_Luv2LBGR</h4>
<pre>public static final&nbsp;int COLOR_Luv2LBGR</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_Luv2LBGR">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_Luv2LRGB">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_Luv2LRGB</h4>
<pre>public static final&nbsp;int COLOR_Luv2LRGB</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_Luv2LRGB">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_Luv2RGB">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_Luv2RGB</h4>
<pre>public static final&nbsp;int COLOR_Luv2RGB</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_Luv2RGB">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_mRGBA2RGBA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_mRGBA2RGBA</h4>
<pre>public static final&nbsp;int COLOR_mRGBA2RGBA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_mRGBA2RGBA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_RGB2BGR">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_RGB2BGR</h4>
<pre>public static final&nbsp;int COLOR_RGB2BGR</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGB2BGR">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_RGB2BGR555">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_RGB2BGR555</h4>
<pre>public static final&nbsp;int COLOR_RGB2BGR555</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGB2BGR555">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_RGB2BGR565">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_RGB2BGR565</h4>
<pre>public static final&nbsp;int COLOR_RGB2BGR565</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGB2BGR565">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_RGB2BGRA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_RGB2BGRA</h4>
<pre>public static final&nbsp;int COLOR_RGB2BGRA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGB2BGRA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_RGB2GRAY">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_RGB2GRAY</h4>
<pre>public static final&nbsp;int COLOR_RGB2GRAY</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGB2GRAY">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_RGB2HLS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_RGB2HLS</h4>
<pre>public static final&nbsp;int COLOR_RGB2HLS</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGB2HLS">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_RGB2HLS_FULL">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_RGB2HLS_FULL</h4>
<pre>public static final&nbsp;int COLOR_RGB2HLS_FULL</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGB2HLS_FULL">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_RGB2HSV">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_RGB2HSV</h4>
<pre>public static final&nbsp;int COLOR_RGB2HSV</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGB2HSV">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_RGB2HSV_FULL">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_RGB2HSV_FULL</h4>
<pre>public static final&nbsp;int COLOR_RGB2HSV_FULL</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGB2HSV_FULL">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_RGB2Lab">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_RGB2Lab</h4>
<pre>public static final&nbsp;int COLOR_RGB2Lab</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGB2Lab">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_RGB2Luv">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_RGB2Luv</h4>
<pre>public static final&nbsp;int COLOR_RGB2Luv</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGB2Luv">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_RGB2RGBA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_RGB2RGBA</h4>
<pre>public static final&nbsp;int COLOR_RGB2RGBA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGB2RGBA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_RGB2XYZ">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_RGB2XYZ</h4>
<pre>public static final&nbsp;int COLOR_RGB2XYZ</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGB2XYZ">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_RGB2YCrCb">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_RGB2YCrCb</h4>
<pre>public static final&nbsp;int COLOR_RGB2YCrCb</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGB2YCrCb">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_RGB2YUV">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_RGB2YUV</h4>
<pre>public static final&nbsp;int COLOR_RGB2YUV</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGB2YUV">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_RGB2YUV_I420">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_RGB2YUV_I420</h4>
<pre>public static final&nbsp;int COLOR_RGB2YUV_I420</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGB2YUV_I420">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_RGB2YUV_IYUV">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_RGB2YUV_IYUV</h4>
<pre>public static final&nbsp;int COLOR_RGB2YUV_IYUV</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGB2YUV_IYUV">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_RGB2YUV_YV12">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_RGB2YUV_YV12</h4>
<pre>public static final&nbsp;int COLOR_RGB2YUV_YV12</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGB2YUV_YV12">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_RGBA2BGR">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_RGBA2BGR</h4>
<pre>public static final&nbsp;int COLOR_RGBA2BGR</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGBA2BGR">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_RGBA2BGR555">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_RGBA2BGR555</h4>
<pre>public static final&nbsp;int COLOR_RGBA2BGR555</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGBA2BGR555">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_RGBA2BGR565">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_RGBA2BGR565</h4>
<pre>public static final&nbsp;int COLOR_RGBA2BGR565</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGBA2BGR565">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_RGBA2BGRA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_RGBA2BGRA</h4>
<pre>public static final&nbsp;int COLOR_RGBA2BGRA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGBA2BGRA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_RGBA2GRAY">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_RGBA2GRAY</h4>
<pre>public static final&nbsp;int COLOR_RGBA2GRAY</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGBA2GRAY">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_RGBA2mRGBA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_RGBA2mRGBA</h4>
<pre>public static final&nbsp;int COLOR_RGBA2mRGBA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGBA2mRGBA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_RGBA2RGB">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_RGBA2RGB</h4>
<pre>public static final&nbsp;int COLOR_RGBA2RGB</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGBA2RGB">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_RGBA2YUV_I420">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_RGBA2YUV_I420</h4>
<pre>public static final&nbsp;int COLOR_RGBA2YUV_I420</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGBA2YUV_I420">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_RGBA2YUV_IYUV">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_RGBA2YUV_IYUV</h4>
<pre>public static final&nbsp;int COLOR_RGBA2YUV_IYUV</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGBA2YUV_IYUV">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_RGBA2YUV_YV12">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_RGBA2YUV_YV12</h4>
<pre>public static final&nbsp;int COLOR_RGBA2YUV_YV12</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_RGBA2YUV_YV12">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_XYZ2BGR">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_XYZ2BGR</h4>
<pre>public static final&nbsp;int COLOR_XYZ2BGR</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_XYZ2BGR">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_XYZ2RGB">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_XYZ2RGB</h4>
<pre>public static final&nbsp;int COLOR_XYZ2RGB</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_XYZ2RGB">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YCrCb2BGR">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YCrCb2BGR</h4>
<pre>public static final&nbsp;int COLOR_YCrCb2BGR</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YCrCb2BGR">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YCrCb2RGB">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YCrCb2RGB</h4>
<pre>public static final&nbsp;int COLOR_YCrCb2RGB</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YCrCb2RGB">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2BGR">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2BGR</h4>
<pre>public static final&nbsp;int COLOR_YUV2BGR</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGR">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2BGR_I420">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2BGR_I420</h4>
<pre>public static final&nbsp;int COLOR_YUV2BGR_I420</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGR_I420">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2BGR_IYUV">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2BGR_IYUV</h4>
<pre>public static final&nbsp;int COLOR_YUV2BGR_IYUV</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGR_IYUV">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2BGR_NV12">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2BGR_NV12</h4>
<pre>public static final&nbsp;int COLOR_YUV2BGR_NV12</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGR_NV12">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2BGR_NV21">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2BGR_NV21</h4>
<pre>public static final&nbsp;int COLOR_YUV2BGR_NV21</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGR_NV21">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2BGR_UYNV">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2BGR_UYNV</h4>
<pre>public static final&nbsp;int COLOR_YUV2BGR_UYNV</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGR_UYNV">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2BGR_UYVY">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2BGR_UYVY</h4>
<pre>public static final&nbsp;int COLOR_YUV2BGR_UYVY</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGR_UYVY">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2BGR_Y422">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2BGR_Y422</h4>
<pre>public static final&nbsp;int COLOR_YUV2BGR_Y422</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGR_Y422">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2BGR_YUNV">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2BGR_YUNV</h4>
<pre>public static final&nbsp;int COLOR_YUV2BGR_YUNV</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGR_YUNV">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2BGR_YUY2">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2BGR_YUY2</h4>
<pre>public static final&nbsp;int COLOR_YUV2BGR_YUY2</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGR_YUY2">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2BGR_YUYV">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2BGR_YUYV</h4>
<pre>public static final&nbsp;int COLOR_YUV2BGR_YUYV</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGR_YUYV">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2BGR_YV12">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2BGR_YV12</h4>
<pre>public static final&nbsp;int COLOR_YUV2BGR_YV12</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGR_YV12">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2BGR_YVYU">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2BGR_YVYU</h4>
<pre>public static final&nbsp;int COLOR_YUV2BGR_YVYU</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGR_YVYU">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2BGRA_I420">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2BGRA_I420</h4>
<pre>public static final&nbsp;int COLOR_YUV2BGRA_I420</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGRA_I420">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2BGRA_IYUV">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2BGRA_IYUV</h4>
<pre>public static final&nbsp;int COLOR_YUV2BGRA_IYUV</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGRA_IYUV">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2BGRA_NV12">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2BGRA_NV12</h4>
<pre>public static final&nbsp;int COLOR_YUV2BGRA_NV12</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGRA_NV12">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2BGRA_NV21">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2BGRA_NV21</h4>
<pre>public static final&nbsp;int COLOR_YUV2BGRA_NV21</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGRA_NV21">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2BGRA_UYNV">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2BGRA_UYNV</h4>
<pre>public static final&nbsp;int COLOR_YUV2BGRA_UYNV</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGRA_UYNV">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2BGRA_UYVY">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2BGRA_UYVY</h4>
<pre>public static final&nbsp;int COLOR_YUV2BGRA_UYVY</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGRA_UYVY">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2BGRA_Y422">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2BGRA_Y422</h4>
<pre>public static final&nbsp;int COLOR_YUV2BGRA_Y422</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGRA_Y422">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2BGRA_YUNV">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2BGRA_YUNV</h4>
<pre>public static final&nbsp;int COLOR_YUV2BGRA_YUNV</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGRA_YUNV">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2BGRA_YUY2">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2BGRA_YUY2</h4>
<pre>public static final&nbsp;int COLOR_YUV2BGRA_YUY2</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGRA_YUY2">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2BGRA_YUYV">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2BGRA_YUYV</h4>
<pre>public static final&nbsp;int COLOR_YUV2BGRA_YUYV</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGRA_YUYV">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2BGRA_YV12">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2BGRA_YV12</h4>
<pre>public static final&nbsp;int COLOR_YUV2BGRA_YV12</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGRA_YV12">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2BGRA_YVYU">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2BGRA_YVYU</h4>
<pre>public static final&nbsp;int COLOR_YUV2BGRA_YVYU</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2BGRA_YVYU">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2GRAY_420">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2GRAY_420</h4>
<pre>public static final&nbsp;int COLOR_YUV2GRAY_420</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2GRAY_420">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2GRAY_I420">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2GRAY_I420</h4>
<pre>public static final&nbsp;int COLOR_YUV2GRAY_I420</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2GRAY_I420">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2GRAY_IYUV">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2GRAY_IYUV</h4>
<pre>public static final&nbsp;int COLOR_YUV2GRAY_IYUV</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2GRAY_IYUV">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2GRAY_NV12">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2GRAY_NV12</h4>
<pre>public static final&nbsp;int COLOR_YUV2GRAY_NV12</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2GRAY_NV12">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2GRAY_NV21">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2GRAY_NV21</h4>
<pre>public static final&nbsp;int COLOR_YUV2GRAY_NV21</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2GRAY_NV21">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2GRAY_UYNV">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2GRAY_UYNV</h4>
<pre>public static final&nbsp;int COLOR_YUV2GRAY_UYNV</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2GRAY_UYNV">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2GRAY_UYVY">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2GRAY_UYVY</h4>
<pre>public static final&nbsp;int COLOR_YUV2GRAY_UYVY</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2GRAY_UYVY">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2GRAY_Y422">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2GRAY_Y422</h4>
<pre>public static final&nbsp;int COLOR_YUV2GRAY_Y422</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2GRAY_Y422">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2GRAY_YUNV">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2GRAY_YUNV</h4>
<pre>public static final&nbsp;int COLOR_YUV2GRAY_YUNV</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2GRAY_YUNV">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2GRAY_YUY2">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2GRAY_YUY2</h4>
<pre>public static final&nbsp;int COLOR_YUV2GRAY_YUY2</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2GRAY_YUY2">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2GRAY_YUYV">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2GRAY_YUYV</h4>
<pre>public static final&nbsp;int COLOR_YUV2GRAY_YUYV</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2GRAY_YUYV">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2GRAY_YV12">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2GRAY_YV12</h4>
<pre>public static final&nbsp;int COLOR_YUV2GRAY_YV12</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2GRAY_YV12">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2GRAY_YVYU">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2GRAY_YVYU</h4>
<pre>public static final&nbsp;int COLOR_YUV2GRAY_YVYU</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2GRAY_YVYU">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2RGB">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2RGB</h4>
<pre>public static final&nbsp;int COLOR_YUV2RGB</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGB">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2RGB_I420">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2RGB_I420</h4>
<pre>public static final&nbsp;int COLOR_YUV2RGB_I420</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGB_I420">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2RGB_IYUV">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2RGB_IYUV</h4>
<pre>public static final&nbsp;int COLOR_YUV2RGB_IYUV</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGB_IYUV">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2RGB_NV12">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2RGB_NV12</h4>
<pre>public static final&nbsp;int COLOR_YUV2RGB_NV12</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGB_NV12">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2RGB_NV21">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2RGB_NV21</h4>
<pre>public static final&nbsp;int COLOR_YUV2RGB_NV21</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGB_NV21">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2RGB_UYNV">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2RGB_UYNV</h4>
<pre>public static final&nbsp;int COLOR_YUV2RGB_UYNV</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGB_UYNV">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2RGB_UYVY">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2RGB_UYVY</h4>
<pre>public static final&nbsp;int COLOR_YUV2RGB_UYVY</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGB_UYVY">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2RGB_Y422">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2RGB_Y422</h4>
<pre>public static final&nbsp;int COLOR_YUV2RGB_Y422</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGB_Y422">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2RGB_YUNV">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2RGB_YUNV</h4>
<pre>public static final&nbsp;int COLOR_YUV2RGB_YUNV</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGB_YUNV">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2RGB_YUY2">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2RGB_YUY2</h4>
<pre>public static final&nbsp;int COLOR_YUV2RGB_YUY2</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGB_YUY2">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2RGB_YUYV">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2RGB_YUYV</h4>
<pre>public static final&nbsp;int COLOR_YUV2RGB_YUYV</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGB_YUYV">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2RGB_YV12">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2RGB_YV12</h4>
<pre>public static final&nbsp;int COLOR_YUV2RGB_YV12</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGB_YV12">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2RGB_YVYU">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2RGB_YVYU</h4>
<pre>public static final&nbsp;int COLOR_YUV2RGB_YVYU</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGB_YVYU">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2RGBA_I420">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2RGBA_I420</h4>
<pre>public static final&nbsp;int COLOR_YUV2RGBA_I420</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGBA_I420">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2RGBA_IYUV">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2RGBA_IYUV</h4>
<pre>public static final&nbsp;int COLOR_YUV2RGBA_IYUV</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGBA_IYUV">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2RGBA_NV12">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2RGBA_NV12</h4>
<pre>public static final&nbsp;int COLOR_YUV2RGBA_NV12</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGBA_NV12">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2RGBA_NV21">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2RGBA_NV21</h4>
<pre>public static final&nbsp;int COLOR_YUV2RGBA_NV21</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGBA_NV21">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2RGBA_UYNV">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2RGBA_UYNV</h4>
<pre>public static final&nbsp;int COLOR_YUV2RGBA_UYNV</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGBA_UYNV">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2RGBA_UYVY">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2RGBA_UYVY</h4>
<pre>public static final&nbsp;int COLOR_YUV2RGBA_UYVY</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGBA_UYVY">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2RGBA_Y422">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2RGBA_Y422</h4>
<pre>public static final&nbsp;int COLOR_YUV2RGBA_Y422</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGBA_Y422">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2RGBA_YUNV">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2RGBA_YUNV</h4>
<pre>public static final&nbsp;int COLOR_YUV2RGBA_YUNV</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGBA_YUNV">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2RGBA_YUY2">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2RGBA_YUY2</h4>
<pre>public static final&nbsp;int COLOR_YUV2RGBA_YUY2</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGBA_YUY2">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2RGBA_YUYV">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2RGBA_YUYV</h4>
<pre>public static final&nbsp;int COLOR_YUV2RGBA_YUYV</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGBA_YUYV">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2RGBA_YV12">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2RGBA_YV12</h4>
<pre>public static final&nbsp;int COLOR_YUV2RGBA_YV12</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGBA_YV12">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV2RGBA_YVYU">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV2RGBA_YVYU</h4>
<pre>public static final&nbsp;int COLOR_YUV2RGBA_YVYU</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV2RGBA_YVYU">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV420p2BGR">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV420p2BGR</h4>
<pre>public static final&nbsp;int COLOR_YUV420p2BGR</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV420p2BGR">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV420p2BGRA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV420p2BGRA</h4>
<pre>public static final&nbsp;int COLOR_YUV420p2BGRA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV420p2BGRA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV420p2GRAY">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV420p2GRAY</h4>
<pre>public static final&nbsp;int COLOR_YUV420p2GRAY</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV420p2GRAY">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV420p2RGB">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV420p2RGB</h4>
<pre>public static final&nbsp;int COLOR_YUV420p2RGB</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV420p2RGB">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV420p2RGBA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV420p2RGBA</h4>
<pre>public static final&nbsp;int COLOR_YUV420p2RGBA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV420p2RGBA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV420sp2BGR">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV420sp2BGR</h4>
<pre>public static final&nbsp;int COLOR_YUV420sp2BGR</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV420sp2BGR">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV420sp2BGRA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV420sp2BGRA</h4>
<pre>public static final&nbsp;int COLOR_YUV420sp2BGRA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV420sp2BGRA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV420sp2GRAY">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV420sp2GRAY</h4>
<pre>public static final&nbsp;int COLOR_YUV420sp2GRAY</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV420sp2GRAY">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV420sp2RGB">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV420sp2RGB</h4>
<pre>public static final&nbsp;int COLOR_YUV420sp2RGB</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV420sp2RGB">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLOR_YUV420sp2RGBA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLOR_YUV420sp2RGBA</h4>
<pre>public static final&nbsp;int COLOR_YUV420sp2RGBA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLOR_YUV420sp2RGBA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLORMAP_AUTUMN">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLORMAP_AUTUMN</h4>
<pre>public static final&nbsp;int COLORMAP_AUTUMN</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLORMAP_AUTUMN">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLORMAP_BONE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLORMAP_BONE</h4>
<pre>public static final&nbsp;int COLORMAP_BONE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLORMAP_BONE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLORMAP_CIVIDIS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLORMAP_CIVIDIS</h4>
<pre>public static final&nbsp;int COLORMAP_CIVIDIS</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLORMAP_CIVIDIS">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLORMAP_COOL">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLORMAP_COOL</h4>
<pre>public static final&nbsp;int COLORMAP_COOL</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLORMAP_COOL">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLORMAP_DEEPGREEN">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLORMAP_DEEPGREEN</h4>
<pre>public static final&nbsp;int COLORMAP_DEEPGREEN</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLORMAP_DEEPGREEN">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLORMAP_HOT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLORMAP_HOT</h4>
<pre>public static final&nbsp;int COLORMAP_HOT</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLORMAP_HOT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLORMAP_HSV">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLORMAP_HSV</h4>
<pre>public static final&nbsp;int COLORMAP_HSV</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLORMAP_HSV">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLORMAP_INFERNO">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLORMAP_INFERNO</h4>
<pre>public static final&nbsp;int COLORMAP_INFERNO</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLORMAP_INFERNO">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLORMAP_JET">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLORMAP_JET</h4>
<pre>public static final&nbsp;int COLORMAP_JET</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLORMAP_JET">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLORMAP_MAGMA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLORMAP_MAGMA</h4>
<pre>public static final&nbsp;int COLORMAP_MAGMA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLORMAP_MAGMA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLORMAP_OCEAN">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLORMAP_OCEAN</h4>
<pre>public static final&nbsp;int COLORMAP_OCEAN</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLORMAP_OCEAN">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLORMAP_PARULA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLORMAP_PARULA</h4>
<pre>public static final&nbsp;int COLORMAP_PARULA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLORMAP_PARULA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLORMAP_PINK">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLORMAP_PINK</h4>
<pre>public static final&nbsp;int COLORMAP_PINK</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLORMAP_PINK">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLORMAP_PLASMA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLORMAP_PLASMA</h4>
<pre>public static final&nbsp;int COLORMAP_PLASMA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLORMAP_PLASMA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLORMAP_RAINBOW">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLORMAP_RAINBOW</h4>
<pre>public static final&nbsp;int COLORMAP_RAINBOW</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLORMAP_RAINBOW">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLORMAP_SPRING">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLORMAP_SPRING</h4>
<pre>public static final&nbsp;int COLORMAP_SPRING</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLORMAP_SPRING">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLORMAP_SUMMER">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLORMAP_SUMMER</h4>
<pre>public static final&nbsp;int COLORMAP_SUMMER</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLORMAP_SUMMER">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLORMAP_TURBO">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLORMAP_TURBO</h4>
<pre>public static final&nbsp;int COLORMAP_TURBO</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLORMAP_TURBO">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLORMAP_TWILIGHT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLORMAP_TWILIGHT</h4>
<pre>public static final&nbsp;int COLORMAP_TWILIGHT</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLORMAP_TWILIGHT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLORMAP_TWILIGHT_SHIFTED">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLORMAP_TWILIGHT_SHIFTED</h4>
<pre>public static final&nbsp;int COLORMAP_TWILIGHT_SHIFTED</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLORMAP_TWILIGHT_SHIFTED">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLORMAP_VIRIDIS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLORMAP_VIRIDIS</h4>
<pre>public static final&nbsp;int COLORMAP_VIRIDIS</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLORMAP_VIRIDIS">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COLORMAP_WINTER">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLORMAP_WINTER</h4>
<pre>public static final&nbsp;int COLORMAP_WINTER</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.COLORMAP_WINTER">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CONTOURS_MATCH_I1">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CONTOURS_MATCH_I1</h4>
<pre>public static final&nbsp;int CONTOURS_MATCH_I1</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CONTOURS_MATCH_I1">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CONTOURS_MATCH_I2">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CONTOURS_MATCH_I2</h4>
<pre>public static final&nbsp;int CONTOURS_MATCH_I2</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CONTOURS_MATCH_I2">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CONTOURS_MATCH_I3">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CONTOURS_MATCH_I3</h4>
<pre>public static final&nbsp;int CONTOURS_MATCH_I3</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CONTOURS_MATCH_I3">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_BILATERAL">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_BILATERAL</h4>
<pre>public static final&nbsp;int CV_BILATERAL</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_BILATERAL">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_BLUR">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_BLUR</h4>
<pre>public static final&nbsp;int CV_BLUR</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_BLUR">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_BLUR_NO_SCALE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_BLUR_NO_SCALE</h4>
<pre>public static final&nbsp;int CV_BLUR_NO_SCALE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_BLUR_NO_SCALE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_CANNY_L2_GRADIENT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_CANNY_L2_GRADIENT</h4>
<pre>public static final&nbsp;int CV_CANNY_L2_GRADIENT</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_CANNY_L2_GRADIENT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_CHAIN_CODE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_CHAIN_CODE</h4>
<pre>public static final&nbsp;int CV_CHAIN_CODE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_CHAIN_CODE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_CLOCKWISE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_CLOCKWISE</h4>
<pre>public static final&nbsp;int CV_CLOCKWISE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_CLOCKWISE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_COMP_BHATTACHARYYA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_COMP_BHATTACHARYYA</h4>
<pre>public static final&nbsp;int CV_COMP_BHATTACHARYYA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_COMP_BHATTACHARYYA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_COMP_CHISQR">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_COMP_CHISQR</h4>
<pre>public static final&nbsp;int CV_COMP_CHISQR</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_COMP_CHISQR">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_COMP_CHISQR_ALT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_COMP_CHISQR_ALT</h4>
<pre>public static final&nbsp;int CV_COMP_CHISQR_ALT</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_COMP_CHISQR_ALT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_COMP_CORREL">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_COMP_CORREL</h4>
<pre>public static final&nbsp;int CV_COMP_CORREL</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_COMP_CORREL">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_COMP_HELLINGER">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_COMP_HELLINGER</h4>
<pre>public static final&nbsp;int CV_COMP_HELLINGER</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_COMP_HELLINGER">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_COMP_INTERSECT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_COMP_INTERSECT</h4>
<pre>public static final&nbsp;int CV_COMP_INTERSECT</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_COMP_INTERSECT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_COMP_KL_DIV">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_COMP_KL_DIV</h4>
<pre>public static final&nbsp;int CV_COMP_KL_DIV</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_COMP_KL_DIV">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_CONTOURS_MATCH_I1">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_CONTOURS_MATCH_I1</h4>
<pre>public static final&nbsp;int CV_CONTOURS_MATCH_I1</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_CONTOURS_MATCH_I1">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_CONTOURS_MATCH_I2">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_CONTOURS_MATCH_I2</h4>
<pre>public static final&nbsp;int CV_CONTOURS_MATCH_I2</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_CONTOURS_MATCH_I2">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_CONTOURS_MATCH_I3">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_CONTOURS_MATCH_I3</h4>
<pre>public static final&nbsp;int CV_CONTOURS_MATCH_I3</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_CONTOURS_MATCH_I3">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_COUNTER_CLOCKWISE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_COUNTER_CLOCKWISE</h4>
<pre>public static final&nbsp;int CV_COUNTER_CLOCKWISE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_COUNTER_CLOCKWISE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_DIST_C">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_DIST_C</h4>
<pre>public static final&nbsp;int CV_DIST_C</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_DIST_C">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_DIST_FAIR">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_DIST_FAIR</h4>
<pre>public static final&nbsp;int CV_DIST_FAIR</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_DIST_FAIR">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_DIST_HUBER">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_DIST_HUBER</h4>
<pre>public static final&nbsp;int CV_DIST_HUBER</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_DIST_HUBER">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_DIST_L1">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_DIST_L1</h4>
<pre>public static final&nbsp;int CV_DIST_L1</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_DIST_L1">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_DIST_L12">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_DIST_L12</h4>
<pre>public static final&nbsp;int CV_DIST_L12</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_DIST_L12">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_DIST_L2">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_DIST_L2</h4>
<pre>public static final&nbsp;int CV_DIST_L2</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_DIST_L2">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_DIST_LABEL_CCOMP">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_DIST_LABEL_CCOMP</h4>
<pre>public static final&nbsp;int CV_DIST_LABEL_CCOMP</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_DIST_LABEL_CCOMP">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_DIST_LABEL_PIXEL">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_DIST_LABEL_PIXEL</h4>
<pre>public static final&nbsp;int CV_DIST_LABEL_PIXEL</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_DIST_LABEL_PIXEL">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_DIST_MASK_3">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_DIST_MASK_3</h4>
<pre>public static final&nbsp;int CV_DIST_MASK_3</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_DIST_MASK_3">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_DIST_MASK_5">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_DIST_MASK_5</h4>
<pre>public static final&nbsp;int CV_DIST_MASK_5</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_DIST_MASK_5">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_DIST_MASK_PRECISE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_DIST_MASK_PRECISE</h4>
<pre>public static final&nbsp;int CV_DIST_MASK_PRECISE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_DIST_MASK_PRECISE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_DIST_USER">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_DIST_USER</h4>
<pre>public static final&nbsp;int CV_DIST_USER</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_DIST_USER">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_DIST_WELSCH">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_DIST_WELSCH</h4>
<pre>public static final&nbsp;int CV_DIST_WELSCH</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_DIST_WELSCH">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_GAUSSIAN">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_GAUSSIAN</h4>
<pre>public static final&nbsp;int CV_GAUSSIAN</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_GAUSSIAN">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_GAUSSIAN_5x5">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_GAUSSIAN_5x5</h4>
<pre>public static final&nbsp;int CV_GAUSSIAN_5x5</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_GAUSSIAN_5x5">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_HOUGH_GRADIENT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_HOUGH_GRADIENT</h4>
<pre>public static final&nbsp;int CV_HOUGH_GRADIENT</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_HOUGH_GRADIENT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_HOUGH_MULTI_SCALE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_HOUGH_MULTI_SCALE</h4>
<pre>public static final&nbsp;int CV_HOUGH_MULTI_SCALE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_HOUGH_MULTI_SCALE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_HOUGH_PROBABILISTIC">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_HOUGH_PROBABILISTIC</h4>
<pre>public static final&nbsp;int CV_HOUGH_PROBABILISTIC</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_HOUGH_PROBABILISTIC">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_HOUGH_STANDARD">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_HOUGH_STANDARD</h4>
<pre>public static final&nbsp;int CV_HOUGH_STANDARD</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_HOUGH_STANDARD">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_LINK_RUNS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_LINK_RUNS</h4>
<pre>public static final&nbsp;int CV_LINK_RUNS</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_LINK_RUNS">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_MAX_SOBEL_KSIZE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_MAX_SOBEL_KSIZE</h4>
<pre>public static final&nbsp;int CV_MAX_SOBEL_KSIZE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_MAX_SOBEL_KSIZE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_MEDIAN">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_MEDIAN</h4>
<pre>public static final&nbsp;int CV_MEDIAN</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_MEDIAN">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_mRGBA2RGBA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_mRGBA2RGBA</h4>
<pre>public static final&nbsp;int CV_mRGBA2RGBA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_mRGBA2RGBA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_POLY_APPROX_DP">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_POLY_APPROX_DP</h4>
<pre>public static final&nbsp;int CV_POLY_APPROX_DP</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_POLY_APPROX_DP">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_RGBA2mRGBA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_RGBA2mRGBA</h4>
<pre>public static final&nbsp;int CV_RGBA2mRGBA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_RGBA2mRGBA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_SCHARR">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_SCHARR</h4>
<pre>public static final&nbsp;int CV_SCHARR</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_SCHARR">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_SHAPE_CROSS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_SHAPE_CROSS</h4>
<pre>public static final&nbsp;int CV_SHAPE_CROSS</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_SHAPE_CROSS">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_SHAPE_CUSTOM">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_SHAPE_CUSTOM</h4>
<pre>public static final&nbsp;int CV_SHAPE_CUSTOM</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_SHAPE_CUSTOM">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_SHAPE_ELLIPSE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_SHAPE_ELLIPSE</h4>
<pre>public static final&nbsp;int CV_SHAPE_ELLIPSE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_SHAPE_ELLIPSE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_SHAPE_RECT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_SHAPE_RECT</h4>
<pre>public static final&nbsp;int CV_SHAPE_RECT</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_SHAPE_RECT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_WARP_FILL_OUTLIERS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_WARP_FILL_OUTLIERS</h4>
<pre>public static final&nbsp;int CV_WARP_FILL_OUTLIERS</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_WARP_FILL_OUTLIERS">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CV_WARP_INVERSE_MAP">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CV_WARP_INVERSE_MAP</h4>
<pre>public static final&nbsp;int CV_WARP_INVERSE_MAP</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.CV_WARP_INVERSE_MAP">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="DIST_C">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DIST_C</h4>
<pre>public static final&nbsp;int DIST_C</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.DIST_C">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="DIST_FAIR">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DIST_FAIR</h4>
<pre>public static final&nbsp;int DIST_FAIR</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.DIST_FAIR">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="DIST_HUBER">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DIST_HUBER</h4>
<pre>public static final&nbsp;int DIST_HUBER</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.DIST_HUBER">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="DIST_L1">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DIST_L1</h4>
<pre>public static final&nbsp;int DIST_L1</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.DIST_L1">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="DIST_L12">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DIST_L12</h4>
<pre>public static final&nbsp;int DIST_L12</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.DIST_L12">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="DIST_L2">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DIST_L2</h4>
<pre>public static final&nbsp;int DIST_L2</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.DIST_L2">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="DIST_LABEL_CCOMP">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DIST_LABEL_CCOMP</h4>
<pre>public static final&nbsp;int DIST_LABEL_CCOMP</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.DIST_LABEL_CCOMP">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="DIST_LABEL_PIXEL">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DIST_LABEL_PIXEL</h4>
<pre>public static final&nbsp;int DIST_LABEL_PIXEL</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.DIST_LABEL_PIXEL">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="DIST_MASK_3">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DIST_MASK_3</h4>
<pre>public static final&nbsp;int DIST_MASK_3</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.DIST_MASK_3">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="DIST_MASK_5">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DIST_MASK_5</h4>
<pre>public static final&nbsp;int DIST_MASK_5</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.DIST_MASK_5">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="DIST_MASK_PRECISE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DIST_MASK_PRECISE</h4>
<pre>public static final&nbsp;int DIST_MASK_PRECISE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.DIST_MASK_PRECISE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="DIST_USER">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DIST_USER</h4>
<pre>public static final&nbsp;int DIST_USER</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.DIST_USER">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="DIST_WELSCH">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DIST_WELSCH</h4>
<pre>public static final&nbsp;int DIST_WELSCH</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.DIST_WELSCH">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="FILLED">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>FILLED</h4>
<pre>public static final&nbsp;int FILLED</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.FILLED">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="FILTER_SCHARR">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>FILTER_SCHARR</h4>
<pre>public static final&nbsp;int FILTER_SCHARR</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.FILTER_SCHARR">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="FLOODFILL_FIXED_RANGE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>FLOODFILL_FIXED_RANGE</h4>
<pre>public static final&nbsp;int FLOODFILL_FIXED_RANGE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.FLOODFILL_FIXED_RANGE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="FLOODFILL_MASK_ONLY">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>FLOODFILL_MASK_ONLY</h4>
<pre>public static final&nbsp;int FLOODFILL_MASK_ONLY</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.FLOODFILL_MASK_ONLY">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="FONT_HERSHEY_COMPLEX">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>FONT_HERSHEY_COMPLEX</h4>
<pre>public static final&nbsp;int FONT_HERSHEY_COMPLEX</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.FONT_HERSHEY_COMPLEX">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="FONT_HERSHEY_COMPLEX_SMALL">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>FONT_HERSHEY_COMPLEX_SMALL</h4>
<pre>public static final&nbsp;int FONT_HERSHEY_COMPLEX_SMALL</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.FONT_HERSHEY_COMPLEX_SMALL">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="FONT_HERSHEY_DUPLEX">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>FONT_HERSHEY_DUPLEX</h4>
<pre>public static final&nbsp;int FONT_HERSHEY_DUPLEX</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.FONT_HERSHEY_DUPLEX">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="FONT_HERSHEY_PLAIN">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>FONT_HERSHEY_PLAIN</h4>
<pre>public static final&nbsp;int FONT_HERSHEY_PLAIN</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.FONT_HERSHEY_PLAIN">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="FONT_HERSHEY_SCRIPT_COMPLEX">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>FONT_HERSHEY_SCRIPT_COMPLEX</h4>
<pre>public static final&nbsp;int FONT_HERSHEY_SCRIPT_COMPLEX</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.FONT_HERSHEY_SCRIPT_COMPLEX">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="FONT_HERSHEY_SCRIPT_SIMPLEX">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>FONT_HERSHEY_SCRIPT_SIMPLEX</h4>
<pre>public static final&nbsp;int FONT_HERSHEY_SCRIPT_SIMPLEX</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.FONT_HERSHEY_SCRIPT_SIMPLEX">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="FONT_HERSHEY_SIMPLEX">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>FONT_HERSHEY_SIMPLEX</h4>
<pre>public static final&nbsp;int FONT_HERSHEY_SIMPLEX</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.FONT_HERSHEY_SIMPLEX">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="FONT_HERSHEY_TRIPLEX">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>FONT_HERSHEY_TRIPLEX</h4>
<pre>public static final&nbsp;int FONT_HERSHEY_TRIPLEX</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.FONT_HERSHEY_TRIPLEX">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="FONT_ITALIC">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>FONT_ITALIC</h4>
<pre>public static final&nbsp;int FONT_ITALIC</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.FONT_ITALIC">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="GC_BGD">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>GC_BGD</h4>
<pre>public static final&nbsp;int GC_BGD</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.GC_BGD">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="GC_EVAL">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>GC_EVAL</h4>
<pre>public static final&nbsp;int GC_EVAL</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.GC_EVAL">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="GC_EVAL_FREEZE_MODEL">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>GC_EVAL_FREEZE_MODEL</h4>
<pre>public static final&nbsp;int GC_EVAL_FREEZE_MODEL</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.GC_EVAL_FREEZE_MODEL">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="GC_FGD">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>GC_FGD</h4>
<pre>public static final&nbsp;int GC_FGD</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.GC_FGD">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="GC_INIT_WITH_MASK">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>GC_INIT_WITH_MASK</h4>
<pre>public static final&nbsp;int GC_INIT_WITH_MASK</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.GC_INIT_WITH_MASK">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="GC_INIT_WITH_RECT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>GC_INIT_WITH_RECT</h4>
<pre>public static final&nbsp;int GC_INIT_WITH_RECT</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.GC_INIT_WITH_RECT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="GC_PR_BGD">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>GC_PR_BGD</h4>
<pre>public static final&nbsp;int GC_PR_BGD</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.GC_PR_BGD">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="GC_PR_FGD">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>GC_PR_FGD</h4>
<pre>public static final&nbsp;int GC_PR_FGD</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.GC_PR_FGD">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="HISTCMP_BHATTACHARYYA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>HISTCMP_BHATTACHARYYA</h4>
<pre>public static final&nbsp;int HISTCMP_BHATTACHARYYA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.HISTCMP_BHATTACHARYYA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="HISTCMP_CHISQR">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>HISTCMP_CHISQR</h4>
<pre>public static final&nbsp;int HISTCMP_CHISQR</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.HISTCMP_CHISQR">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="HISTCMP_CHISQR_ALT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>HISTCMP_CHISQR_ALT</h4>
<pre>public static final&nbsp;int HISTCMP_CHISQR_ALT</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.HISTCMP_CHISQR_ALT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="HISTCMP_CORREL">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>HISTCMP_CORREL</h4>
<pre>public static final&nbsp;int HISTCMP_CORREL</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.HISTCMP_CORREL">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="HISTCMP_HELLINGER">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>HISTCMP_HELLINGER</h4>
<pre>public static final&nbsp;int HISTCMP_HELLINGER</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.HISTCMP_HELLINGER">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="HISTCMP_INTERSECT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>HISTCMP_INTERSECT</h4>
<pre>public static final&nbsp;int HISTCMP_INTERSECT</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.HISTCMP_INTERSECT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="HISTCMP_KL_DIV">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>HISTCMP_KL_DIV</h4>
<pre>public static final&nbsp;int HISTCMP_KL_DIV</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.HISTCMP_KL_DIV">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="HOUGH_GRADIENT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>HOUGH_GRADIENT</h4>
<pre>public static final&nbsp;int HOUGH_GRADIENT</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.HOUGH_GRADIENT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="HOUGH_GRADIENT_ALT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>HOUGH_GRADIENT_ALT</h4>
<pre>public static final&nbsp;int HOUGH_GRADIENT_ALT</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.HOUGH_GRADIENT_ALT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="HOUGH_MULTI_SCALE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>HOUGH_MULTI_SCALE</h4>
<pre>public static final&nbsp;int HOUGH_MULTI_SCALE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.HOUGH_MULTI_SCALE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="HOUGH_PROBABILISTIC">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>HOUGH_PROBABILISTIC</h4>
<pre>public static final&nbsp;int HOUGH_PROBABILISTIC</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.HOUGH_PROBABILISTIC">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="HOUGH_STANDARD">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>HOUGH_STANDARD</h4>
<pre>public static final&nbsp;int HOUGH_STANDARD</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.HOUGH_STANDARD">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="INTER_AREA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>INTER_AREA</h4>
<pre>public static final&nbsp;int INTER_AREA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.INTER_AREA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="INTER_BITS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>INTER_BITS</h4>
<pre>public static final&nbsp;int INTER_BITS</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.INTER_BITS">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="INTER_BITS2">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>INTER_BITS2</h4>
<pre>public static final&nbsp;int INTER_BITS2</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.INTER_BITS2">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="INTER_CUBIC">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>INTER_CUBIC</h4>
<pre>public static final&nbsp;int INTER_CUBIC</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.INTER_CUBIC">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="INTER_LANCZOS4">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>INTER_LANCZOS4</h4>
<pre>public static final&nbsp;int INTER_LANCZOS4</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.INTER_LANCZOS4">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="INTER_LINEAR">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>INTER_LINEAR</h4>
<pre>public static final&nbsp;int INTER_LINEAR</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.INTER_LINEAR">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="INTER_LINEAR_EXACT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>INTER_LINEAR_EXACT</h4>
<pre>public static final&nbsp;int INTER_LINEAR_EXACT</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.INTER_LINEAR_EXACT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="INTER_MAX">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>INTER_MAX</h4>
<pre>public static final&nbsp;int INTER_MAX</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.INTER_MAX">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="INTER_NEAREST">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>INTER_NEAREST</h4>
<pre>public static final&nbsp;int INTER_NEAREST</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.INTER_NEAREST">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="INTER_NEAREST_EXACT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>INTER_NEAREST_EXACT</h4>
<pre>public static final&nbsp;int INTER_NEAREST_EXACT</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.INTER_NEAREST_EXACT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="INTER_TAB_SIZE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>INTER_TAB_SIZE</h4>
<pre>public static final&nbsp;int INTER_TAB_SIZE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.INTER_TAB_SIZE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="INTER_TAB_SIZE2">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>INTER_TAB_SIZE2</h4>
<pre>public static final&nbsp;int INTER_TAB_SIZE2</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.INTER_TAB_SIZE2">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="INTERSECT_FULL">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>INTERSECT_FULL</h4>
<pre>public static final&nbsp;int INTERSECT_FULL</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.INTERSECT_FULL">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="INTERSECT_NONE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>INTERSECT_NONE</h4>
<pre>public static final&nbsp;int INTERSECT_NONE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.INTERSECT_NONE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="INTERSECT_PARTIAL">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>INTERSECT_PARTIAL</h4>
<pre>public static final&nbsp;int INTERSECT_PARTIAL</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.INTERSECT_PARTIAL">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="LINE_4">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>LINE_4</h4>
<pre>public static final&nbsp;int LINE_4</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.LINE_4">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="LINE_8">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>LINE_8</h4>
<pre>public static final&nbsp;int LINE_8</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.LINE_8">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="LINE_AA">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>LINE_AA</h4>
<pre>public static final&nbsp;int LINE_AA</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.LINE_AA">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="LSD_REFINE_ADV">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>LSD_REFINE_ADV</h4>
<pre>public static final&nbsp;int LSD_REFINE_ADV</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.LSD_REFINE_ADV">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="LSD_REFINE_NONE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>LSD_REFINE_NONE</h4>
<pre>public static final&nbsp;int LSD_REFINE_NONE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.LSD_REFINE_NONE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="LSD_REFINE_STD">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>LSD_REFINE_STD</h4>
<pre>public static final&nbsp;int LSD_REFINE_STD</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.LSD_REFINE_STD">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="MARKER_CROSS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>MARKER_CROSS</h4>
<pre>public static final&nbsp;int MARKER_CROSS</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.MARKER_CROSS">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="MARKER_DIAMOND">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>MARKER_DIAMOND</h4>
<pre>public static final&nbsp;int MARKER_DIAMOND</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.MARKER_DIAMOND">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="MARKER_SQUARE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>MARKER_SQUARE</h4>
<pre>public static final&nbsp;int MARKER_SQUARE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.MARKER_SQUARE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="MARKER_STAR">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>MARKER_STAR</h4>
<pre>public static final&nbsp;int MARKER_STAR</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.MARKER_STAR">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="MARKER_TILTED_CROSS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>MARKER_TILTED_CROSS</h4>
<pre>public static final&nbsp;int MARKER_TILTED_CROSS</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.MARKER_TILTED_CROSS">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="MARKER_TRIANGLE_DOWN">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>MARKER_TRIANGLE_DOWN</h4>
<pre>public static final&nbsp;int MARKER_TRIANGLE_DOWN</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.MARKER_TRIANGLE_DOWN">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="MARKER_TRIANGLE_UP">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>MARKER_TRIANGLE_UP</h4>
<pre>public static final&nbsp;int MARKER_TRIANGLE_UP</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.MARKER_TRIANGLE_UP">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="MORPH_BLACKHAT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>MORPH_BLACKHAT</h4>
<pre>public static final&nbsp;int MORPH_BLACKHAT</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.MORPH_BLACKHAT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="MORPH_CLOSE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>MORPH_CLOSE</h4>
<pre>public static final&nbsp;int MORPH_CLOSE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.MORPH_CLOSE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="MORPH_CROSS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>MORPH_CROSS</h4>
<pre>public static final&nbsp;int MORPH_CROSS</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.MORPH_CROSS">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="MORPH_DILATE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>MORPH_DILATE</h4>
<pre>public static final&nbsp;int MORPH_DILATE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.MORPH_DILATE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="MORPH_ELLIPSE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>MORPH_ELLIPSE</h4>
<pre>public static final&nbsp;int MORPH_ELLIPSE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.MORPH_ELLIPSE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="MORPH_ERODE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>MORPH_ERODE</h4>
<pre>public static final&nbsp;int MORPH_ERODE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.MORPH_ERODE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="MORPH_GRADIENT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>MORPH_GRADIENT</h4>
<pre>public static final&nbsp;int MORPH_GRADIENT</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.MORPH_GRADIENT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="MORPH_HITMISS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>MORPH_HITMISS</h4>
<pre>public static final&nbsp;int MORPH_HITMISS</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.MORPH_HITMISS">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="MORPH_OPEN">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>MORPH_OPEN</h4>
<pre>public static final&nbsp;int MORPH_OPEN</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.MORPH_OPEN">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="MORPH_RECT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>MORPH_RECT</h4>
<pre>public static final&nbsp;int MORPH_RECT</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.MORPH_RECT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="MORPH_TOPHAT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>MORPH_TOPHAT</h4>
<pre>public static final&nbsp;int MORPH_TOPHAT</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.MORPH_TOPHAT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="RETR_CCOMP">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>RETR_CCOMP</h4>
<pre>public static final&nbsp;int RETR_CCOMP</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.RETR_CCOMP">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="RETR_EXTERNAL">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>RETR_EXTERNAL</h4>
<pre>public static final&nbsp;int RETR_EXTERNAL</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.RETR_EXTERNAL">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="RETR_FLOODFILL">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>RETR_FLOODFILL</h4>
<pre>public static final&nbsp;int RETR_FLOODFILL</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.RETR_FLOODFILL">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="RETR_LIST">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>RETR_LIST</h4>
<pre>public static final&nbsp;int RETR_LIST</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.RETR_LIST">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="RETR_TREE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>RETR_TREE</h4>
<pre>public static final&nbsp;int RETR_TREE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.RETR_TREE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="THRESH_BINARY">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>THRESH_BINARY</h4>
<pre>public static final&nbsp;int THRESH_BINARY</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.THRESH_BINARY">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="THRESH_BINARY_INV">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>THRESH_BINARY_INV</h4>
<pre>public static final&nbsp;int THRESH_BINARY_INV</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.THRESH_BINARY_INV">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="THRESH_MASK">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>THRESH_MASK</h4>
<pre>public static final&nbsp;int THRESH_MASK</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.THRESH_MASK">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="THRESH_OTSU">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>THRESH_OTSU</h4>
<pre>public static final&nbsp;int THRESH_OTSU</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.THRESH_OTSU">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="THRESH_TOZERO">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>THRESH_TOZERO</h4>
<pre>public static final&nbsp;int THRESH_TOZERO</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.THRESH_TOZERO">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="THRESH_TOZERO_INV">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>THRESH_TOZERO_INV</h4>
<pre>public static final&nbsp;int THRESH_TOZERO_INV</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.THRESH_TOZERO_INV">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="THRESH_TRIANGLE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>THRESH_TRIANGLE</h4>
<pre>public static final&nbsp;int THRESH_TRIANGLE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.THRESH_TRIANGLE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="THRESH_TRUNC">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>THRESH_TRUNC</h4>
<pre>public static final&nbsp;int THRESH_TRUNC</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.THRESH_TRUNC">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="TM_CCOEFF">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>TM_CCOEFF</h4>
<pre>public static final&nbsp;int TM_CCOEFF</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.TM_CCOEFF">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="TM_CCOEFF_NORMED">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>TM_CCOEFF_NORMED</h4>
<pre>public static final&nbsp;int TM_CCOEFF_NORMED</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.TM_CCOEFF_NORMED">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="TM_CCORR">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>TM_CCORR</h4>
<pre>public static final&nbsp;int TM_CCORR</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.TM_CCORR">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="TM_CCORR_NORMED">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>TM_CCORR_NORMED</h4>
<pre>public static final&nbsp;int TM_CCORR_NORMED</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.TM_CCORR_NORMED">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="TM_SQDIFF">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>TM_SQDIFF</h4>
<pre>public static final&nbsp;int TM_SQDIFF</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.TM_SQDIFF">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="TM_SQDIFF_NORMED">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>TM_SQDIFF_NORMED</h4>
<pre>public static final&nbsp;int TM_SQDIFF_NORMED</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.TM_SQDIFF_NORMED">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="WARP_FILL_OUTLIERS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>WARP_FILL_OUTLIERS</h4>
<pre>public static final&nbsp;int WARP_FILL_OUTLIERS</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.WARP_FILL_OUTLIERS">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="WARP_INVERSE_MAP">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>WARP_INVERSE_MAP</h4>
<pre>public static final&nbsp;int WARP_INVERSE_MAP</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.WARP_INVERSE_MAP">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="WARP_POLAR_LINEAR">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>WARP_POLAR_LINEAR</h4>
<pre>public static final&nbsp;int WARP_POLAR_LINEAR</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.WARP_POLAR_LINEAR">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="WARP_POLAR_LOG">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>WARP_POLAR_LOG</h4>
<pre>public static final&nbsp;int WARP_POLAR_LOG</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.imgproc.Imgproc.WARP_POLAR_LOG">Constant Field Values</a></dd>
</dl>
</li>
</ul>
</li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="Imgproc--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>Imgproc</h4>
<pre>public&nbsp;Imgproc()</pre>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="accumulate-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>accumulate</h4>
<pre>public static&nbsp;void&nbsp;accumulate(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block">Adds an image to the accumulator image.

 The function adds src or some of its elements to dst :

 \(\texttt{dst} (x,y)  \leftarrow \texttt{dst} (x,y) +  \texttt{src} (x,y)  \quad \text{if} \quad \texttt{mask} (x,y)  \ne 0\)

 The function supports multi-channel images. Each channel is processed independently.

 The function cv::accumulate can be used, for example, to collect statistics of a scene background
 viewed by a still camera and for the further foreground-background segmentation.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Input image of type CV_8UC(n), CV_16UC(n), CV_32FC(n) or CV_64FC(n), where n is a positive integer.</dd>
<dd><code>dst</code> - %Accumulator image with the same number of channels as input image, and a depth of CV_32F or CV_64F.

 SEE:  accumulateSquare, accumulateProduct, accumulateWeighted</dd>
</dl>
</li>
</ul>
<a name="accumulate-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>accumulate</h4>
<pre>public static&nbsp;void&nbsp;accumulate(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
<div class="block">Adds an image to the accumulator image.

 The function adds src or some of its elements to dst :

 \(\texttt{dst} (x,y)  \leftarrow \texttt{dst} (x,y) +  \texttt{src} (x,y)  \quad \text{if} \quad \texttt{mask} (x,y)  \ne 0\)

 The function supports multi-channel images. Each channel is processed independently.

 The function cv::accumulate can be used, for example, to collect statistics of a scene background
 viewed by a still camera and for the further foreground-background segmentation.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Input image of type CV_8UC(n), CV_16UC(n), CV_32FC(n) or CV_64FC(n), where n is a positive integer.</dd>
<dd><code>dst</code> - %Accumulator image with the same number of channels as input image, and a depth of CV_32F or CV_64F.</dd>
<dd><code>mask</code> - Optional operation mask.

 SEE:  accumulateSquare, accumulateProduct, accumulateWeighted</dd>
</dl>
</li>
</ul>
<a name="accumulateProduct-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>accumulateProduct</h4>
<pre>public static&nbsp;void&nbsp;accumulateProduct(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block">Adds the per-element product of two input images to the accumulator image.

 The function adds the product of two images or their selected regions to the accumulator dst :

 \(\texttt{dst} (x,y)  \leftarrow \texttt{dst} (x,y) +  \texttt{src1} (x,y)  \cdot \texttt{src2} (x,y)  \quad \text{if} \quad \texttt{mask} (x,y)  \ne 0\)

 The function supports multi-channel images. Each channel is processed independently.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - First input image, 1- or 3-channel, 8-bit or 32-bit floating point.</dd>
<dd><code>src2</code> - Second input image of the same type and the same size as src1 .</dd>
<dd><code>dst</code> - %Accumulator image with the same number of channels as input images, 32-bit or 64-bit
 floating-point.

 SEE:  accumulate, accumulateSquare, accumulateWeighted</dd>
</dl>
</li>
</ul>
<a name="accumulateProduct-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>accumulateProduct</h4>
<pre>public static&nbsp;void&nbsp;accumulateProduct(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
<div class="block">Adds the per-element product of two input images to the accumulator image.

 The function adds the product of two images or their selected regions to the accumulator dst :

 \(\texttt{dst} (x,y)  \leftarrow \texttt{dst} (x,y) +  \texttt{src1} (x,y)  \cdot \texttt{src2} (x,y)  \quad \text{if} \quad \texttt{mask} (x,y)  \ne 0\)

 The function supports multi-channel images. Each channel is processed independently.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - First input image, 1- or 3-channel, 8-bit or 32-bit floating point.</dd>
<dd><code>src2</code> - Second input image of the same type and the same size as src1 .</dd>
<dd><code>dst</code> - %Accumulator image with the same number of channels as input images, 32-bit or 64-bit
 floating-point.</dd>
<dd><code>mask</code> - Optional operation mask.

 SEE:  accumulate, accumulateSquare, accumulateWeighted</dd>
</dl>
</li>
</ul>
<a name="accumulateSquare-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>accumulateSquare</h4>
<pre>public static&nbsp;void&nbsp;accumulateSquare(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block">Adds the square of a source image to the accumulator image.

 The function adds the input image src or its selected region, raised to a power of 2, to the
 accumulator dst :

 \(\texttt{dst} (x,y)  \leftarrow \texttt{dst} (x,y) +  \texttt{src} (x,y)^2  \quad \text{if} \quad \texttt{mask} (x,y)  \ne 0\)

 The function supports multi-channel images. Each channel is processed independently.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Input image as 1- or 3-channel, 8-bit or 32-bit floating point.</dd>
<dd><code>dst</code> - %Accumulator image with the same number of channels as input image, 32-bit or 64-bit
 floating-point.

 SEE:  accumulateSquare, accumulateProduct, accumulateWeighted</dd>
</dl>
</li>
</ul>
<a name="accumulateSquare-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>accumulateSquare</h4>
<pre>public static&nbsp;void&nbsp;accumulateSquare(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
<div class="block">Adds the square of a source image to the accumulator image.

 The function adds the input image src or its selected region, raised to a power of 2, to the
 accumulator dst :

 \(\texttt{dst} (x,y)  \leftarrow \texttt{dst} (x,y) +  \texttt{src} (x,y)^2  \quad \text{if} \quad \texttt{mask} (x,y)  \ne 0\)

 The function supports multi-channel images. Each channel is processed independently.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Input image as 1- or 3-channel, 8-bit or 32-bit floating point.</dd>
<dd><code>dst</code> - %Accumulator image with the same number of channels as input image, 32-bit or 64-bit
 floating-point.</dd>
<dd><code>mask</code> - Optional operation mask.

 SEE:  accumulateSquare, accumulateProduct, accumulateWeighted</dd>
</dl>
</li>
</ul>
<a name="accumulateWeighted-org.opencv.core.Mat-org.opencv.core.Mat-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>accumulateWeighted</h4>
<pre>public static&nbsp;void&nbsp;accumulateWeighted(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                      double&nbsp;alpha)</pre>
<div class="block">Updates a running average.

 The function calculates the weighted sum of the input image src and the accumulator dst so that dst
 becomes a running average of a frame sequence:

 \(\texttt{dst} (x,y)  \leftarrow (1- \texttt{alpha} )  \cdot \texttt{dst} (x,y) +  \texttt{alpha} \cdot \texttt{src} (x,y)  \quad \text{if} \quad \texttt{mask} (x,y)  \ne 0\)

 That is, alpha regulates the update speed (how fast the accumulator "forgets" about earlier images).
 The function supports multi-channel images. Each channel is processed independently.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Input image as 1- or 3-channel, 8-bit or 32-bit floating point.</dd>
<dd><code>dst</code> - %Accumulator image with the same number of channels as input image, 32-bit or 64-bit
 floating-point.</dd>
<dd><code>alpha</code> - Weight of the input image.

 SEE:  accumulate, accumulateSquare, accumulateProduct</dd>
</dl>
</li>
</ul>
<a name="accumulateWeighted-org.opencv.core.Mat-org.opencv.core.Mat-double-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>accumulateWeighted</h4>
<pre>public static&nbsp;void&nbsp;accumulateWeighted(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                      double&nbsp;alpha,
                                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
<div class="block">Updates a running average.

 The function calculates the weighted sum of the input image src and the accumulator dst so that dst
 becomes a running average of a frame sequence:

 \(\texttt{dst} (x,y)  \leftarrow (1- \texttt{alpha} )  \cdot \texttt{dst} (x,y) +  \texttt{alpha} \cdot \texttt{src} (x,y)  \quad \text{if} \quad \texttt{mask} (x,y)  \ne 0\)

 That is, alpha regulates the update speed (how fast the accumulator "forgets" about earlier images).
 The function supports multi-channel images. Each channel is processed independently.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Input image as 1- or 3-channel, 8-bit or 32-bit floating point.</dd>
<dd><code>dst</code> - %Accumulator image with the same number of channels as input image, 32-bit or 64-bit
 floating-point.</dd>
<dd><code>alpha</code> - Weight of the input image.</dd>
<dd><code>mask</code> - Optional operation mask.

 SEE:  accumulate, accumulateSquare, accumulateProduct</dd>
</dl>
</li>
</ul>
<a name="adaptiveThreshold-org.opencv.core.Mat-org.opencv.core.Mat-double-int-int-int-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>adaptiveThreshold</h4>
<pre>public static&nbsp;void&nbsp;adaptiveThreshold(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                     double&nbsp;maxValue,
                                     int&nbsp;adaptiveMethod,
                                     int&nbsp;thresholdType,
                                     int&nbsp;blockSize,
                                     double&nbsp;C)</pre>
<div class="block">Applies an adaptive threshold to an array.

 The function transforms a grayscale image to a binary image according to the formulae:
 <ul>
   <li>
    <b>THRESH_BINARY</b>
     \(dst(x,y) =  \fork{\texttt{maxValue}}{if \(src(x,y) &gt; T(x,y)\)}{0}{otherwise}\)
   </li>
   <li>
    <b>THRESH_BINARY_INV</b>
     \(dst(x,y) =  \fork{0}{if \(src(x,y) &gt; T(x,y)\)}{\texttt{maxValue}}{otherwise}\)
 where \(T(x,y)\) is a threshold calculated individually for each pixel (see adaptiveMethod parameter).
   </li>
 </ul>

 The function can process the image in-place.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Source 8-bit single-channel image.</dd>
<dd><code>dst</code> - Destination image of the same size and the same type as src.</dd>
<dd><code>maxValue</code> - Non-zero value assigned to the pixels for which the condition is satisfied</dd>
<dd><code>adaptiveMethod</code> - Adaptive thresholding algorithm to use, see #AdaptiveThresholdTypes.
 The #BORDER_REPLICATE | #BORDER_ISOLATED is used to process boundaries.</dd>
<dd><code>thresholdType</code> - Thresholding type that must be either #THRESH_BINARY or #THRESH_BINARY_INV,
 see #ThresholdTypes.</dd>
<dd><code>blockSize</code> - Size of a pixel neighborhood that is used to calculate a threshold value for the
 pixel: 3, 5, 7, and so on.</dd>
<dd><code>C</code> - Constant subtracted from the mean or weighted mean (see the details below). Normally, it
 is positive but may be zero or negative as well.

 SEE:  threshold, blur, GaussianBlur</dd>
</dl>
</li>
</ul>
<a name="applyColorMap-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>applyColorMap</h4>
<pre>public static&nbsp;void&nbsp;applyColorMap(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                 int&nbsp;colormap)</pre>
<div class="block">Applies a GNU Octave/MATLAB equivalent colormap on a given image.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - The source image, grayscale or colored of type CV_8UC1 or CV_8UC3.</dd>
<dd><code>dst</code> - The result is the colormapped source image. Note: Mat::create is called on dst.</dd>
<dd><code>colormap</code> - The colormap to apply, see #ColormapTypes</dd>
</dl>
</li>
</ul>
<a name="applyColorMap-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>applyColorMap</h4>
<pre>public static&nbsp;void&nbsp;applyColorMap(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;userColor)</pre>
<div class="block">Applies a user colormap on a given image.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - The source image, grayscale or colored of type CV_8UC1 or CV_8UC3.</dd>
<dd><code>dst</code> - The result is the colormapped source image. Note: Mat::create is called on dst.</dd>
<dd><code>userColor</code> - The colormap to apply of type CV_8UC1 or CV_8UC3 and size 256</dd>
</dl>
</li>
</ul>
<a name="approxPolyDP-org.opencv.core.MatOfPoint2f-org.opencv.core.MatOfPoint2f-double-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>approxPolyDP</h4>
<pre>public static&nbsp;void&nbsp;approxPolyDP(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;curve,
                                <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;approxCurve,
                                double&nbsp;epsilon,
                                boolean&nbsp;closed)</pre>
<div class="block">Approximates a polygonal curve(s) with the specified precision.

 The function cv::approxPolyDP approximates a curve or a polygon with another curve/polygon with less
 vertices so that the distance between them is less or equal to the specified precision. It uses the
 Douglas-Peucker algorithm &lt;http://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm&gt;</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>curve</code> - Input vector of a 2D point stored in std::vector or Mat</dd>
<dd><code>approxCurve</code> - Result of the approximation. The type should match the type of the input curve.</dd>
<dd><code>epsilon</code> - Parameter specifying the approximation accuracy. This is the maximum distance
 between the original curve and its approximation.</dd>
<dd><code>closed</code> - If true, the approximated curve is closed (its first and last vertices are
 connected). Otherwise, it is not closed.</dd>
</dl>
</li>
</ul>
<a name="arcLength-org.opencv.core.MatOfPoint2f-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>arcLength</h4>
<pre>public static&nbsp;double&nbsp;arcLength(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;curve,
                               boolean&nbsp;closed)</pre>
<div class="block">Calculates a contour perimeter or a curve length.

 The function computes a curve length or a closed contour perimeter.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>curve</code> - Input vector of 2D points, stored in std::vector or Mat.</dd>
<dd><code>closed</code> - Flag indicating whether the curve is closed or not.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="arrowedLine-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Point-org.opencv.core.Scalar-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>arrowedLine</h4>
<pre>public static&nbsp;void&nbsp;arrowedLine(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                               <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt1,
                               <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt2,
                               <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color)</pre>
<div class="block">Draws an arrow segment pointing from the first point to the second one.

 The function cv::arrowedLine draws an arrow between pt1 and pt2 points in the image. See also #line.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - Image.</dd>
<dd><code>pt1</code> - The point the arrow starts from.</dd>
<dd><code>pt2</code> - The point the arrow points to.</dd>
<dd><code>color</code> - Line color.</dd>
</dl>
</li>
</ul>
<a name="arrowedLine-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Point-org.opencv.core.Scalar-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>arrowedLine</h4>
<pre>public static&nbsp;void&nbsp;arrowedLine(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                               <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt1,
                               <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt2,
                               <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
                               int&nbsp;thickness)</pre>
<div class="block">Draws an arrow segment pointing from the first point to the second one.

 The function cv::arrowedLine draws an arrow between pt1 and pt2 points in the image. See also #line.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - Image.</dd>
<dd><code>pt1</code> - The point the arrow starts from.</dd>
<dd><code>pt2</code> - The point the arrow points to.</dd>
<dd><code>color</code> - Line color.</dd>
<dd><code>thickness</code> - Line thickness.</dd>
</dl>
</li>
</ul>
<a name="arrowedLine-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Point-org.opencv.core.Scalar-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>arrowedLine</h4>
<pre>public static&nbsp;void&nbsp;arrowedLine(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                               <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt1,
                               <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt2,
                               <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
                               int&nbsp;thickness,
                               int&nbsp;line_type)</pre>
<div class="block">Draws an arrow segment pointing from the first point to the second one.

 The function cv::arrowedLine draws an arrow between pt1 and pt2 points in the image. See also #line.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - Image.</dd>
<dd><code>pt1</code> - The point the arrow starts from.</dd>
<dd><code>pt2</code> - The point the arrow points to.</dd>
<dd><code>color</code> - Line color.</dd>
<dd><code>thickness</code> - Line thickness.</dd>
<dd><code>line_type</code> - Type of the line. See #LineTypes</dd>
</dl>
</li>
</ul>
<a name="arrowedLine-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Point-org.opencv.core.Scalar-int-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>arrowedLine</h4>
<pre>public static&nbsp;void&nbsp;arrowedLine(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                               <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt1,
                               <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt2,
                               <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
                               int&nbsp;thickness,
                               int&nbsp;line_type,
                               int&nbsp;shift)</pre>
<div class="block">Draws an arrow segment pointing from the first point to the second one.

 The function cv::arrowedLine draws an arrow between pt1 and pt2 points in the image. See also #line.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - Image.</dd>
<dd><code>pt1</code> - The point the arrow starts from.</dd>
<dd><code>pt2</code> - The point the arrow points to.</dd>
<dd><code>color</code> - Line color.</dd>
<dd><code>thickness</code> - Line thickness.</dd>
<dd><code>line_type</code> - Type of the line. See #LineTypes</dd>
<dd><code>shift</code> - Number of fractional bits in the point coordinates.</dd>
</dl>
</li>
</ul>
<a name="arrowedLine-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Point-org.opencv.core.Scalar-int-int-int-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>arrowedLine</h4>
<pre>public static&nbsp;void&nbsp;arrowedLine(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                               <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt1,
                               <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt2,
                               <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
                               int&nbsp;thickness,
                               int&nbsp;line_type,
                               int&nbsp;shift,
                               double&nbsp;tipLength)</pre>
<div class="block">Draws an arrow segment pointing from the first point to the second one.

 The function cv::arrowedLine draws an arrow between pt1 and pt2 points in the image. See also #line.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - Image.</dd>
<dd><code>pt1</code> - The point the arrow starts from.</dd>
<dd><code>pt2</code> - The point the arrow points to.</dd>
<dd><code>color</code> - Line color.</dd>
<dd><code>thickness</code> - Line thickness.</dd>
<dd><code>line_type</code> - Type of the line. See #LineTypes</dd>
<dd><code>shift</code> - Number of fractional bits in the point coordinates.</dd>
<dd><code>tipLength</code> - The length of the arrow tip in relation to the arrow length</dd>
</dl>
</li>
</ul>
<a name="bilateralFilter-org.opencv.core.Mat-org.opencv.core.Mat-int-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bilateralFilter</h4>
<pre>public static&nbsp;void&nbsp;bilateralFilter(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                   int&nbsp;d,
                                   double&nbsp;sigmaColor,
                                   double&nbsp;sigmaSpace)</pre>
<div class="block">Applies the bilateral filter to an image.

 The function applies bilateral filtering to the input image, as described in
 http://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html
 bilateralFilter can reduce unwanted noise very well while keeping edges fairly sharp. However, it is
 very slow compared to most filters.

 _Sigma values_: For simplicity, you can set the 2 sigma values to be the same. If they are small (&lt;
 10), the filter will not have much effect, whereas if they are large (&gt; 150), they will have a very
 strong effect, making the image look "cartoonish".

 _Filter size_: Large filters (d &gt; 5) are very slow, so it is recommended to use d=5 for real-time
 applications, and perhaps d=9 for offline applications that need heavy noise filtering.

 This filter does not work inplace.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Source 8-bit or floating-point, 1-channel or 3-channel image.</dd>
<dd><code>dst</code> - Destination image of the same size and type as src .</dd>
<dd><code>d</code> - Diameter of each pixel neighborhood that is used during filtering. If it is non-positive,
 it is computed from sigmaSpace.</dd>
<dd><code>sigmaColor</code> - Filter sigma in the color space. A larger value of the parameter means that
 farther colors within the pixel neighborhood (see sigmaSpace) will be mixed together, resulting
 in larger areas of semi-equal color.</dd>
<dd><code>sigmaSpace</code> - Filter sigma in the coordinate space. A larger value of the parameter means that
 farther pixels will influence each other as long as their colors are close enough (see sigmaColor
 ). When d&gt;0, it specifies the neighborhood size regardless of sigmaSpace. Otherwise, d is
 proportional to sigmaSpace.</dd>
</dl>
</li>
</ul>
<a name="bilateralFilter-org.opencv.core.Mat-org.opencv.core.Mat-int-double-double-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bilateralFilter</h4>
<pre>public static&nbsp;void&nbsp;bilateralFilter(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                   int&nbsp;d,
                                   double&nbsp;sigmaColor,
                                   double&nbsp;sigmaSpace,
                                   int&nbsp;borderType)</pre>
<div class="block">Applies the bilateral filter to an image.

 The function applies bilateral filtering to the input image, as described in
 http://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html
 bilateralFilter can reduce unwanted noise very well while keeping edges fairly sharp. However, it is
 very slow compared to most filters.

 _Sigma values_: For simplicity, you can set the 2 sigma values to be the same. If they are small (&lt;
 10), the filter will not have much effect, whereas if they are large (&gt; 150), they will have a very
 strong effect, making the image look "cartoonish".

 _Filter size_: Large filters (d &gt; 5) are very slow, so it is recommended to use d=5 for real-time
 applications, and perhaps d=9 for offline applications that need heavy noise filtering.

 This filter does not work inplace.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Source 8-bit or floating-point, 1-channel or 3-channel image.</dd>
<dd><code>dst</code> - Destination image of the same size and type as src .</dd>
<dd><code>d</code> - Diameter of each pixel neighborhood that is used during filtering. If it is non-positive,
 it is computed from sigmaSpace.</dd>
<dd><code>sigmaColor</code> - Filter sigma in the color space. A larger value of the parameter means that
 farther colors within the pixel neighborhood (see sigmaSpace) will be mixed together, resulting
 in larger areas of semi-equal color.</dd>
<dd><code>sigmaSpace</code> - Filter sigma in the coordinate space. A larger value of the parameter means that
 farther pixels will influence each other as long as their colors are close enough (see sigmaColor
 ). When d&gt;0, it specifies the neighborhood size regardless of sigmaSpace. Otherwise, d is
 proportional to sigmaSpace.</dd>
<dd><code>borderType</code> - border mode used to extrapolate pixels outside of the image, see #BorderTypes</dd>
</dl>
</li>
</ul>
<a name="blendLinear-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>blendLinear</h4>
<pre>public static&nbsp;void&nbsp;blendLinear(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;weights1,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;weights2,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block">variant without <code>mask</code> parameter</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - automatically generated</dd>
<dd><code>src2</code> - automatically generated</dd>
<dd><code>weights1</code> - automatically generated</dd>
<dd><code>weights2</code> - automatically generated</dd>
<dd><code>dst</code> - automatically generated</dd>
</dl>
</li>
</ul>
<a name="blur-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>blur</h4>
<pre>public static&nbsp;void&nbsp;blur(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize)</pre>
<div class="block">Blurs an image using the normalized box filter.

 The function smooths an image using the kernel:

 \(\texttt{K} =  \frac{1}{\texttt{ksize.width*ksize.height}} \begin{bmatrix} 1 &amp; 1 &amp; 1 &amp;  \cdots &amp; 1 &amp; 1  \\ 1 &amp; 1 &amp; 1 &amp;  \cdots &amp; 1 &amp; 1  \\ \hdotsfor{6} \\ 1 &amp; 1 &amp; 1 &amp;  \cdots &amp; 1 &amp; 1  \\ \end{bmatrix}\)

 The call <code>blur(src, dst, ksize, anchor, borderType)</code> is equivalent to `boxFilter(src, dst, src.type(), ksize,
 anchor, true, borderType)`.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image; it can have any number of channels, which are processed independently, but
 the depth should be CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.</dd>
<dd><code>dst</code> - output image of the same size and type as src.</dd>
<dd><code>ksize</code> - blurring kernel size.
 center.
 SEE:  boxFilter, bilateralFilter, GaussianBlur, medianBlur</dd>
</dl>
</li>
</ul>
<a name="blur-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-org.opencv.core.Point-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>blur</h4>
<pre>public static&nbsp;void&nbsp;blur(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
                        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor)</pre>
<div class="block">Blurs an image using the normalized box filter.

 The function smooths an image using the kernel:

 \(\texttt{K} =  \frac{1}{\texttt{ksize.width*ksize.height}} \begin{bmatrix} 1 &amp; 1 &amp; 1 &amp;  \cdots &amp; 1 &amp; 1  \\ 1 &amp; 1 &amp; 1 &amp;  \cdots &amp; 1 &amp; 1  \\ \hdotsfor{6} \\ 1 &amp; 1 &amp; 1 &amp;  \cdots &amp; 1 &amp; 1  \\ \end{bmatrix}\)

 The call <code>blur(src, dst, ksize, anchor, borderType)</code> is equivalent to `boxFilter(src, dst, src.type(), ksize,
 anchor, true, borderType)`.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image; it can have any number of channels, which are processed independently, but
 the depth should be CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.</dd>
<dd><code>dst</code> - output image of the same size and type as src.</dd>
<dd><code>ksize</code> - blurring kernel size.</dd>
<dd><code>anchor</code> - anchor point; default value Point(-1,-1) means that the anchor is at the kernel
 center.
 SEE:  boxFilter, bilateralFilter, GaussianBlur, medianBlur</dd>
</dl>
</li>
</ul>
<a name="blur-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-org.opencv.core.Point-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>blur</h4>
<pre>public static&nbsp;void&nbsp;blur(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
                        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
                        int&nbsp;borderType)</pre>
<div class="block">Blurs an image using the normalized box filter.

 The function smooths an image using the kernel:

 \(\texttt{K} =  \frac{1}{\texttt{ksize.width*ksize.height}} \begin{bmatrix} 1 &amp; 1 &amp; 1 &amp;  \cdots &amp; 1 &amp; 1  \\ 1 &amp; 1 &amp; 1 &amp;  \cdots &amp; 1 &amp; 1  \\ \hdotsfor{6} \\ 1 &amp; 1 &amp; 1 &amp;  \cdots &amp; 1 &amp; 1  \\ \end{bmatrix}\)

 The call <code>blur(src, dst, ksize, anchor, borderType)</code> is equivalent to `boxFilter(src, dst, src.type(), ksize,
 anchor, true, borderType)`.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image; it can have any number of channels, which are processed independently, but
 the depth should be CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.</dd>
<dd><code>dst</code> - output image of the same size and type as src.</dd>
<dd><code>ksize</code> - blurring kernel size.</dd>
<dd><code>anchor</code> - anchor point; default value Point(-1,-1) means that the anchor is at the kernel
 center.</dd>
<dd><code>borderType</code> - border mode used to extrapolate pixels outside of the image, see #BorderTypes. #BORDER_WRAP is not supported.
 SEE:  boxFilter, bilateralFilter, GaussianBlur, medianBlur</dd>
</dl>
</li>
</ul>
<a name="boundingRect-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>boundingRect</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;boundingRect(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;array)</pre>
<div class="block">Calculates the up-right bounding rectangle of a point set or non-zero pixels of gray-scale image.

 The function calculates and returns the minimal up-right bounding rectangle for the specified point set or
 non-zero pixels of gray-scale image.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>array</code> - Input gray-scale image or 2D point set, stored in std::vector or Mat.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="boxFilter-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Size-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>boxFilter</h4>
<pre>public static&nbsp;void&nbsp;boxFilter(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                             int&nbsp;ddepth,
                             <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize)</pre>
<div class="block">Blurs an image using the box filter.

 The function smooths an image using the kernel:

 \(\texttt{K} =  \alpha \begin{bmatrix} 1 &amp; 1 &amp; 1 &amp;  \cdots &amp; 1 &amp; 1  \\ 1 &amp; 1 &amp; 1 &amp;  \cdots &amp; 1 &amp; 1  \\ \hdotsfor{6} \\ 1 &amp; 1 &amp; 1 &amp;  \cdots &amp; 1 &amp; 1 \end{bmatrix}\)

 where

 \(\alpha = \begin{cases} \frac{1}{\texttt{ksize.width*ksize.height}} &amp; \texttt{when } \texttt{normalize=true}  \\1 &amp; \texttt{otherwise}\end{cases}\)

 Unnormalized box filter is useful for computing various integral characteristics over each pixel
 neighborhood, such as covariance matrices of image derivatives (used in dense optical flow
 algorithms, and so on). If you need to compute pixel sums over variable-size windows, use #integral.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image.</dd>
<dd><code>dst</code> - output image of the same size and type as src.</dd>
<dd><code>ddepth</code> - the output image depth (-1 to use src.depth()).</dd>
<dd><code>ksize</code> - blurring kernel size.
 center.
 SEE:  blur, bilateralFilter, GaussianBlur, medianBlur, integral</dd>
</dl>
</li>
</ul>
<a name="boxFilter-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Size-org.opencv.core.Point-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>boxFilter</h4>
<pre>public static&nbsp;void&nbsp;boxFilter(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                             int&nbsp;ddepth,
                             <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
                             <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor)</pre>
<div class="block">Blurs an image using the box filter.

 The function smooths an image using the kernel:

 \(\texttt{K} =  \alpha \begin{bmatrix} 1 &amp; 1 &amp; 1 &amp;  \cdots &amp; 1 &amp; 1  \\ 1 &amp; 1 &amp; 1 &amp;  \cdots &amp; 1 &amp; 1  \\ \hdotsfor{6} \\ 1 &amp; 1 &amp; 1 &amp;  \cdots &amp; 1 &amp; 1 \end{bmatrix}\)

 where

 \(\alpha = \begin{cases} \frac{1}{\texttt{ksize.width*ksize.height}} &amp; \texttt{when } \texttt{normalize=true}  \\1 &amp; \texttt{otherwise}\end{cases}\)

 Unnormalized box filter is useful for computing various integral characteristics over each pixel
 neighborhood, such as covariance matrices of image derivatives (used in dense optical flow
 algorithms, and so on). If you need to compute pixel sums over variable-size windows, use #integral.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image.</dd>
<dd><code>dst</code> - output image of the same size and type as src.</dd>
<dd><code>ddepth</code> - the output image depth (-1 to use src.depth()).</dd>
<dd><code>ksize</code> - blurring kernel size.</dd>
<dd><code>anchor</code> - anchor point; default value Point(-1,-1) means that the anchor is at the kernel
 center.
 SEE:  blur, bilateralFilter, GaussianBlur, medianBlur, integral</dd>
</dl>
</li>
</ul>
<a name="boxFilter-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Size-org.opencv.core.Point-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>boxFilter</h4>
<pre>public static&nbsp;void&nbsp;boxFilter(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                             int&nbsp;ddepth,
                             <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
                             <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
                             boolean&nbsp;normalize)</pre>
<div class="block">Blurs an image using the box filter.

 The function smooths an image using the kernel:

 \(\texttt{K} =  \alpha \begin{bmatrix} 1 &amp; 1 &amp; 1 &amp;  \cdots &amp; 1 &amp; 1  \\ 1 &amp; 1 &amp; 1 &amp;  \cdots &amp; 1 &amp; 1  \\ \hdotsfor{6} \\ 1 &amp; 1 &amp; 1 &amp;  \cdots &amp; 1 &amp; 1 \end{bmatrix}\)

 where

 \(\alpha = \begin{cases} \frac{1}{\texttt{ksize.width*ksize.height}} &amp; \texttt{when } \texttt{normalize=true}  \\1 &amp; \texttt{otherwise}\end{cases}\)

 Unnormalized box filter is useful for computing various integral characteristics over each pixel
 neighborhood, such as covariance matrices of image derivatives (used in dense optical flow
 algorithms, and so on). If you need to compute pixel sums over variable-size windows, use #integral.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image.</dd>
<dd><code>dst</code> - output image of the same size and type as src.</dd>
<dd><code>ddepth</code> - the output image depth (-1 to use src.depth()).</dd>
<dd><code>ksize</code> - blurring kernel size.</dd>
<dd><code>anchor</code> - anchor point; default value Point(-1,-1) means that the anchor is at the kernel
 center.</dd>
<dd><code>normalize</code> - flag, specifying whether the kernel is normalized by its area or not.
 SEE:  blur, bilateralFilter, GaussianBlur, medianBlur, integral</dd>
</dl>
</li>
</ul>
<a name="boxFilter-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Size-org.opencv.core.Point-boolean-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>boxFilter</h4>
<pre>public static&nbsp;void&nbsp;boxFilter(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                             int&nbsp;ddepth,
                             <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
                             <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
                             boolean&nbsp;normalize,
                             int&nbsp;borderType)</pre>
<div class="block">Blurs an image using the box filter.

 The function smooths an image using the kernel:

 \(\texttt{K} =  \alpha \begin{bmatrix} 1 &amp; 1 &amp; 1 &amp;  \cdots &amp; 1 &amp; 1  \\ 1 &amp; 1 &amp; 1 &amp;  \cdots &amp; 1 &amp; 1  \\ \hdotsfor{6} \\ 1 &amp; 1 &amp; 1 &amp;  \cdots &amp; 1 &amp; 1 \end{bmatrix}\)

 where

 \(\alpha = \begin{cases} \frac{1}{\texttt{ksize.width*ksize.height}} &amp; \texttt{when } \texttt{normalize=true}  \\1 &amp; \texttt{otherwise}\end{cases}\)

 Unnormalized box filter is useful for computing various integral characteristics over each pixel
 neighborhood, such as covariance matrices of image derivatives (used in dense optical flow
 algorithms, and so on). If you need to compute pixel sums over variable-size windows, use #integral.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image.</dd>
<dd><code>dst</code> - output image of the same size and type as src.</dd>
<dd><code>ddepth</code> - the output image depth (-1 to use src.depth()).</dd>
<dd><code>ksize</code> - blurring kernel size.</dd>
<dd><code>anchor</code> - anchor point; default value Point(-1,-1) means that the anchor is at the kernel
 center.</dd>
<dd><code>normalize</code> - flag, specifying whether the kernel is normalized by its area or not.</dd>
<dd><code>borderType</code> - border mode used to extrapolate pixels outside of the image, see #BorderTypes. #BORDER_WRAP is not supported.
 SEE:  blur, bilateralFilter, GaussianBlur, medianBlur, integral</dd>
</dl>
</li>
</ul>
<a name="boxPoints-org.opencv.core.RotatedRect-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>boxPoints</h4>
<pre>public static&nbsp;void&nbsp;boxPoints(<a href="../../../org/opencv/core/RotatedRect.html" title="class in org.opencv.core">RotatedRect</a>&nbsp;box,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points)</pre>
<div class="block">Finds the four vertices of a rotated rect. Useful to draw the rotated rectangle.

 The function finds the four vertices of a rotated rectangle. This function is useful to draw the
 rectangle. In C++, instead of using this function, you can directly use RotatedRect::points method. Please
 visit the REF: tutorial_bounding_rotated_ellipses "tutorial on Creating Bounding rotated boxes and ellipses for contours" for more information.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>box</code> - The input rotated rectangle. It may be the output of REF: minAreaRect.</dd>
<dd><code>points</code> - The output array of four vertices of rectangles.</dd>
</dl>
</li>
</ul>
<a name="calcBackProject-java.util.List-org.opencv.core.MatOfInt-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.MatOfFloat-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>calcBackProject</h4>
<pre>public static&nbsp;void&nbsp;calcBackProject(java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;images,
                                   <a href="../../../org/opencv/core/MatOfInt.html" title="class in org.opencv.core">MatOfInt</a>&nbsp;channels,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;hist,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                   <a href="../../../org/opencv/core/MatOfFloat.html" title="class in org.opencv.core">MatOfFloat</a>&nbsp;ranges,
                                   double&nbsp;scale)</pre>
</li>
</ul>
<a name="calcHist-java.util.List-org.opencv.core.MatOfInt-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.MatOfInt-org.opencv.core.MatOfFloat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>calcHist</h4>
<pre>public static&nbsp;void&nbsp;calcHist(java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;images,
                            <a href="../../../org/opencv/core/MatOfInt.html" title="class in org.opencv.core">MatOfInt</a>&nbsp;channels,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;hist,
                            <a href="../../../org/opencv/core/MatOfInt.html" title="class in org.opencv.core">MatOfInt</a>&nbsp;histSize,
                            <a href="../../../org/opencv/core/MatOfFloat.html" title="class in org.opencv.core">MatOfFloat</a>&nbsp;ranges)</pre>
<div class="block">this variant supports only uniform histograms.

 ranges argument is either empty vector or a flattened vector of histSize.size()*2 elements
 (histSize.size() element pairs). The first and second elements of each pair specify the lower and
 upper boundaries.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>images</code> - automatically generated</dd>
<dd><code>channels</code> - automatically generated</dd>
<dd><code>mask</code> - automatically generated</dd>
<dd><code>hist</code> - automatically generated</dd>
<dd><code>histSize</code> - automatically generated</dd>
<dd><code>ranges</code> - automatically generated</dd>
</dl>
</li>
</ul>
<a name="calcHist-java.util.List-org.opencv.core.MatOfInt-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.MatOfInt-org.opencv.core.MatOfFloat-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>calcHist</h4>
<pre>public static&nbsp;void&nbsp;calcHist(java.util.List&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;images,
                            <a href="../../../org/opencv/core/MatOfInt.html" title="class in org.opencv.core">MatOfInt</a>&nbsp;channels,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;hist,
                            <a href="../../../org/opencv/core/MatOfInt.html" title="class in org.opencv.core">MatOfInt</a>&nbsp;histSize,
                            <a href="../../../org/opencv/core/MatOfFloat.html" title="class in org.opencv.core">MatOfFloat</a>&nbsp;ranges,
                            boolean&nbsp;accumulate)</pre>
<div class="block">this variant supports only uniform histograms.

 ranges argument is either empty vector or a flattened vector of histSize.size()*2 elements
 (histSize.size() element pairs). The first and second elements of each pair specify the lower and
 upper boundaries.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>images</code> - automatically generated</dd>
<dd><code>channels</code> - automatically generated</dd>
<dd><code>mask</code> - automatically generated</dd>
<dd><code>hist</code> - automatically generated</dd>
<dd><code>histSize</code> - automatically generated</dd>
<dd><code>ranges</code> - automatically generated</dd>
<dd><code>accumulate</code> - automatically generated</dd>
</dl>
</li>
</ul>
<a name="Canny-org.opencv.core.Mat-org.opencv.core.Mat-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Canny</h4>
<pre>public static&nbsp;void&nbsp;Canny(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;edges,
                         double&nbsp;threshold1,
                         double&nbsp;threshold2)</pre>
<div class="block">Finds edges in an image using the Canny algorithm CITE: Canny86 .

 The function finds edges in the input image and marks them in the output map edges using the
 Canny algorithm. The smallest value between threshold1 and threshold2 is used for edge linking. The
 largest value is used to find initial segments of strong edges. See
 &lt;http://en.wikipedia.org/wiki/Canny_edge_detector&gt;</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - 8-bit input image.</dd>
<dd><code>edges</code> - output edge map; single channels 8-bit image, which has the same size as image .</dd>
<dd><code>threshold1</code> - first threshold for the hysteresis procedure.</dd>
<dd><code>threshold2</code> - second threshold for the hysteresis procedure.
 \(=\sqrt{(dI/dx)^2 + (dI/dy)^2}\) should be used to calculate the image gradient magnitude (
 L2gradient=true ), or whether the default \(L_1\) norm \(=|dI/dx|+|dI/dy|\) is enough (
 L2gradient=false ).</dd>
</dl>
</li>
</ul>
<a name="Canny-org.opencv.core.Mat-org.opencv.core.Mat-double-double-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Canny</h4>
<pre>public static&nbsp;void&nbsp;Canny(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;edges,
                         double&nbsp;threshold1,
                         double&nbsp;threshold2,
                         int&nbsp;apertureSize)</pre>
<div class="block">Finds edges in an image using the Canny algorithm CITE: Canny86 .

 The function finds edges in the input image and marks them in the output map edges using the
 Canny algorithm. The smallest value between threshold1 and threshold2 is used for edge linking. The
 largest value is used to find initial segments of strong edges. See
 &lt;http://en.wikipedia.org/wiki/Canny_edge_detector&gt;</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - 8-bit input image.</dd>
<dd><code>edges</code> - output edge map; single channels 8-bit image, which has the same size as image .</dd>
<dd><code>threshold1</code> - first threshold for the hysteresis procedure.</dd>
<dd><code>threshold2</code> - second threshold for the hysteresis procedure.</dd>
<dd><code>apertureSize</code> - aperture size for the Sobel operator.
 \(=\sqrt{(dI/dx)^2 + (dI/dy)^2}\) should be used to calculate the image gradient magnitude (
 L2gradient=true ), or whether the default \(L_1\) norm \(=|dI/dx|+|dI/dy|\) is enough (
 L2gradient=false ).</dd>
</dl>
</li>
</ul>
<a name="Canny-org.opencv.core.Mat-org.opencv.core.Mat-double-double-int-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Canny</h4>
<pre>public static&nbsp;void&nbsp;Canny(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;edges,
                         double&nbsp;threshold1,
                         double&nbsp;threshold2,
                         int&nbsp;apertureSize,
                         boolean&nbsp;L2gradient)</pre>
<div class="block">Finds edges in an image using the Canny algorithm CITE: Canny86 .

 The function finds edges in the input image and marks them in the output map edges using the
 Canny algorithm. The smallest value between threshold1 and threshold2 is used for edge linking. The
 largest value is used to find initial segments of strong edges. See
 &lt;http://en.wikipedia.org/wiki/Canny_edge_detector&gt;</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - 8-bit input image.</dd>
<dd><code>edges</code> - output edge map; single channels 8-bit image, which has the same size as image .</dd>
<dd><code>threshold1</code> - first threshold for the hysteresis procedure.</dd>
<dd><code>threshold2</code> - second threshold for the hysteresis procedure.</dd>
<dd><code>apertureSize</code> - aperture size for the Sobel operator.</dd>
<dd><code>L2gradient</code> - a flag, indicating whether a more accurate \(L_2\) norm
 \(=\sqrt{(dI/dx)^2 + (dI/dy)^2}\) should be used to calculate the image gradient magnitude (
 L2gradient=true ), or whether the default \(L_1\) norm \(=|dI/dx|+|dI/dy|\) is enough (
 L2gradient=false ).</dd>
</dl>
</li>
</ul>
<a name="Canny-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Canny</h4>
<pre>public static&nbsp;void&nbsp;Canny(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dx,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dy,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;edges,
                         double&nbsp;threshold1,
                         double&nbsp;threshold2)</pre>
<div class="block">\overload

 Finds edges in an image using the Canny algorithm with custom image gradient.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>dx</code> - 16-bit x derivative of input image (CV_16SC1 or CV_16SC3).</dd>
<dd><code>dy</code> - 16-bit y derivative of input image (same type as dx).</dd>
<dd><code>edges</code> - output edge map; single channels 8-bit image, which has the same size as image .</dd>
<dd><code>threshold1</code> - first threshold for the hysteresis procedure.</dd>
<dd><code>threshold2</code> - second threshold for the hysteresis procedure.
 \(=\sqrt{(dI/dx)^2 + (dI/dy)^2}\) should be used to calculate the image gradient magnitude (
 L2gradient=true ), or whether the default \(L_1\) norm \(=|dI/dx|+|dI/dy|\) is enough (
 L2gradient=false ).</dd>
</dl>
</li>
</ul>
<a name="Canny-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-double-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Canny</h4>
<pre>public static&nbsp;void&nbsp;Canny(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dx,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dy,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;edges,
                         double&nbsp;threshold1,
                         double&nbsp;threshold2,
                         boolean&nbsp;L2gradient)</pre>
<div class="block">\overload

 Finds edges in an image using the Canny algorithm with custom image gradient.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>dx</code> - 16-bit x derivative of input image (CV_16SC1 or CV_16SC3).</dd>
<dd><code>dy</code> - 16-bit y derivative of input image (same type as dx).</dd>
<dd><code>edges</code> - output edge map; single channels 8-bit image, which has the same size as image .</dd>
<dd><code>threshold1</code> - first threshold for the hysteresis procedure.</dd>
<dd><code>threshold2</code> - second threshold for the hysteresis procedure.</dd>
<dd><code>L2gradient</code> - a flag, indicating whether a more accurate \(L_2\) norm
 \(=\sqrt{(dI/dx)^2 + (dI/dy)^2}\) should be used to calculate the image gradient magnitude (
 L2gradient=true ), or whether the default \(L_1\) norm \(=|dI/dx|+|dI/dy|\) is enough (
 L2gradient=false ).</dd>
</dl>
</li>
</ul>
<a name="circle-org.opencv.core.Mat-org.opencv.core.Point-int-org.opencv.core.Scalar-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>circle</h4>
<pre>public static&nbsp;void&nbsp;circle(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                          <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
                          int&nbsp;radius,
                          <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color)</pre>
<div class="block">Draws a circle.

 The function cv::circle draws a simple or filled circle with a given center and radius.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - Image where the circle is drawn.</dd>
<dd><code>center</code> - Center of the circle.</dd>
<dd><code>radius</code> - Radius of the circle.</dd>
<dd><code>color</code> - Circle color.
 mean that a filled circle is to be drawn.</dd>
</dl>
</li>
</ul>
<a name="circle-org.opencv.core.Mat-org.opencv.core.Point-int-org.opencv.core.Scalar-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>circle</h4>
<pre>public static&nbsp;void&nbsp;circle(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                          <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
                          int&nbsp;radius,
                          <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
                          int&nbsp;thickness)</pre>
<div class="block">Draws a circle.

 The function cv::circle draws a simple or filled circle with a given center and radius.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - Image where the circle is drawn.</dd>
<dd><code>center</code> - Center of the circle.</dd>
<dd><code>radius</code> - Radius of the circle.</dd>
<dd><code>color</code> - Circle color.</dd>
<dd><code>thickness</code> - Thickness of the circle outline, if positive. Negative values, like #FILLED,
 mean that a filled circle is to be drawn.</dd>
</dl>
</li>
</ul>
<a name="circle-org.opencv.core.Mat-org.opencv.core.Point-int-org.opencv.core.Scalar-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>circle</h4>
<pre>public static&nbsp;void&nbsp;circle(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                          <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
                          int&nbsp;radius,
                          <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
                          int&nbsp;thickness,
                          int&nbsp;lineType)</pre>
<div class="block">Draws a circle.

 The function cv::circle draws a simple or filled circle with a given center and radius.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - Image where the circle is drawn.</dd>
<dd><code>center</code> - Center of the circle.</dd>
<dd><code>radius</code> - Radius of the circle.</dd>
<dd><code>color</code> - Circle color.</dd>
<dd><code>thickness</code> - Thickness of the circle outline, if positive. Negative values, like #FILLED,
 mean that a filled circle is to be drawn.</dd>
<dd><code>lineType</code> - Type of the circle boundary. See #LineTypes</dd>
</dl>
</li>
</ul>
<a name="circle-org.opencv.core.Mat-org.opencv.core.Point-int-org.opencv.core.Scalar-int-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>circle</h4>
<pre>public static&nbsp;void&nbsp;circle(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                          <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
                          int&nbsp;radius,
                          <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
                          int&nbsp;thickness,
                          int&nbsp;lineType,
                          int&nbsp;shift)</pre>
<div class="block">Draws a circle.

 The function cv::circle draws a simple or filled circle with a given center and radius.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - Image where the circle is drawn.</dd>
<dd><code>center</code> - Center of the circle.</dd>
<dd><code>radius</code> - Radius of the circle.</dd>
<dd><code>color</code> - Circle color.</dd>
<dd><code>thickness</code> - Thickness of the circle outline, if positive. Negative values, like #FILLED,
 mean that a filled circle is to be drawn.</dd>
<dd><code>lineType</code> - Type of the circle boundary. See #LineTypes</dd>
<dd><code>shift</code> - Number of fractional bits in the coordinates of the center and in the radius value.</dd>
</dl>
</li>
</ul>
<a name="clipLine-org.opencv.core.Rect-org.opencv.core.Point-org.opencv.core.Point-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clipLine</h4>
<pre>public static&nbsp;boolean&nbsp;clipLine(<a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;imgRect,
                               <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt1,
                               <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt2)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>imgRect</code> - Image rectangle.</dd>
<dd><code>pt1</code> - First line point.</dd>
<dd><code>pt2</code> - Second line point.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="compareHist-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>compareHist</h4>
<pre>public static&nbsp;double&nbsp;compareHist(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;H1,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;H2,
                                 int&nbsp;method)</pre>
<div class="block">Compares two histograms.

 The function cv::compareHist compares two dense or two sparse histograms using the specified method.

 The function returns \(d(H_1, H_2)\) .

 While the function works well with 1-, 2-, 3-dimensional dense histograms, it may not be suitable
 for high-dimensional sparse histograms. In such histograms, because of aliasing and sampling
 problems, the coordinates of non-zero histogram bins can slightly shift. To compare such histograms
 or more general sparse configurations of weighted points, consider using the #EMD function.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>H1</code> - First compared histogram.</dd>
<dd><code>H2</code> - Second compared histogram of the same size as H1 .</dd>
<dd><code>method</code> - Comparison method, see #HistCompMethods</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="connectedComponents-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>connectedComponents</h4>
<pre>public static&nbsp;int&nbsp;connectedComponents(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;labels)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - the 8-bit single-channel image to be labeled</dd>
<dd><code>labels</code> - destination labeled image</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="connectedComponents-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>connectedComponents</h4>
<pre>public static&nbsp;int&nbsp;connectedComponents(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;labels,
                                      int&nbsp;connectivity)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - the 8-bit single-channel image to be labeled</dd>
<dd><code>labels</code> - destination labeled image</dd>
<dd><code>connectivity</code> - 8 or 4 for 8-way or 4-way connectivity respectively</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="connectedComponents-org.opencv.core.Mat-org.opencv.core.Mat-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>connectedComponents</h4>
<pre>public static&nbsp;int&nbsp;connectedComponents(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;labels,
                                      int&nbsp;connectivity,
                                      int&nbsp;ltype)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - the 8-bit single-channel image to be labeled</dd>
<dd><code>labels</code> - destination labeled image</dd>
<dd><code>connectivity</code> - 8 or 4 for 8-way or 4-way connectivity respectively</dd>
<dd><code>ltype</code> - output image label type. Currently CV_32S and CV_16U are supported.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="connectedComponentsWithAlgorithm-org.opencv.core.Mat-org.opencv.core.Mat-int-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>connectedComponentsWithAlgorithm</h4>
<pre>public static&nbsp;int&nbsp;connectedComponentsWithAlgorithm(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;labels,
                                                   int&nbsp;connectivity,
                                                   int&nbsp;ltype,
                                                   int&nbsp;ccltype)</pre>
<div class="block">computes the connected components labeled image of boolean image

 image with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0
 represents the background label. ltype specifies the output label image type, an important
 consideration based on the total number of labels or alternatively the total number of pixels in
 the source image. ccltype specifies the connected components labeling algorithm to use, currently
 Bolelli (Spaghetti) CITE: Bolelli2019, Grana (BBDT) CITE: Grana2010 and Wu's (SAUF) CITE: Wu2009 algorithms
 are supported, see the #ConnectedComponentsAlgorithmsTypes for details. Note that SAUF algorithm forces
 a row major ordering of labels while Spaghetti and BBDT do not.
 This function uses parallel version of the algorithms if at least one allowed
 parallel framework is enabled and if the rows of the image are at least twice the number returned by #getNumberOfCPUs.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - the 8-bit single-channel image to be labeled</dd>
<dd><code>labels</code> - destination labeled image</dd>
<dd><code>connectivity</code> - 8 or 4 for 8-way or 4-way connectivity respectively</dd>
<dd><code>ltype</code> - output image label type. Currently CV_32S and CV_16U are supported.</dd>
<dd><code>ccltype</code> - connected components algorithm type (see the #ConnectedComponentsAlgorithmsTypes).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="connectedComponentsWithStats-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>connectedComponentsWithStats</h4>
<pre>public static&nbsp;int&nbsp;connectedComponentsWithStats(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;labels,
                                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;stats,
                                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;centroids)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - the 8-bit single-channel image to be labeled</dd>
<dd><code>labels</code> - destination labeled image</dd>
<dd><code>stats</code> - statistics output for each label, including the background label.
 Statistics are accessed via stats(label, COLUMN) where COLUMN is one of
 #ConnectedComponentsTypes, selecting the statistic. The data type is CV_32S.</dd>
<dd><code>centroids</code> - centroid output for each label, including the background label. Centroids are
 accessed via centroids(label, 0) for x and centroids(label, 1) for y. The data type CV_64F.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="connectedComponentsWithStats-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>connectedComponentsWithStats</h4>
<pre>public static&nbsp;int&nbsp;connectedComponentsWithStats(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;labels,
                                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;stats,
                                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;centroids,
                                               int&nbsp;connectivity)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - the 8-bit single-channel image to be labeled</dd>
<dd><code>labels</code> - destination labeled image</dd>
<dd><code>stats</code> - statistics output for each label, including the background label.
 Statistics are accessed via stats(label, COLUMN) where COLUMN is one of
 #ConnectedComponentsTypes, selecting the statistic. The data type is CV_32S.</dd>
<dd><code>centroids</code> - centroid output for each label, including the background label. Centroids are
 accessed via centroids(label, 0) for x and centroids(label, 1) for y. The data type CV_64F.</dd>
<dd><code>connectivity</code> - 8 or 4 for 8-way or 4-way connectivity respectively</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="connectedComponentsWithStats-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>connectedComponentsWithStats</h4>
<pre>public static&nbsp;int&nbsp;connectedComponentsWithStats(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;labels,
                                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;stats,
                                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;centroids,
                                               int&nbsp;connectivity,
                                               int&nbsp;ltype)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - the 8-bit single-channel image to be labeled</dd>
<dd><code>labels</code> - destination labeled image</dd>
<dd><code>stats</code> - statistics output for each label, including the background label.
 Statistics are accessed via stats(label, COLUMN) where COLUMN is one of
 #ConnectedComponentsTypes, selecting the statistic. The data type is CV_32S.</dd>
<dd><code>centroids</code> - centroid output for each label, including the background label. Centroids are
 accessed via centroids(label, 0) for x and centroids(label, 1) for y. The data type CV_64F.</dd>
<dd><code>connectivity</code> - 8 or 4 for 8-way or 4-way connectivity respectively</dd>
<dd><code>ltype</code> - output image label type. Currently CV_32S and CV_16U are supported.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="connectedComponentsWithStatsWithAlgorithm-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>connectedComponentsWithStatsWithAlgorithm</h4>
<pre>public static&nbsp;int&nbsp;connectedComponentsWithStatsWithAlgorithm(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;labels,
                                                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;stats,
                                                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;centroids,
                                                            int&nbsp;connectivity,
                                                            int&nbsp;ltype,
                                                            int&nbsp;ccltype)</pre>
<div class="block">computes the connected components labeled image of boolean image and also produces a statistics output for each label

 image with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0
 represents the background label. ltype specifies the output label image type, an important
 consideration based on the total number of labels or alternatively the total number of pixels in
 the source image. ccltype specifies the connected components labeling algorithm to use, currently
 Bolelli (Spaghetti) CITE: Bolelli2019, Grana (BBDT) CITE: Grana2010 and Wu's (SAUF) CITE: Wu2009 algorithms
 are supported, see the #ConnectedComponentsAlgorithmsTypes for details. Note that SAUF algorithm forces
 a row major ordering of labels while Spaghetti and BBDT do not.
 This function uses parallel version of the algorithms (statistics included) if at least one allowed
 parallel framework is enabled and if the rows of the image are at least twice the number returned by #getNumberOfCPUs.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - the 8-bit single-channel image to be labeled</dd>
<dd><code>labels</code> - destination labeled image</dd>
<dd><code>stats</code> - statistics output for each label, including the background label.
 Statistics are accessed via stats(label, COLUMN) where COLUMN is one of
 #ConnectedComponentsTypes, selecting the statistic. The data type is CV_32S.</dd>
<dd><code>centroids</code> - centroid output for each label, including the background label. Centroids are
 accessed via centroids(label, 0) for x and centroids(label, 1) for y. The data type CV_64F.</dd>
<dd><code>connectivity</code> - 8 or 4 for 8-way or 4-way connectivity respectively</dd>
<dd><code>ltype</code> - output image label type. Currently CV_32S and CV_16U are supported.</dd>
<dd><code>ccltype</code> - connected components algorithm type (see #ConnectedComponentsAlgorithmsTypes).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="contourArea-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>contourArea</h4>
<pre>public static&nbsp;double&nbsp;contourArea(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;contour)</pre>
<div class="block">Calculates a contour area.

 The function computes a contour area. Similarly to moments , the area is computed using the Green
 formula. Thus, the returned area and the number of non-zero pixels, if you draw the contour using
 #drawContours or #fillPoly , can be different. Also, the function will most certainly give a wrong
 results for contours with self-intersections.

 Example:
 <code>
     vector&lt;Point&gt; contour;
     contour.push_back(Point2f(0, 0));
     contour.push_back(Point2f(10, 0));
     contour.push_back(Point2f(10, 10));
     contour.push_back(Point2f(5, 4));

     double area0 = contourArea(contour);
     vector&lt;Point&gt; approx;
     approxPolyDP(contour, approx, 5, true);
     double area1 = contourArea(approx);

     cout &lt;&lt; "area0 =" &lt;&lt; area0 &lt;&lt; endl &lt;&lt;
             "area1 =" &lt;&lt; area1 &lt;&lt; endl &lt;&lt;
             "approx poly vertices" &lt;&lt; approx.size() &lt;&lt; endl;
 </code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>contour</code> - Input vector of 2D points (contour vertices), stored in std::vector or Mat.
 depending on the contour orientation (clockwise or counter-clockwise). Using this feature you can
 determine orientation of a contour by taking the sign of an area. By default, the parameter is
 false, which means that the absolute value is returned.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="contourArea-org.opencv.core.Mat-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>contourArea</h4>
<pre>public static&nbsp;double&nbsp;contourArea(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;contour,
                                 boolean&nbsp;oriented)</pre>
<div class="block">Calculates a contour area.

 The function computes a contour area. Similarly to moments , the area is computed using the Green
 formula. Thus, the returned area and the number of non-zero pixels, if you draw the contour using
 #drawContours or #fillPoly , can be different. Also, the function will most certainly give a wrong
 results for contours with self-intersections.

 Example:
 <code>
     vector&lt;Point&gt; contour;
     contour.push_back(Point2f(0, 0));
     contour.push_back(Point2f(10, 0));
     contour.push_back(Point2f(10, 10));
     contour.push_back(Point2f(5, 4));

     double area0 = contourArea(contour);
     vector&lt;Point&gt; approx;
     approxPolyDP(contour, approx, 5, true);
     double area1 = contourArea(approx);

     cout &lt;&lt; "area0 =" &lt;&lt; area0 &lt;&lt; endl &lt;&lt;
             "area1 =" &lt;&lt; area1 &lt;&lt; endl &lt;&lt;
             "approx poly vertices" &lt;&lt; approx.size() &lt;&lt; endl;
 </code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>contour</code> - Input vector of 2D points (contour vertices), stored in std::vector or Mat.</dd>
<dd><code>oriented</code> - Oriented area flag. If it is true, the function returns a signed area value,
 depending on the contour orientation (clockwise or counter-clockwise). Using this feature you can
 determine orientation of a contour by taking the sign of an area. By default, the parameter is
 false, which means that the absolute value is returned.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="convertMaps-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>convertMaps</h4>
<pre>public static&nbsp;void&nbsp;convertMaps(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map1,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map2,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dstmap1,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dstmap2,
                               int&nbsp;dstmap1type)</pre>
<div class="block">Converts image transformation maps from one representation to another.

 The function converts a pair of maps for remap from one representation to another. The following
 options ( (map1.type(), map2.type()) \(\rightarrow\) (dstmap1.type(), dstmap2.type()) ) are
 supported:

 <ul>
   <li>
  \(\texttt{(CV_32FC1, CV_32FC1)} \rightarrow \texttt{(CV_16SC2, CV_16UC1)}\). This is the
 most frequently used conversion operation, in which the original floating-point maps (see #remap)
 are converted to a more compact and much faster fixed-point representation. The first output array
 contains the rounded coordinates and the second array (created only when nninterpolation=false )
 contains indices in the interpolation tables.
   </li>
 </ul>

 <ul>
   <li>
  \(\texttt{(CV_32FC2)} \rightarrow \texttt{(CV_16SC2, CV_16UC1)}\). The same as above but
 the original maps are stored in one 2-channel matrix.
   </li>
 </ul>

 <ul>
   <li>
  Reverse conversion. Obviously, the reconstructed floating-point maps will not be exactly the same
 as the originals.
   </li>
 </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>map1</code> - The first input map of type CV_16SC2, CV_32FC1, or CV_32FC2 .</dd>
<dd><code>map2</code> - The second input map of type CV_16UC1, CV_32FC1, or none (empty matrix),
 respectively.</dd>
<dd><code>dstmap1</code> - The first output map that has the type dstmap1type and the same size as src .</dd>
<dd><code>dstmap2</code> - The second output map.</dd>
<dd><code>dstmap1type</code> - Type of the first output map that should be CV_16SC2, CV_32FC1, or
 CV_32FC2 .
 nearest-neighbor or for a more complex interpolation.

 SEE:  remap, undistort, initUndistortRectifyMap</dd>
</dl>
</li>
</ul>
<a name="convertMaps-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>convertMaps</h4>
<pre>public static&nbsp;void&nbsp;convertMaps(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map1,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map2,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dstmap1,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dstmap2,
                               int&nbsp;dstmap1type,
                               boolean&nbsp;nninterpolation)</pre>
<div class="block">Converts image transformation maps from one representation to another.

 The function converts a pair of maps for remap from one representation to another. The following
 options ( (map1.type(), map2.type()) \(\rightarrow\) (dstmap1.type(), dstmap2.type()) ) are
 supported:

 <ul>
   <li>
  \(\texttt{(CV_32FC1, CV_32FC1)} \rightarrow \texttt{(CV_16SC2, CV_16UC1)}\). This is the
 most frequently used conversion operation, in which the original floating-point maps (see #remap)
 are converted to a more compact and much faster fixed-point representation. The first output array
 contains the rounded coordinates and the second array (created only when nninterpolation=false )
 contains indices in the interpolation tables.
   </li>
 </ul>

 <ul>
   <li>
  \(\texttt{(CV_32FC2)} \rightarrow \texttt{(CV_16SC2, CV_16UC1)}\). The same as above but
 the original maps are stored in one 2-channel matrix.
   </li>
 </ul>

 <ul>
   <li>
  Reverse conversion. Obviously, the reconstructed floating-point maps will not be exactly the same
 as the originals.
   </li>
 </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>map1</code> - The first input map of type CV_16SC2, CV_32FC1, or CV_32FC2 .</dd>
<dd><code>map2</code> - The second input map of type CV_16UC1, CV_32FC1, or none (empty matrix),
 respectively.</dd>
<dd><code>dstmap1</code> - The first output map that has the type dstmap1type and the same size as src .</dd>
<dd><code>dstmap2</code> - The second output map.</dd>
<dd><code>dstmap1type</code> - Type of the first output map that should be CV_16SC2, CV_32FC1, or
 CV_32FC2 .</dd>
<dd><code>nninterpolation</code> - Flag indicating whether the fixed-point maps are used for the
 nearest-neighbor or for a more complex interpolation.

 SEE:  remap, undistort, initUndistortRectifyMap</dd>
</dl>
</li>
</ul>
<a name="convexHull-org.opencv.core.MatOfPoint-org.opencv.core.MatOfInt-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>convexHull</h4>
<pre>public static&nbsp;void&nbsp;convexHull(<a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&nbsp;points,
                              <a href="../../../org/opencv/core/MatOfInt.html" title="class in org.opencv.core">MatOfInt</a>&nbsp;hull)</pre>
<div class="block">Finds the convex hull of a point set.

 The function cv::convexHull finds the convex hull of a 2D point set using the Sklansky's algorithm CITE: Sklansky82
 that has *O(N logN)* complexity in the current implementation.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points</code> - Input 2D point set, stored in std::vector or Mat.</dd>
<dd><code>hull</code> - Output convex hull. It is either an integer vector of indices or vector of points. In
 the first case, the hull elements are 0-based indices of the convex hull points in the original
 array (since the set of convex hull points is a subset of the original point set). In the second
 case, hull elements are the convex hull points themselves.
 Otherwise, it is oriented counter-clockwise. The assumed coordinate system has its X axis pointing
 to the right, and its Y axis pointing upwards.
 returns convex hull points. Otherwise, it returns indices of the convex hull points. When the
 output array is std::vector, the flag is ignored, and the output depends on the type of the
 vector: std::vector&lt;int&gt; implies returnPoints=false, std::vector&lt;Point&gt; implies
 returnPoints=true.

 <b>Note:</b> <code>points</code> and <code>hull</code> should be different arrays, inplace processing isn't supported.

 Check REF: tutorial_hull "the corresponding tutorial" for more details.

 useful links:

 https://www.learnopencv.com/convex-hull-using-opencv-in-python-and-c/</dd>
</dl>
</li>
</ul>
<a name="convexHull-org.opencv.core.MatOfPoint-org.opencv.core.MatOfInt-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>convexHull</h4>
<pre>public static&nbsp;void&nbsp;convexHull(<a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&nbsp;points,
                              <a href="../../../org/opencv/core/MatOfInt.html" title="class in org.opencv.core">MatOfInt</a>&nbsp;hull,
                              boolean&nbsp;clockwise)</pre>
<div class="block">Finds the convex hull of a point set.

 The function cv::convexHull finds the convex hull of a 2D point set using the Sklansky's algorithm CITE: Sklansky82
 that has *O(N logN)* complexity in the current implementation.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points</code> - Input 2D point set, stored in std::vector or Mat.</dd>
<dd><code>hull</code> - Output convex hull. It is either an integer vector of indices or vector of points. In
 the first case, the hull elements are 0-based indices of the convex hull points in the original
 array (since the set of convex hull points is a subset of the original point set). In the second
 case, hull elements are the convex hull points themselves.</dd>
<dd><code>clockwise</code> - Orientation flag. If it is true, the output convex hull is oriented clockwise.
 Otherwise, it is oriented counter-clockwise. The assumed coordinate system has its X axis pointing
 to the right, and its Y axis pointing upwards.
 returns convex hull points. Otherwise, it returns indices of the convex hull points. When the
 output array is std::vector, the flag is ignored, and the output depends on the type of the
 vector: std::vector&lt;int&gt; implies returnPoints=false, std::vector&lt;Point&gt; implies
 returnPoints=true.

 <b>Note:</b> <code>points</code> and <code>hull</code> should be different arrays, inplace processing isn't supported.

 Check REF: tutorial_hull "the corresponding tutorial" for more details.

 useful links:

 https://www.learnopencv.com/convex-hull-using-opencv-in-python-and-c/</dd>
</dl>
</li>
</ul>
<a name="convexityDefects-org.opencv.core.MatOfPoint-org.opencv.core.MatOfInt-org.opencv.core.MatOfInt4-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>convexityDefects</h4>
<pre>public static&nbsp;void&nbsp;convexityDefects(<a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&nbsp;contour,
                                    <a href="../../../org/opencv/core/MatOfInt.html" title="class in org.opencv.core">MatOfInt</a>&nbsp;convexhull,
                                    <a href="../../../org/opencv/core/MatOfInt4.html" title="class in org.opencv.core">MatOfInt4</a>&nbsp;convexityDefects)</pre>
<div class="block">Finds the convexity defects of a contour.

 The figure below displays convexity defects of a hand contour:

 ![image](pics/defects.png)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>contour</code> - Input contour.</dd>
<dd><code>convexhull</code> - Convex hull obtained using convexHull that should contain indices of the contour
 points that make the hull.</dd>
<dd><code>convexityDefects</code> - The output vector of convexity defects. In C++ and the new Python/Java
 interface each convexity defect is represented as 4-element integer vector (a.k.a. #Vec4i):
 (start_index, end_index, farthest_pt_index, fixpt_depth), where indices are 0-based indices
 in the original contour of the convexity defect beginning, end and the farthest point, and
 fixpt_depth is fixed-point approximation (with 8 fractional bits) of the distance between the
 farthest contour point and the hull. That is, to get the floating-point value of the depth will be
 fixpt_depth/256.0.</dd>
</dl>
</li>
</ul>
<a name="cornerEigenValsAndVecs-org.opencv.core.Mat-org.opencv.core.Mat-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cornerEigenValsAndVecs</h4>
<pre>public static&nbsp;void&nbsp;cornerEigenValsAndVecs(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                          int&nbsp;blockSize,
                                          int&nbsp;ksize)</pre>
<div class="block">Calculates eigenvalues and eigenvectors of image blocks for corner detection.

 For every pixel \(p\) , the function cornerEigenValsAndVecs considers a blockSize \(\times\) blockSize
 neighborhood \(S(p)\) . It calculates the covariation matrix of derivatives over the neighborhood as:

 \(M =  \begin{bmatrix} \sum _{S(p)}(dI/dx)^2 &amp;  \sum _{S(p)}dI/dx dI/dy  \\ \sum _{S(p)}dI/dx dI/dy &amp;  \sum _{S(p)}(dI/dy)^2 \end{bmatrix}\)

 where the derivatives are computed using the Sobel operator.

 After that, it finds eigenvectors and eigenvalues of \(M\) and stores them in the destination image as
 \((\lambda_1, \lambda_2, x_1, y_1, x_2, y_2)\) where

 <ul>
   <li>
    \(\lambda_1, \lambda_2\) are the non-sorted eigenvalues of \(M\)
   </li>
   <li>
    \(x_1, y_1\) are the eigenvectors corresponding to \(\lambda_1\)
   </li>
   <li>
    \(x_2, y_2\) are the eigenvectors corresponding to \(\lambda_2\)
   </li>
 </ul>

 The output of the function can be used for robust edge or corner detection.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Input single-channel 8-bit or floating-point image.</dd>
<dd><code>dst</code> - Image to store the results. It has the same size as src and the type CV_32FC(6) .</dd>
<dd><code>blockSize</code> - Neighborhood size (see details below).</dd>
<dd><code>ksize</code> - Aperture parameter for the Sobel operator.

 SEE:  cornerMinEigenVal, cornerHarris, preCornerDetect</dd>
</dl>
</li>
</ul>
<a name="cornerEigenValsAndVecs-org.opencv.core.Mat-org.opencv.core.Mat-int-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cornerEigenValsAndVecs</h4>
<pre>public static&nbsp;void&nbsp;cornerEigenValsAndVecs(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                          int&nbsp;blockSize,
                                          int&nbsp;ksize,
                                          int&nbsp;borderType)</pre>
<div class="block">Calculates eigenvalues and eigenvectors of image blocks for corner detection.

 For every pixel \(p\) , the function cornerEigenValsAndVecs considers a blockSize \(\times\) blockSize
 neighborhood \(S(p)\) . It calculates the covariation matrix of derivatives over the neighborhood as:

 \(M =  \begin{bmatrix} \sum _{S(p)}(dI/dx)^2 &amp;  \sum _{S(p)}dI/dx dI/dy  \\ \sum _{S(p)}dI/dx dI/dy &amp;  \sum _{S(p)}(dI/dy)^2 \end{bmatrix}\)

 where the derivatives are computed using the Sobel operator.

 After that, it finds eigenvectors and eigenvalues of \(M\) and stores them in the destination image as
 \((\lambda_1, \lambda_2, x_1, y_1, x_2, y_2)\) where

 <ul>
   <li>
    \(\lambda_1, \lambda_2\) are the non-sorted eigenvalues of \(M\)
   </li>
   <li>
    \(x_1, y_1\) are the eigenvectors corresponding to \(\lambda_1\)
   </li>
   <li>
    \(x_2, y_2\) are the eigenvectors corresponding to \(\lambda_2\)
   </li>
 </ul>

 The output of the function can be used for robust edge or corner detection.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Input single-channel 8-bit or floating-point image.</dd>
<dd><code>dst</code> - Image to store the results. It has the same size as src and the type CV_32FC(6) .</dd>
<dd><code>blockSize</code> - Neighborhood size (see details below).</dd>
<dd><code>ksize</code> - Aperture parameter for the Sobel operator.</dd>
<dd><code>borderType</code> - Pixel extrapolation method. See #BorderTypes. #BORDER_WRAP is not supported.

 SEE:  cornerMinEigenVal, cornerHarris, preCornerDetect</dd>
</dl>
</li>
</ul>
<a name="cornerHarris-org.opencv.core.Mat-org.opencv.core.Mat-int-int-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cornerHarris</h4>
<pre>public static&nbsp;void&nbsp;cornerHarris(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                int&nbsp;blockSize,
                                int&nbsp;ksize,
                                double&nbsp;k)</pre>
<div class="block">Harris corner detector.

 The function runs the Harris corner detector on the image. Similarly to cornerMinEigenVal and
 cornerEigenValsAndVecs , for each pixel \((x, y)\) it calculates a \(2\times2\) gradient covariance
 matrix \(M^{(x,y)}\) over a \(\texttt{blockSize} \times \texttt{blockSize}\) neighborhood. Then, it
 computes the following characteristic:

 \(\texttt{dst} (x,y) =  \mathrm{det} M^{(x,y)} - k  \cdot \left ( \mathrm{tr} M^{(x,y)} \right )^2\)

 Corners in the image can be found as the local maxima of this response map.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Input single-channel 8-bit or floating-point image.</dd>
<dd><code>dst</code> - Image to store the Harris detector responses. It has the type CV_32FC1 and the same
 size as src .</dd>
<dd><code>blockSize</code> - Neighborhood size (see the details on #cornerEigenValsAndVecs ).</dd>
<dd><code>ksize</code> - Aperture parameter for the Sobel operator.</dd>
<dd><code>k</code> - Harris detector free parameter. See the formula above.</dd>
</dl>
</li>
</ul>
<a name="cornerHarris-org.opencv.core.Mat-org.opencv.core.Mat-int-int-double-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cornerHarris</h4>
<pre>public static&nbsp;void&nbsp;cornerHarris(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                int&nbsp;blockSize,
                                int&nbsp;ksize,
                                double&nbsp;k,
                                int&nbsp;borderType)</pre>
<div class="block">Harris corner detector.

 The function runs the Harris corner detector on the image. Similarly to cornerMinEigenVal and
 cornerEigenValsAndVecs , for each pixel \((x, y)\) it calculates a \(2\times2\) gradient covariance
 matrix \(M^{(x,y)}\) over a \(\texttt{blockSize} \times \texttt{blockSize}\) neighborhood. Then, it
 computes the following characteristic:

 \(\texttt{dst} (x,y) =  \mathrm{det} M^{(x,y)} - k  \cdot \left ( \mathrm{tr} M^{(x,y)} \right )^2\)

 Corners in the image can be found as the local maxima of this response map.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Input single-channel 8-bit or floating-point image.</dd>
<dd><code>dst</code> - Image to store the Harris detector responses. It has the type CV_32FC1 and the same
 size as src .</dd>
<dd><code>blockSize</code> - Neighborhood size (see the details on #cornerEigenValsAndVecs ).</dd>
<dd><code>ksize</code> - Aperture parameter for the Sobel operator.</dd>
<dd><code>k</code> - Harris detector free parameter. See the formula above.</dd>
<dd><code>borderType</code> - Pixel extrapolation method. See #BorderTypes. #BORDER_WRAP is not supported.</dd>
</dl>
</li>
</ul>
<a name="cornerMinEigenVal-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cornerMinEigenVal</h4>
<pre>public static&nbsp;void&nbsp;cornerMinEigenVal(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                     int&nbsp;blockSize)</pre>
<div class="block">Calculates the minimal eigenvalue of gradient matrices for corner detection.

 The function is similar to cornerEigenValsAndVecs but it calculates and stores only the minimal
 eigenvalue of the covariance matrix of derivatives, that is, \(\min(\lambda_1, \lambda_2)\) in terms
 of the formulae in the cornerEigenValsAndVecs description.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Input single-channel 8-bit or floating-point image.</dd>
<dd><code>dst</code> - Image to store the minimal eigenvalues. It has the type CV_32FC1 and the same size as
 src .</dd>
<dd><code>blockSize</code> - Neighborhood size (see the details on #cornerEigenValsAndVecs ).</dd>
</dl>
</li>
</ul>
<a name="cornerMinEigenVal-org.opencv.core.Mat-org.opencv.core.Mat-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cornerMinEigenVal</h4>
<pre>public static&nbsp;void&nbsp;cornerMinEigenVal(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                     int&nbsp;blockSize,
                                     int&nbsp;ksize)</pre>
<div class="block">Calculates the minimal eigenvalue of gradient matrices for corner detection.

 The function is similar to cornerEigenValsAndVecs but it calculates and stores only the minimal
 eigenvalue of the covariance matrix of derivatives, that is, \(\min(\lambda_1, \lambda_2)\) in terms
 of the formulae in the cornerEigenValsAndVecs description.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Input single-channel 8-bit or floating-point image.</dd>
<dd><code>dst</code> - Image to store the minimal eigenvalues. It has the type CV_32FC1 and the same size as
 src .</dd>
<dd><code>blockSize</code> - Neighborhood size (see the details on #cornerEigenValsAndVecs ).</dd>
<dd><code>ksize</code> - Aperture parameter for the Sobel operator.</dd>
</dl>
</li>
</ul>
<a name="cornerMinEigenVal-org.opencv.core.Mat-org.opencv.core.Mat-int-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cornerMinEigenVal</h4>
<pre>public static&nbsp;void&nbsp;cornerMinEigenVal(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                     int&nbsp;blockSize,
                                     int&nbsp;ksize,
                                     int&nbsp;borderType)</pre>
<div class="block">Calculates the minimal eigenvalue of gradient matrices for corner detection.

 The function is similar to cornerEigenValsAndVecs but it calculates and stores only the minimal
 eigenvalue of the covariance matrix of derivatives, that is, \(\min(\lambda_1, \lambda_2)\) in terms
 of the formulae in the cornerEigenValsAndVecs description.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Input single-channel 8-bit or floating-point image.</dd>
<dd><code>dst</code> - Image to store the minimal eigenvalues. It has the type CV_32FC1 and the same size as
 src .</dd>
<dd><code>blockSize</code> - Neighborhood size (see the details on #cornerEigenValsAndVecs ).</dd>
<dd><code>ksize</code> - Aperture parameter for the Sobel operator.</dd>
<dd><code>borderType</code> - Pixel extrapolation method. See #BorderTypes. #BORDER_WRAP is not supported.</dd>
</dl>
</li>
</ul>
<a name="cornerSubPix-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-org.opencv.core.Size-org.opencv.core.TermCriteria-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cornerSubPix</h4>
<pre>public static&nbsp;void&nbsp;cornerSubPix(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;corners,
                                <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;winSize,
                                <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;zeroZone,
                                <a href="../../../org/opencv/core/TermCriteria.html" title="class in org.opencv.core">TermCriteria</a>&nbsp;criteria)</pre>
<div class="block">Refines the corner locations.

 The function iterates to find the sub-pixel accurate location of corners or radial saddle
 points as described in CITE: forstner1987fast, and as shown on the figure below.

 ![image](pics/cornersubpix.png)

 Sub-pixel accurate corner locator is based on the observation that every vector from the center \(q\)
 to a point \(p\) located within a neighborhood of \(q\) is orthogonal to the image gradient at \(p\)
 subject to image and measurement noise. Consider the expression:

 \(\epsilon _i = {DI_{p_i}}^T  \cdot (q - p_i)\)

 where \({DI_{p_i}}\) is an image gradient at one of the points \(p_i\) in a neighborhood of \(q\) . The
 value of \(q\) is to be found so that \(\epsilon_i\) is minimized. A system of equations may be set up
 with \(\epsilon_i\) set to zero:

 \(\sum _i(DI_{p_i}  \cdot {DI_{p_i}}^T) \cdot q -  \sum _i(DI_{p_i}  \cdot {DI_{p_i}}^T  \cdot p_i)\)

 where the gradients are summed within a neighborhood ("search window") of \(q\) . Calling the first
 gradient term \(G\) and the second gradient term \(b\) gives:

 \(q = G^{-1}  \cdot b\)

 The algorithm sets the center of the neighborhood window at this new center \(q\) and then iterates
 until the center stays within a set threshold.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - Input single-channel, 8-bit or float image.</dd>
<dd><code>corners</code> - Initial coordinates of the input corners and refined coordinates provided for
 output.</dd>
<dd><code>winSize</code> - Half of the side length of the search window. For example, if winSize=Size(5,5) ,
 then a \((5*2+1) \times (5*2+1) = 11 \times 11\) search window is used.</dd>
<dd><code>zeroZone</code> - Half of the size of the dead region in the middle of the search zone over which
 the summation in the formula below is not done. It is used sometimes to avoid possible
 singularities of the autocorrelation matrix. The value of (-1,-1) indicates that there is no such
 a size.</dd>
<dd><code>criteria</code> - Criteria for termination of the iterative process of corner refinement. That is,
 the process of corner position refinement stops either after criteria.maxCount iterations or when
 the corner position moves by less than criteria.epsilon on some iteration.</dd>
</dl>
</li>
</ul>
<a name="createCLAHE--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createCLAHE</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/imgproc/CLAHE.html" title="class in org.opencv.imgproc">CLAHE</a>&nbsp;createCLAHE()</pre>
<div class="block">Creates a smart pointer to a cv::CLAHE class and initializes it.

 equally sized rectangular tiles. tileGridSize defines the number of tiles in row and column.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="createCLAHE-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createCLAHE</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/imgproc/CLAHE.html" title="class in org.opencv.imgproc">CLAHE</a>&nbsp;createCLAHE(double&nbsp;clipLimit)</pre>
<div class="block">Creates a smart pointer to a cv::CLAHE class and initializes it.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>clipLimit</code> - Threshold for contrast limiting.
 equally sized rectangular tiles. tileGridSize defines the number of tiles in row and column.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="createCLAHE-double-org.opencv.core.Size-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createCLAHE</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/imgproc/CLAHE.html" title="class in org.opencv.imgproc">CLAHE</a>&nbsp;createCLAHE(double&nbsp;clipLimit,
                                <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;tileGridSize)</pre>
<div class="block">Creates a smart pointer to a cv::CLAHE class and initializes it.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>clipLimit</code> - Threshold for contrast limiting.</dd>
<dd><code>tileGridSize</code> - Size of grid for histogram equalization. Input image will be divided into
 equally sized rectangular tiles. tileGridSize defines the number of tiles in row and column.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="createGeneralizedHoughBallard--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createGeneralizedHoughBallard</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/imgproc/GeneralizedHoughBallard.html" title="class in org.opencv.imgproc">GeneralizedHoughBallard</a>&nbsp;createGeneralizedHoughBallard()</pre>
<div class="block">Creates a smart pointer to a cv::GeneralizedHoughBallard class and initializes it.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="createGeneralizedHoughGuil--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createGeneralizedHoughGuil</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/imgproc/GeneralizedHoughGuil.html" title="class in org.opencv.imgproc">GeneralizedHoughGuil</a>&nbsp;createGeneralizedHoughGuil()</pre>
<div class="block">Creates a smart pointer to a cv::GeneralizedHoughGuil class and initializes it.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="createHanningWindow-org.opencv.core.Mat-org.opencv.core.Size-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createHanningWindow</h4>
<pre>public static&nbsp;void&nbsp;createHanningWindow(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                       <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;winSize,
                                       int&nbsp;type)</pre>
<div class="block">This function computes a Hanning window coefficients in two dimensions.

 See (http://en.wikipedia.org/wiki/Hann_function) and (http://en.wikipedia.org/wiki/Window_function)
 for more information.

 An example is shown below:
 <code>
     // create hanning window of size 100x100 and type CV_32F
     Mat hann;
     createHanningWindow(hann, Size(100, 100), CV_32F);
 </code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>dst</code> - Destination array to place Hann coefficients in</dd>
<dd><code>winSize</code> - The window size specifications (both width and height must be &gt; 1)</dd>
<dd><code>type</code> - Created array type</dd>
</dl>
</li>
</ul>
<a name="createLineSegmentDetector--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createLineSegmentDetector</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/imgproc/LineSegmentDetector.html" title="class in org.opencv.imgproc">LineSegmentDetector</a>&nbsp;createLineSegmentDetector()</pre>
<div class="block">Creates a smart pointer to a LineSegmentDetector object and initializes it.

 The LineSegmentDetector algorithm is defined using the standard values. Only advanced users may want
 to edit those, as to tailor it for their own application.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="createLineSegmentDetector-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createLineSegmentDetector</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/imgproc/LineSegmentDetector.html" title="class in org.opencv.imgproc">LineSegmentDetector</a>&nbsp;createLineSegmentDetector(int&nbsp;refine)</pre>
<div class="block">Creates a smart pointer to a LineSegmentDetector object and initializes it.

 The LineSegmentDetector algorithm is defined using the standard values. Only advanced users may want
 to edit those, as to tailor it for their own application.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>refine</code> - The way found lines will be refined, see #LineSegmentDetectorModes</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="createLineSegmentDetector-int-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createLineSegmentDetector</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/imgproc/LineSegmentDetector.html" title="class in org.opencv.imgproc">LineSegmentDetector</a>&nbsp;createLineSegmentDetector(int&nbsp;refine,
                                                            double&nbsp;scale)</pre>
<div class="block">Creates a smart pointer to a LineSegmentDetector object and initializes it.

 The LineSegmentDetector algorithm is defined using the standard values. Only advanced users may want
 to edit those, as to tailor it for their own application.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>refine</code> - The way found lines will be refined, see #LineSegmentDetectorModes</dd>
<dd><code>scale</code> - The scale of the image that will be used to find the lines. Range (0..1].</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="createLineSegmentDetector-int-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createLineSegmentDetector</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/imgproc/LineSegmentDetector.html" title="class in org.opencv.imgproc">LineSegmentDetector</a>&nbsp;createLineSegmentDetector(int&nbsp;refine,
                                                            double&nbsp;scale,
                                                            double&nbsp;sigma_scale)</pre>
<div class="block">Creates a smart pointer to a LineSegmentDetector object and initializes it.

 The LineSegmentDetector algorithm is defined using the standard values. Only advanced users may want
 to edit those, as to tailor it for their own application.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>refine</code> - The way found lines will be refined, see #LineSegmentDetectorModes</dd>
<dd><code>scale</code> - The scale of the image that will be used to find the lines. Range (0..1].</dd>
<dd><code>sigma_scale</code> - Sigma for Gaussian filter. It is computed as sigma = sigma_scale/scale.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="createLineSegmentDetector-int-double-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createLineSegmentDetector</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/imgproc/LineSegmentDetector.html" title="class in org.opencv.imgproc">LineSegmentDetector</a>&nbsp;createLineSegmentDetector(int&nbsp;refine,
                                                            double&nbsp;scale,
                                                            double&nbsp;sigma_scale,
                                                            double&nbsp;quant)</pre>
<div class="block">Creates a smart pointer to a LineSegmentDetector object and initializes it.

 The LineSegmentDetector algorithm is defined using the standard values. Only advanced users may want
 to edit those, as to tailor it for their own application.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>refine</code> - The way found lines will be refined, see #LineSegmentDetectorModes</dd>
<dd><code>scale</code> - The scale of the image that will be used to find the lines. Range (0..1].</dd>
<dd><code>sigma_scale</code> - Sigma for Gaussian filter. It is computed as sigma = sigma_scale/scale.</dd>
<dd><code>quant</code> - Bound to the quantization error on the gradient norm.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="createLineSegmentDetector-int-double-double-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createLineSegmentDetector</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/imgproc/LineSegmentDetector.html" title="class in org.opencv.imgproc">LineSegmentDetector</a>&nbsp;createLineSegmentDetector(int&nbsp;refine,
                                                            double&nbsp;scale,
                                                            double&nbsp;sigma_scale,
                                                            double&nbsp;quant,
                                                            double&nbsp;ang_th)</pre>
<div class="block">Creates a smart pointer to a LineSegmentDetector object and initializes it.

 The LineSegmentDetector algorithm is defined using the standard values. Only advanced users may want
 to edit those, as to tailor it for their own application.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>refine</code> - The way found lines will be refined, see #LineSegmentDetectorModes</dd>
<dd><code>scale</code> - The scale of the image that will be used to find the lines. Range (0..1].</dd>
<dd><code>sigma_scale</code> - Sigma for Gaussian filter. It is computed as sigma = sigma_scale/scale.</dd>
<dd><code>quant</code> - Bound to the quantization error on the gradient norm.</dd>
<dd><code>ang_th</code> - Gradient angle tolerance in degrees.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="createLineSegmentDetector-int-double-double-double-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createLineSegmentDetector</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/imgproc/LineSegmentDetector.html" title="class in org.opencv.imgproc">LineSegmentDetector</a>&nbsp;createLineSegmentDetector(int&nbsp;refine,
                                                            double&nbsp;scale,
                                                            double&nbsp;sigma_scale,
                                                            double&nbsp;quant,
                                                            double&nbsp;ang_th,
                                                            double&nbsp;log_eps)</pre>
<div class="block">Creates a smart pointer to a LineSegmentDetector object and initializes it.

 The LineSegmentDetector algorithm is defined using the standard values. Only advanced users may want
 to edit those, as to tailor it for their own application.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>refine</code> - The way found lines will be refined, see #LineSegmentDetectorModes</dd>
<dd><code>scale</code> - The scale of the image that will be used to find the lines. Range (0..1].</dd>
<dd><code>sigma_scale</code> - Sigma for Gaussian filter. It is computed as sigma = sigma_scale/scale.</dd>
<dd><code>quant</code> - Bound to the quantization error on the gradient norm.</dd>
<dd><code>ang_th</code> - Gradient angle tolerance in degrees.</dd>
<dd><code>log_eps</code> - Detection threshold: -log10(NFA) &gt; log_eps. Used only when advance refinement is chosen.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="createLineSegmentDetector-int-double-double-double-double-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createLineSegmentDetector</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/imgproc/LineSegmentDetector.html" title="class in org.opencv.imgproc">LineSegmentDetector</a>&nbsp;createLineSegmentDetector(int&nbsp;refine,
                                                            double&nbsp;scale,
                                                            double&nbsp;sigma_scale,
                                                            double&nbsp;quant,
                                                            double&nbsp;ang_th,
                                                            double&nbsp;log_eps,
                                                            double&nbsp;density_th)</pre>
<div class="block">Creates a smart pointer to a LineSegmentDetector object and initializes it.

 The LineSegmentDetector algorithm is defined using the standard values. Only advanced users may want
 to edit those, as to tailor it for their own application.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>refine</code> - The way found lines will be refined, see #LineSegmentDetectorModes</dd>
<dd><code>scale</code> - The scale of the image that will be used to find the lines. Range (0..1].</dd>
<dd><code>sigma_scale</code> - Sigma for Gaussian filter. It is computed as sigma = sigma_scale/scale.</dd>
<dd><code>quant</code> - Bound to the quantization error on the gradient norm.</dd>
<dd><code>ang_th</code> - Gradient angle tolerance in degrees.</dd>
<dd><code>log_eps</code> - Detection threshold: -log10(NFA) &gt; log_eps. Used only when advance refinement is chosen.</dd>
<dd><code>density_th</code> - Minimal density of aligned region points in the enclosing rectangle.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="createLineSegmentDetector-int-double-double-double-double-double-double-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createLineSegmentDetector</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/imgproc/LineSegmentDetector.html" title="class in org.opencv.imgproc">LineSegmentDetector</a>&nbsp;createLineSegmentDetector(int&nbsp;refine,
                                                            double&nbsp;scale,
                                                            double&nbsp;sigma_scale,
                                                            double&nbsp;quant,
                                                            double&nbsp;ang_th,
                                                            double&nbsp;log_eps,
                                                            double&nbsp;density_th,
                                                            int&nbsp;n_bins)</pre>
<div class="block">Creates a smart pointer to a LineSegmentDetector object and initializes it.

 The LineSegmentDetector algorithm is defined using the standard values. Only advanced users may want
 to edit those, as to tailor it for their own application.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>refine</code> - The way found lines will be refined, see #LineSegmentDetectorModes</dd>
<dd><code>scale</code> - The scale of the image that will be used to find the lines. Range (0..1].</dd>
<dd><code>sigma_scale</code> - Sigma for Gaussian filter. It is computed as sigma = sigma_scale/scale.</dd>
<dd><code>quant</code> - Bound to the quantization error on the gradient norm.</dd>
<dd><code>ang_th</code> - Gradient angle tolerance in degrees.</dd>
<dd><code>log_eps</code> - Detection threshold: -log10(NFA) &gt; log_eps. Used only when advance refinement is chosen.</dd>
<dd><code>density_th</code> - Minimal density of aligned region points in the enclosing rectangle.</dd>
<dd><code>n_bins</code> - Number of bins in pseudo-ordering of gradient modulus.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="cvtColor-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cvtColor</h4>
<pre>public static&nbsp;void&nbsp;cvtColor(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                            int&nbsp;code)</pre>
<div class="block">Converts an image from one color space to another.

 The function converts an input image from one color space to another. In case of a transformation
 to-from RGB color space, the order of the channels should be specified explicitly (RGB or BGR). Note
 that the default color format in OpenCV is often referred to as RGB but it is actually BGR (the
 bytes are reversed). So the first byte in a standard (24-bit) color image will be an 8-bit Blue
 component, the second byte will be Green, and the third byte will be Red. The fourth, fifth, and
 sixth bytes would then be the second pixel (Blue, then Green, then Red), and so on.

 The conventional ranges for R, G, and B channel values are:
 <ul>
   <li>
    0 to 255 for CV_8U images
   </li>
   <li>
    0 to 65535 for CV_16U images
   </li>
   <li>
    0 to 1 for CV_32F images
   </li>
 </ul>

 In case of linear transformations, the range does not matter. But in case of a non-linear
 transformation, an input RGB image should be normalized to the proper value range to get the correct
 results, for example, for RGB \(\rightarrow\) L\*u\*v\* transformation. For example, if you have a
 32-bit floating-point image directly converted from an 8-bit image without any scaling, then it will
 have the 0..255 value range instead of 0..1 assumed by the function. So, before calling #cvtColor ,
 you need first to scale the image down:
 <code>
     img *= 1./255;
     cvtColor(img, img, COLOR_BGR2Luv);
 </code>
 If you use #cvtColor with 8-bit images, the conversion will have some information lost. For many
 applications, this will not be noticeable but it is recommended to use 32-bit images in applications
 that need the full range of colors or that convert an image before an operation and then convert
 back.

 If conversion adds the alpha channel, its value will set to the maximum of corresponding channel
 range: 255 for CV_8U, 65535 for CV_16U, 1 for CV_32F.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image: 8-bit unsigned, 16-bit unsigned ( CV_16UC... ), or single-precision
 floating-point.</dd>
<dd><code>dst</code> - output image of the same size and depth as src.</dd>
<dd><code>code</code> - color space conversion code (see #ColorConversionCodes).
 channels is derived automatically from src and code.

 SEE: REF: imgproc_color_conversions</dd>
</dl>
</li>
</ul>
<a name="cvtColor-org.opencv.core.Mat-org.opencv.core.Mat-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cvtColor</h4>
<pre>public static&nbsp;void&nbsp;cvtColor(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                            int&nbsp;code,
                            int&nbsp;dstCn)</pre>
<div class="block">Converts an image from one color space to another.

 The function converts an input image from one color space to another. In case of a transformation
 to-from RGB color space, the order of the channels should be specified explicitly (RGB or BGR). Note
 that the default color format in OpenCV is often referred to as RGB but it is actually BGR (the
 bytes are reversed). So the first byte in a standard (24-bit) color image will be an 8-bit Blue
 component, the second byte will be Green, and the third byte will be Red. The fourth, fifth, and
 sixth bytes would then be the second pixel (Blue, then Green, then Red), and so on.

 The conventional ranges for R, G, and B channel values are:
 <ul>
   <li>
    0 to 255 for CV_8U images
   </li>
   <li>
    0 to 65535 for CV_16U images
   </li>
   <li>
    0 to 1 for CV_32F images
   </li>
 </ul>

 In case of linear transformations, the range does not matter. But in case of a non-linear
 transformation, an input RGB image should be normalized to the proper value range to get the correct
 results, for example, for RGB \(\rightarrow\) L\*u\*v\* transformation. For example, if you have a
 32-bit floating-point image directly converted from an 8-bit image without any scaling, then it will
 have the 0..255 value range instead of 0..1 assumed by the function. So, before calling #cvtColor ,
 you need first to scale the image down:
 <code>
     img *= 1./255;
     cvtColor(img, img, COLOR_BGR2Luv);
 </code>
 If you use #cvtColor with 8-bit images, the conversion will have some information lost. For many
 applications, this will not be noticeable but it is recommended to use 32-bit images in applications
 that need the full range of colors or that convert an image before an operation and then convert
 back.

 If conversion adds the alpha channel, its value will set to the maximum of corresponding channel
 range: 255 for CV_8U, 65535 for CV_16U, 1 for CV_32F.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image: 8-bit unsigned, 16-bit unsigned ( CV_16UC... ), or single-precision
 floating-point.</dd>
<dd><code>dst</code> - output image of the same size and depth as src.</dd>
<dd><code>code</code> - color space conversion code (see #ColorConversionCodes).</dd>
<dd><code>dstCn</code> - number of channels in the destination image; if the parameter is 0, the number of the
 channels is derived automatically from src and code.

 SEE: REF: imgproc_color_conversions</dd>
</dl>
</li>
</ul>
<a name="cvtColorTwoPlane-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cvtColorTwoPlane</h4>
<pre>public static&nbsp;void&nbsp;cvtColorTwoPlane(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                                    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                                    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                    int&nbsp;code)</pre>
<div class="block">Converts an image from one color space to another where the source image is
 stored in two planes.

 This function only supports YUV420 to RGB conversion as of now.

 <ul>
   <li>
  #COLOR_YUV2BGR_NV12
   </li>
   <li>
  #COLOR_YUV2RGB_NV12
   </li>
   <li>
  #COLOR_YUV2BGRA_NV12
   </li>
   <li>
  #COLOR_YUV2RGBA_NV12
   </li>
   <li>
  #COLOR_YUV2BGR_NV21
   </li>
   <li>
  #COLOR_YUV2RGB_NV21
   </li>
   <li>
  #COLOR_YUV2BGRA_NV21
   </li>
   <li>
  #COLOR_YUV2RGBA_NV21
   </li>
 </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - automatically generated</dd>
<dd><code>src2</code> - automatically generated</dd>
<dd><code>dst</code> - automatically generated</dd>
<dd><code>code</code> - automatically generated</dd>
</dl>
</li>
</ul>
<a name="demosaicing-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>demosaicing</h4>
<pre>public static&nbsp;void&nbsp;demosaicing(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                               int&nbsp;code)</pre>
<div class="block">main function for all demosaicing processes</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image: 8-bit unsigned or 16-bit unsigned.</dd>
<dd><code>dst</code> - output image of the same size and depth as src.</dd>
<dd><code>code</code> - Color space conversion code (see the description below).
 channels is derived automatically from src and code.

 The function can do the following transformations:

 <ul>
   <li>
    Demosaicing using bilinear interpolation
   </li>
 </ul>

     #COLOR_BayerBG2BGR , #COLOR_BayerGB2BGR , #COLOR_BayerRG2BGR , #COLOR_BayerGR2BGR

     #COLOR_BayerBG2GRAY , #COLOR_BayerGB2GRAY , #COLOR_BayerRG2GRAY , #COLOR_BayerGR2GRAY

 <ul>
   <li>
    Demosaicing using Variable Number of Gradients.
   </li>
 </ul>

     #COLOR_BayerBG2BGR_VNG , #COLOR_BayerGB2BGR_VNG , #COLOR_BayerRG2BGR_VNG , #COLOR_BayerGR2BGR_VNG

 <ul>
   <li>
    Edge-Aware Demosaicing.
   </li>
 </ul>

     #COLOR_BayerBG2BGR_EA , #COLOR_BayerGB2BGR_EA , #COLOR_BayerRG2BGR_EA , #COLOR_BayerGR2BGR_EA

 <ul>
   <li>
    Demosaicing with alpha channel
   </li>
 </ul>

     #COLOR_BayerBG2BGRA , #COLOR_BayerGB2BGRA , #COLOR_BayerRG2BGRA , #COLOR_BayerGR2BGRA

 SEE: cvtColor</dd>
</dl>
</li>
</ul>
<a name="demosaicing-org.opencv.core.Mat-org.opencv.core.Mat-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>demosaicing</h4>
<pre>public static&nbsp;void&nbsp;demosaicing(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                               int&nbsp;code,
                               int&nbsp;dstCn)</pre>
<div class="block">main function for all demosaicing processes</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image: 8-bit unsigned or 16-bit unsigned.</dd>
<dd><code>dst</code> - output image of the same size and depth as src.</dd>
<dd><code>code</code> - Color space conversion code (see the description below).</dd>
<dd><code>dstCn</code> - number of channels in the destination image; if the parameter is 0, the number of the
 channels is derived automatically from src and code.

 The function can do the following transformations:

 <ul>
   <li>
    Demosaicing using bilinear interpolation
   </li>
 </ul>

     #COLOR_BayerBG2BGR , #COLOR_BayerGB2BGR , #COLOR_BayerRG2BGR , #COLOR_BayerGR2BGR

     #COLOR_BayerBG2GRAY , #COLOR_BayerGB2GRAY , #COLOR_BayerRG2GRAY , #COLOR_BayerGR2GRAY

 <ul>
   <li>
    Demosaicing using Variable Number of Gradients.
   </li>
 </ul>

     #COLOR_BayerBG2BGR_VNG , #COLOR_BayerGB2BGR_VNG , #COLOR_BayerRG2BGR_VNG , #COLOR_BayerGR2BGR_VNG

 <ul>
   <li>
    Edge-Aware Demosaicing.
   </li>
 </ul>

     #COLOR_BayerBG2BGR_EA , #COLOR_BayerGB2BGR_EA , #COLOR_BayerRG2BGR_EA , #COLOR_BayerGR2BGR_EA

 <ul>
   <li>
    Demosaicing with alpha channel
   </li>
 </ul>

     #COLOR_BayerBG2BGRA , #COLOR_BayerGB2BGRA , #COLOR_BayerRG2BGRA , #COLOR_BayerGR2BGRA

 SEE: cvtColor</dd>
</dl>
</li>
</ul>
<a name="dilate-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dilate</h4>
<pre>public static&nbsp;void&nbsp;dilate(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel)</pre>
<div class="block">Dilates an image by using a specific structuring element.

 The function dilates the source image using the specified structuring element that determines the
 shape of a pixel neighborhood over which the maximum is taken:
 \(\texttt{dst} (x,y) =  \max _{(x',y'):  \, \texttt{element} (x',y') \ne0 } \texttt{src} (x+x',y+y')\)

 The function supports the in-place mode. Dilation can be applied several ( iterations ) times. In
 case of multi-channel images, each channel is processed independently.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image; the number of channels can be arbitrary, but the depth should be one of
 CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.</dd>
<dd><code>dst</code> - output image of the same size and type as src.</dd>
<dd><code>kernel</code> - structuring element used for dilation; if element=Mat(), a 3 x 3 rectangular
 structuring element is used. Kernel can be created using #getStructuringElement
 anchor is at the element center.
 SEE:  erode, morphologyEx, getStructuringElement</dd>
</dl>
</li>
</ul>
<a name="dilate-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Point-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dilate</h4>
<pre>public static&nbsp;void&nbsp;dilate(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel,
                          <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor)</pre>
<div class="block">Dilates an image by using a specific structuring element.

 The function dilates the source image using the specified structuring element that determines the
 shape of a pixel neighborhood over which the maximum is taken:
 \(\texttt{dst} (x,y) =  \max _{(x',y'):  \, \texttt{element} (x',y') \ne0 } \texttt{src} (x+x',y+y')\)

 The function supports the in-place mode. Dilation can be applied several ( iterations ) times. In
 case of multi-channel images, each channel is processed independently.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image; the number of channels can be arbitrary, but the depth should be one of
 CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.</dd>
<dd><code>dst</code> - output image of the same size and type as src.</dd>
<dd><code>kernel</code> - structuring element used for dilation; if element=Mat(), a 3 x 3 rectangular
 structuring element is used. Kernel can be created using #getStructuringElement</dd>
<dd><code>anchor</code> - position of the anchor within the element; default value (-1, -1) means that the
 anchor is at the element center.
 SEE:  erode, morphologyEx, getStructuringElement</dd>
</dl>
</li>
</ul>
<a name="dilate-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Point-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dilate</h4>
<pre>public static&nbsp;void&nbsp;dilate(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel,
                          <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
                          int&nbsp;iterations)</pre>
<div class="block">Dilates an image by using a specific structuring element.

 The function dilates the source image using the specified structuring element that determines the
 shape of a pixel neighborhood over which the maximum is taken:
 \(\texttt{dst} (x,y) =  \max _{(x',y'):  \, \texttt{element} (x',y') \ne0 } \texttt{src} (x+x',y+y')\)

 The function supports the in-place mode. Dilation can be applied several ( iterations ) times. In
 case of multi-channel images, each channel is processed independently.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image; the number of channels can be arbitrary, but the depth should be one of
 CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.</dd>
<dd><code>dst</code> - output image of the same size and type as src.</dd>
<dd><code>kernel</code> - structuring element used for dilation; if element=Mat(), a 3 x 3 rectangular
 structuring element is used. Kernel can be created using #getStructuringElement</dd>
<dd><code>anchor</code> - position of the anchor within the element; default value (-1, -1) means that the
 anchor is at the element center.</dd>
<dd><code>iterations</code> - number of times dilation is applied.
 SEE:  erode, morphologyEx, getStructuringElement</dd>
</dl>
</li>
</ul>
<a name="dilate-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Point-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dilate</h4>
<pre>public static&nbsp;void&nbsp;dilate(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel,
                          <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
                          int&nbsp;iterations,
                          int&nbsp;borderType)</pre>
<div class="block">Dilates an image by using a specific structuring element.

 The function dilates the source image using the specified structuring element that determines the
 shape of a pixel neighborhood over which the maximum is taken:
 \(\texttt{dst} (x,y) =  \max _{(x',y'):  \, \texttt{element} (x',y') \ne0 } \texttt{src} (x+x',y+y')\)

 The function supports the in-place mode. Dilation can be applied several ( iterations ) times. In
 case of multi-channel images, each channel is processed independently.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image; the number of channels can be arbitrary, but the depth should be one of
 CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.</dd>
<dd><code>dst</code> - output image of the same size and type as src.</dd>
<dd><code>kernel</code> - structuring element used for dilation; if element=Mat(), a 3 x 3 rectangular
 structuring element is used. Kernel can be created using #getStructuringElement</dd>
<dd><code>anchor</code> - position of the anchor within the element; default value (-1, -1) means that the
 anchor is at the element center.</dd>
<dd><code>iterations</code> - number of times dilation is applied.</dd>
<dd><code>borderType</code> - pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not suported.
 SEE:  erode, morphologyEx, getStructuringElement</dd>
</dl>
</li>
</ul>
<a name="dilate-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Point-int-int-org.opencv.core.Scalar-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dilate</h4>
<pre>public static&nbsp;void&nbsp;dilate(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel,
                          <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
                          int&nbsp;iterations,
                          int&nbsp;borderType,
                          <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;borderValue)</pre>
<div class="block">Dilates an image by using a specific structuring element.

 The function dilates the source image using the specified structuring element that determines the
 shape of a pixel neighborhood over which the maximum is taken:
 \(\texttt{dst} (x,y) =  \max _{(x',y'):  \, \texttt{element} (x',y') \ne0 } \texttt{src} (x+x',y+y')\)

 The function supports the in-place mode. Dilation can be applied several ( iterations ) times. In
 case of multi-channel images, each channel is processed independently.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image; the number of channels can be arbitrary, but the depth should be one of
 CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.</dd>
<dd><code>dst</code> - output image of the same size and type as src.</dd>
<dd><code>kernel</code> - structuring element used for dilation; if element=Mat(), a 3 x 3 rectangular
 structuring element is used. Kernel can be created using #getStructuringElement</dd>
<dd><code>anchor</code> - position of the anchor within the element; default value (-1, -1) means that the
 anchor is at the element center.</dd>
<dd><code>iterations</code> - number of times dilation is applied.</dd>
<dd><code>borderType</code> - pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not suported.</dd>
<dd><code>borderValue</code> - border value in case of a constant border
 SEE:  erode, morphologyEx, getStructuringElement</dd>
</dl>
</li>
</ul>
<a name="distanceTransform-org.opencv.core.Mat-org.opencv.core.Mat-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>distanceTransform</h4>
<pre>public static&nbsp;void&nbsp;distanceTransform(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                     int&nbsp;distanceType,
                                     int&nbsp;maskSize)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - 8-bit, single-channel (binary) source image.</dd>
<dd><code>dst</code> - Output image with calculated distances. It is a 8-bit or 32-bit floating-point,
 single-channel image of the same size as src .</dd>
<dd><code>distanceType</code> - Type of distance, see #DistanceTypes</dd>
<dd><code>maskSize</code> - Size of the distance transform mask, see #DistanceTransformMasks. In case of the
 #DIST_L1 or #DIST_C distance type, the parameter is forced to 3 because a \(3\times 3\) mask gives
 the same result as \(5\times 5\) or any larger aperture.
 the first variant of the function and distanceType == #DIST_L1.</dd>
</dl>
</li>
</ul>
<a name="distanceTransform-org.opencv.core.Mat-org.opencv.core.Mat-int-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>distanceTransform</h4>
<pre>public static&nbsp;void&nbsp;distanceTransform(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                     int&nbsp;distanceType,
                                     int&nbsp;maskSize,
                                     int&nbsp;dstType)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - 8-bit, single-channel (binary) source image.</dd>
<dd><code>dst</code> - Output image with calculated distances. It is a 8-bit or 32-bit floating-point,
 single-channel image of the same size as src .</dd>
<dd><code>distanceType</code> - Type of distance, see #DistanceTypes</dd>
<dd><code>maskSize</code> - Size of the distance transform mask, see #DistanceTransformMasks. In case of the
 #DIST_L1 or #DIST_C distance type, the parameter is forced to 3 because a \(3\times 3\) mask gives
 the same result as \(5\times 5\) or any larger aperture.</dd>
<dd><code>dstType</code> - Type of output image. It can be CV_8U or CV_32F. Type CV_8U can be used only for
 the first variant of the function and distanceType == #DIST_L1.</dd>
</dl>
</li>
</ul>
<a name="distanceTransformWithLabels-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>distanceTransformWithLabels</h4>
<pre>public static&nbsp;void&nbsp;distanceTransformWithLabels(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;labels,
                                               int&nbsp;distanceType,
                                               int&nbsp;maskSize)</pre>
<div class="block">Calculates the distance to the closest zero pixel for each pixel of the source image.

 The function cv::distanceTransform calculates the approximate or precise distance from every binary
 image pixel to the nearest zero pixel. For zero image pixels, the distance will obviously be zero.

 When maskSize == #DIST_MASK_PRECISE and distanceType == #DIST_L2 , the function runs the
 algorithm described in CITE: Felzenszwalb04 . This algorithm is parallelized with the TBB library.

 In other cases, the algorithm CITE: Borgefors86 is used. This means that for a pixel the function
 finds the shortest path to the nearest zero pixel consisting of basic shifts: horizontal, vertical,
 diagonal, or knight's move (the latest is available for a \(5\times 5\) mask). The overall
 distance is calculated as a sum of these basic distances. Since the distance function should be
 symmetric, all of the horizontal and vertical shifts must have the same cost (denoted as a ), all
 the diagonal shifts must have the same cost (denoted as <code>b</code>), and all knight's moves must have the
 same cost (denoted as <code>c</code>). For the #DIST_C and #DIST_L1 types, the distance is calculated
 precisely, whereas for #DIST_L2 (Euclidean distance) the distance can be calculated only with a
 relative error (a \(5\times 5\) mask gives more accurate results). For <code>a</code>,<code>b</code>, and <code>c</code>, OpenCV
 uses the values suggested in the original paper:
 <ul>
   <li>
  DIST_L1: <code>a = 1, b = 2</code>
   </li>
   <li>
  DIST_L2:
   <ul>
     <li>
      <code>3 x 3</code>: <code>a=0.955, b=1.3693</code>
     </li>
     <li>
      <code>5 x 5</code>: <code>a=1, b=1.4, c=2.1969</code>
     </li>
   </ul>
   <li>
  DIST_C: <code>a = 1, b = 1</code>
   </li>
 </ul>

 Typically, for a fast, coarse distance estimation #DIST_L2, a \(3\times 3\) mask is used. For a
 more accurate distance estimation #DIST_L2, a \(5\times 5\) mask or the precise algorithm is used.
 Note that both the precise and the approximate algorithms are linear on the number of pixels.

 This variant of the function does not only compute the minimum distance for each pixel \((x, y)\)
 but also identifies the nearest connected component consisting of zero pixels
 (labelType==#DIST_LABEL_CCOMP) or the nearest zero pixel (labelType==#DIST_LABEL_PIXEL). Index of the
 component/pixel is stored in <code>labels(x, y)</code>. When labelType==#DIST_LABEL_CCOMP, the function
 automatically finds connected components of zero pixels in the input image and marks them with
 distinct labels. When labelType==#DIST_LABEL_PIXEL, the function scans through the input image and
 marks all the zero pixels with distinct labels.

 In this mode, the complexity is still linear. That is, the function provides a very fast way to
 compute the Voronoi diagram for a binary image. Currently, the second variant can use only the
 approximate distance transform algorithm, i.e. maskSize=#DIST_MASK_PRECISE is not supported
 yet.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - 8-bit, single-channel (binary) source image.</dd>
<dd><code>dst</code> - Output image with calculated distances. It is a 8-bit or 32-bit floating-point,
 single-channel image of the same size as src.</dd>
<dd><code>labels</code> - Output 2D array of labels (the discrete Voronoi diagram). It has the type
 CV_32SC1 and the same size as src.</dd>
<dd><code>distanceType</code> - Type of distance, see #DistanceTypes</dd>
<dd><code>maskSize</code> - Size of the distance transform mask, see #DistanceTransformMasks.
 #DIST_MASK_PRECISE is not supported by this variant. In case of the #DIST_L1 or #DIST_C distance type,
 the parameter is forced to 3 because a \(3\times 3\) mask gives the same result as \(5\times
 5\) or any larger aperture.</dd>
</dl>
</li>
</ul>
<a name="distanceTransformWithLabels-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>distanceTransformWithLabels</h4>
<pre>public static&nbsp;void&nbsp;distanceTransformWithLabels(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;labels,
                                               int&nbsp;distanceType,
                                               int&nbsp;maskSize,
                                               int&nbsp;labelType)</pre>
<div class="block">Calculates the distance to the closest zero pixel for each pixel of the source image.

 The function cv::distanceTransform calculates the approximate or precise distance from every binary
 image pixel to the nearest zero pixel. For zero image pixels, the distance will obviously be zero.

 When maskSize == #DIST_MASK_PRECISE and distanceType == #DIST_L2 , the function runs the
 algorithm described in CITE: Felzenszwalb04 . This algorithm is parallelized with the TBB library.

 In other cases, the algorithm CITE: Borgefors86 is used. This means that for a pixel the function
 finds the shortest path to the nearest zero pixel consisting of basic shifts: horizontal, vertical,
 diagonal, or knight's move (the latest is available for a \(5\times 5\) mask). The overall
 distance is calculated as a sum of these basic distances. Since the distance function should be
 symmetric, all of the horizontal and vertical shifts must have the same cost (denoted as a ), all
 the diagonal shifts must have the same cost (denoted as <code>b</code>), and all knight's moves must have the
 same cost (denoted as <code>c</code>). For the #DIST_C and #DIST_L1 types, the distance is calculated
 precisely, whereas for #DIST_L2 (Euclidean distance) the distance can be calculated only with a
 relative error (a \(5\times 5\) mask gives more accurate results). For <code>a</code>,<code>b</code>, and <code>c</code>, OpenCV
 uses the values suggested in the original paper:
 <ul>
   <li>
  DIST_L1: <code>a = 1, b = 2</code>
   </li>
   <li>
  DIST_L2:
   <ul>
     <li>
      <code>3 x 3</code>: <code>a=0.955, b=1.3693</code>
     </li>
     <li>
      <code>5 x 5</code>: <code>a=1, b=1.4, c=2.1969</code>
     </li>
   </ul>
   <li>
  DIST_C: <code>a = 1, b = 1</code>
   </li>
 </ul>

 Typically, for a fast, coarse distance estimation #DIST_L2, a \(3\times 3\) mask is used. For a
 more accurate distance estimation #DIST_L2, a \(5\times 5\) mask or the precise algorithm is used.
 Note that both the precise and the approximate algorithms are linear on the number of pixels.

 This variant of the function does not only compute the minimum distance for each pixel \((x, y)\)
 but also identifies the nearest connected component consisting of zero pixels
 (labelType==#DIST_LABEL_CCOMP) or the nearest zero pixel (labelType==#DIST_LABEL_PIXEL). Index of the
 component/pixel is stored in <code>labels(x, y)</code>. When labelType==#DIST_LABEL_CCOMP, the function
 automatically finds connected components of zero pixels in the input image and marks them with
 distinct labels. When labelType==#DIST_LABEL_PIXEL, the function scans through the input image and
 marks all the zero pixels with distinct labels.

 In this mode, the complexity is still linear. That is, the function provides a very fast way to
 compute the Voronoi diagram for a binary image. Currently, the second variant can use only the
 approximate distance transform algorithm, i.e. maskSize=#DIST_MASK_PRECISE is not supported
 yet.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - 8-bit, single-channel (binary) source image.</dd>
<dd><code>dst</code> - Output image with calculated distances. It is a 8-bit or 32-bit floating-point,
 single-channel image of the same size as src.</dd>
<dd><code>labels</code> - Output 2D array of labels (the discrete Voronoi diagram). It has the type
 CV_32SC1 and the same size as src.</dd>
<dd><code>distanceType</code> - Type of distance, see #DistanceTypes</dd>
<dd><code>maskSize</code> - Size of the distance transform mask, see #DistanceTransformMasks.
 #DIST_MASK_PRECISE is not supported by this variant. In case of the #DIST_L1 or #DIST_C distance type,
 the parameter is forced to 3 because a \(3\times 3\) mask gives the same result as \(5\times
 5\) or any larger aperture.</dd>
<dd><code>labelType</code> - Type of the label array to build, see #DistanceTransformLabelTypes.</dd>
</dl>
</li>
</ul>
<a name="divSpectrums-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>divSpectrums</h4>
<pre>public static&nbsp;void&nbsp;divSpectrums(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;a,
                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;b,
                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;c,
                                int&nbsp;flags)</pre>
<div class="block">Performs the per-element division of the first Fourier spectrum by the second Fourier spectrum.

 The function cv::divSpectrums performs the per-element division of the first array by the second array.
 The arrays are CCS-packed or complex matrices that are results of a real or complex Fourier transform.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - first input array.</dd>
<dd><code>b</code> - second input array of the same size and type as src1 .</dd>
<dd><code>c</code> - output array of the same size and type as src1 .</dd>
<dd><code>flags</code> - operation flags; currently, the only supported flag is cv::DFT_ROWS, which indicates that
 each row of src1 and src2 is an independent 1D Fourier spectrum. If you do not want to use this flag, then simply add a <code>0</code> as value.
 or not (false).</dd>
</dl>
</li>
</ul>
<a name="divSpectrums-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>divSpectrums</h4>
<pre>public static&nbsp;void&nbsp;divSpectrums(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;a,
                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;b,
                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;c,
                                int&nbsp;flags,
                                boolean&nbsp;conjB)</pre>
<div class="block">Performs the per-element division of the first Fourier spectrum by the second Fourier spectrum.

 The function cv::divSpectrums performs the per-element division of the first array by the second array.
 The arrays are CCS-packed or complex matrices that are results of a real or complex Fourier transform.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - first input array.</dd>
<dd><code>b</code> - second input array of the same size and type as src1 .</dd>
<dd><code>c</code> - output array of the same size and type as src1 .</dd>
<dd><code>flags</code> - operation flags; currently, the only supported flag is cv::DFT_ROWS, which indicates that
 each row of src1 and src2 is an independent 1D Fourier spectrum. If you do not want to use this flag, then simply add a <code>0</code> as value.</dd>
<dd><code>conjB</code> - optional flag that conjugates the second input array before the multiplication (true)
 or not (false).</dd>
</dl>
</li>
</ul>
<a name="drawContours-org.opencv.core.Mat-java.util.List-int-org.opencv.core.Scalar-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>drawContours</h4>
<pre>public static&nbsp;void&nbsp;drawContours(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;contours,
                                int&nbsp;contourIdx,
                                <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color)</pre>
<div class="block">Draws contours outlines or filled contours.

 The function draws contour outlines in the image if \(\texttt{thickness} \ge 0\) or fills the area
 bounded by the contours if \(\texttt{thickness}&lt;0\) . The example below shows how to retrieve
 connected components from the binary image and label them: :
 INCLUDE: snippets/imgproc_drawContours.cpp</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - Destination image.</dd>
<dd><code>contours</code> - All the input contours. Each contour is stored as a point vector.</dd>
<dd><code>contourIdx</code> - Parameter indicating a contour to draw. If it is negative, all the contours are drawn.</dd>
<dd><code>color</code> - Color of the contours.
 thickness=#FILLED ), the contour interiors are drawn.
 some of the contours (see maxLevel ).
 If it is 1, the function draws the contour(s) and all the nested contours. If it is 2, the function
 draws the contours, all the nested contours, all the nested-to-nested contours, and so on. This
 parameter is only taken into account when there is hierarchy available.
 \(\texttt{offset}=(dx,dy)\) .
 <b>Note:</b> When thickness=#FILLED, the function is designed to handle connected components with holes correctly
 even when no hierarchy data is provided. This is done by analyzing all the outlines together
 using even-odd rule. This may give incorrect results if you have a joint collection of separately retrieved
 contours. In order to solve this problem, you need to call #drawContours separately for each sub-group
 of contours, or iterate over the collection using contourIdx parameter.</dd>
</dl>
</li>
</ul>
<a name="drawContours-org.opencv.core.Mat-java.util.List-int-org.opencv.core.Scalar-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>drawContours</h4>
<pre>public static&nbsp;void&nbsp;drawContours(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;contours,
                                int&nbsp;contourIdx,
                                <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
                                int&nbsp;thickness)</pre>
<div class="block">Draws contours outlines or filled contours.

 The function draws contour outlines in the image if \(\texttt{thickness} \ge 0\) or fills the area
 bounded by the contours if \(\texttt{thickness}&lt;0\) . The example below shows how to retrieve
 connected components from the binary image and label them: :
 INCLUDE: snippets/imgproc_drawContours.cpp</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - Destination image.</dd>
<dd><code>contours</code> - All the input contours. Each contour is stored as a point vector.</dd>
<dd><code>contourIdx</code> - Parameter indicating a contour to draw. If it is negative, all the contours are drawn.</dd>
<dd><code>color</code> - Color of the contours.</dd>
<dd><code>thickness</code> - Thickness of lines the contours are drawn with. If it is negative (for example,
 thickness=#FILLED ), the contour interiors are drawn.
 some of the contours (see maxLevel ).
 If it is 1, the function draws the contour(s) and all the nested contours. If it is 2, the function
 draws the contours, all the nested contours, all the nested-to-nested contours, and so on. This
 parameter is only taken into account when there is hierarchy available.
 \(\texttt{offset}=(dx,dy)\) .
 <b>Note:</b> When thickness=#FILLED, the function is designed to handle connected components with holes correctly
 even when no hierarchy data is provided. This is done by analyzing all the outlines together
 using even-odd rule. This may give incorrect results if you have a joint collection of separately retrieved
 contours. In order to solve this problem, you need to call #drawContours separately for each sub-group
 of contours, or iterate over the collection using contourIdx parameter.</dd>
</dl>
</li>
</ul>
<a name="drawContours-org.opencv.core.Mat-java.util.List-int-org.opencv.core.Scalar-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>drawContours</h4>
<pre>public static&nbsp;void&nbsp;drawContours(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;contours,
                                int&nbsp;contourIdx,
                                <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
                                int&nbsp;thickness,
                                int&nbsp;lineType)</pre>
<div class="block">Draws contours outlines or filled contours.

 The function draws contour outlines in the image if \(\texttt{thickness} \ge 0\) or fills the area
 bounded by the contours if \(\texttt{thickness}&lt;0\) . The example below shows how to retrieve
 connected components from the binary image and label them: :
 INCLUDE: snippets/imgproc_drawContours.cpp</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - Destination image.</dd>
<dd><code>contours</code> - All the input contours. Each contour is stored as a point vector.</dd>
<dd><code>contourIdx</code> - Parameter indicating a contour to draw. If it is negative, all the contours are drawn.</dd>
<dd><code>color</code> - Color of the contours.</dd>
<dd><code>thickness</code> - Thickness of lines the contours are drawn with. If it is negative (for example,
 thickness=#FILLED ), the contour interiors are drawn.</dd>
<dd><code>lineType</code> - Line connectivity. See #LineTypes
 some of the contours (see maxLevel ).
 If it is 1, the function draws the contour(s) and all the nested contours. If it is 2, the function
 draws the contours, all the nested contours, all the nested-to-nested contours, and so on. This
 parameter is only taken into account when there is hierarchy available.
 \(\texttt{offset}=(dx,dy)\) .
 <b>Note:</b> When thickness=#FILLED, the function is designed to handle connected components with holes correctly
 even when no hierarchy data is provided. This is done by analyzing all the outlines together
 using even-odd rule. This may give incorrect results if you have a joint collection of separately retrieved
 contours. In order to solve this problem, you need to call #drawContours separately for each sub-group
 of contours, or iterate over the collection using contourIdx parameter.</dd>
</dl>
</li>
</ul>
<a name="drawContours-org.opencv.core.Mat-java.util.List-int-org.opencv.core.Scalar-int-int-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>drawContours</h4>
<pre>public static&nbsp;void&nbsp;drawContours(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;contours,
                                int&nbsp;contourIdx,
                                <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
                                int&nbsp;thickness,
                                int&nbsp;lineType,
                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;hierarchy)</pre>
<div class="block">Draws contours outlines or filled contours.

 The function draws contour outlines in the image if \(\texttt{thickness} \ge 0\) or fills the area
 bounded by the contours if \(\texttt{thickness}&lt;0\) . The example below shows how to retrieve
 connected components from the binary image and label them: :
 INCLUDE: snippets/imgproc_drawContours.cpp</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - Destination image.</dd>
<dd><code>contours</code> - All the input contours. Each contour is stored as a point vector.</dd>
<dd><code>contourIdx</code> - Parameter indicating a contour to draw. If it is negative, all the contours are drawn.</dd>
<dd><code>color</code> - Color of the contours.</dd>
<dd><code>thickness</code> - Thickness of lines the contours are drawn with. If it is negative (for example,
 thickness=#FILLED ), the contour interiors are drawn.</dd>
<dd><code>lineType</code> - Line connectivity. See #LineTypes</dd>
<dd><code>hierarchy</code> - Optional information about hierarchy. It is only needed if you want to draw only
 some of the contours (see maxLevel ).
 If it is 1, the function draws the contour(s) and all the nested contours. If it is 2, the function
 draws the contours, all the nested contours, all the nested-to-nested contours, and so on. This
 parameter is only taken into account when there is hierarchy available.
 \(\texttt{offset}=(dx,dy)\) .
 <b>Note:</b> When thickness=#FILLED, the function is designed to handle connected components with holes correctly
 even when no hierarchy data is provided. This is done by analyzing all the outlines together
 using even-odd rule. This may give incorrect results if you have a joint collection of separately retrieved
 contours. In order to solve this problem, you need to call #drawContours separately for each sub-group
 of contours, or iterate over the collection using contourIdx parameter.</dd>
</dl>
</li>
</ul>
<a name="drawContours-org.opencv.core.Mat-java.util.List-int-org.opencv.core.Scalar-int-int-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>drawContours</h4>
<pre>public static&nbsp;void&nbsp;drawContours(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;contours,
                                int&nbsp;contourIdx,
                                <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
                                int&nbsp;thickness,
                                int&nbsp;lineType,
                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;hierarchy,
                                int&nbsp;maxLevel)</pre>
<div class="block">Draws contours outlines or filled contours.

 The function draws contour outlines in the image if \(\texttt{thickness} \ge 0\) or fills the area
 bounded by the contours if \(\texttt{thickness}&lt;0\) . The example below shows how to retrieve
 connected components from the binary image and label them: :
 INCLUDE: snippets/imgproc_drawContours.cpp</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - Destination image.</dd>
<dd><code>contours</code> - All the input contours. Each contour is stored as a point vector.</dd>
<dd><code>contourIdx</code> - Parameter indicating a contour to draw. If it is negative, all the contours are drawn.</dd>
<dd><code>color</code> - Color of the contours.</dd>
<dd><code>thickness</code> - Thickness of lines the contours are drawn with. If it is negative (for example,
 thickness=#FILLED ), the contour interiors are drawn.</dd>
<dd><code>lineType</code> - Line connectivity. See #LineTypes</dd>
<dd><code>hierarchy</code> - Optional information about hierarchy. It is only needed if you want to draw only
 some of the contours (see maxLevel ).</dd>
<dd><code>maxLevel</code> - Maximal level for drawn contours. If it is 0, only the specified contour is drawn.
 If it is 1, the function draws the contour(s) and all the nested contours. If it is 2, the function
 draws the contours, all the nested contours, all the nested-to-nested contours, and so on. This
 parameter is only taken into account when there is hierarchy available.
 \(\texttt{offset}=(dx,dy)\) .
 <b>Note:</b> When thickness=#FILLED, the function is designed to handle connected components with holes correctly
 even when no hierarchy data is provided. This is done by analyzing all the outlines together
 using even-odd rule. This may give incorrect results if you have a joint collection of separately retrieved
 contours. In order to solve this problem, you need to call #drawContours separately for each sub-group
 of contours, or iterate over the collection using contourIdx parameter.</dd>
</dl>
</li>
</ul>
<a name="drawContours-org.opencv.core.Mat-java.util.List-int-org.opencv.core.Scalar-int-int-org.opencv.core.Mat-int-org.opencv.core.Point-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>drawContours</h4>
<pre>public static&nbsp;void&nbsp;drawContours(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;contours,
                                int&nbsp;contourIdx,
                                <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
                                int&nbsp;thickness,
                                int&nbsp;lineType,
                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;hierarchy,
                                int&nbsp;maxLevel,
                                <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;offset)</pre>
<div class="block">Draws contours outlines or filled contours.

 The function draws contour outlines in the image if \(\texttt{thickness} \ge 0\) or fills the area
 bounded by the contours if \(\texttt{thickness}&lt;0\) . The example below shows how to retrieve
 connected components from the binary image and label them: :
 INCLUDE: snippets/imgproc_drawContours.cpp</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - Destination image.</dd>
<dd><code>contours</code> - All the input contours. Each contour is stored as a point vector.</dd>
<dd><code>contourIdx</code> - Parameter indicating a contour to draw. If it is negative, all the contours are drawn.</dd>
<dd><code>color</code> - Color of the contours.</dd>
<dd><code>thickness</code> - Thickness of lines the contours are drawn with. If it is negative (for example,
 thickness=#FILLED ), the contour interiors are drawn.</dd>
<dd><code>lineType</code> - Line connectivity. See #LineTypes</dd>
<dd><code>hierarchy</code> - Optional information about hierarchy. It is only needed if you want to draw only
 some of the contours (see maxLevel ).</dd>
<dd><code>maxLevel</code> - Maximal level for drawn contours. If it is 0, only the specified contour is drawn.
 If it is 1, the function draws the contour(s) and all the nested contours. If it is 2, the function
 draws the contours, all the nested contours, all the nested-to-nested contours, and so on. This
 parameter is only taken into account when there is hierarchy available.</dd>
<dd><code>offset</code> - Optional contour shift parameter. Shift all the drawn contours by the specified
 \(\texttt{offset}=(dx,dy)\) .
 <b>Note:</b> When thickness=#FILLED, the function is designed to handle connected components with holes correctly
 even when no hierarchy data is provided. This is done by analyzing all the outlines together
 using even-odd rule. This may give incorrect results if you have a joint collection of separately retrieved
 contours. In order to solve this problem, you need to call #drawContours separately for each sub-group
 of contours, or iterate over the collection using contourIdx parameter.</dd>
</dl>
</li>
</ul>
<a name="drawMarker-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Scalar-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>drawMarker</h4>
<pre>public static&nbsp;void&nbsp;drawMarker(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                              <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;position,
                              <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color)</pre>
<div class="block">Draws a marker on a predefined position in an image.

 The function cv::drawMarker draws a marker on a given position in the image. For the moment several
 marker types are supported, see #MarkerTypes for more information.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - Image.</dd>
<dd><code>position</code> - The point where the crosshair is positioned.</dd>
<dd><code>color</code> - Line color.</dd>
</dl>
</li>
</ul>
<a name="drawMarker-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Scalar-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>drawMarker</h4>
<pre>public static&nbsp;void&nbsp;drawMarker(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                              <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;position,
                              <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
                              int&nbsp;markerType)</pre>
<div class="block">Draws a marker on a predefined position in an image.

 The function cv::drawMarker draws a marker on a given position in the image. For the moment several
 marker types are supported, see #MarkerTypes for more information.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - Image.</dd>
<dd><code>position</code> - The point where the crosshair is positioned.</dd>
<dd><code>color</code> - Line color.</dd>
<dd><code>markerType</code> - The specific type of marker you want to use, see #MarkerTypes</dd>
</dl>
</li>
</ul>
<a name="drawMarker-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Scalar-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>drawMarker</h4>
<pre>public static&nbsp;void&nbsp;drawMarker(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                              <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;position,
                              <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
                              int&nbsp;markerType,
                              int&nbsp;markerSize)</pre>
<div class="block">Draws a marker on a predefined position in an image.

 The function cv::drawMarker draws a marker on a given position in the image. For the moment several
 marker types are supported, see #MarkerTypes for more information.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - Image.</dd>
<dd><code>position</code> - The point where the crosshair is positioned.</dd>
<dd><code>color</code> - Line color.</dd>
<dd><code>markerType</code> - The specific type of marker you want to use, see #MarkerTypes</dd>
<dd><code>markerSize</code> - The length of the marker axis [default = 20 pixels]</dd>
</dl>
</li>
</ul>
<a name="drawMarker-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Scalar-int-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>drawMarker</h4>
<pre>public static&nbsp;void&nbsp;drawMarker(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                              <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;position,
                              <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
                              int&nbsp;markerType,
                              int&nbsp;markerSize,
                              int&nbsp;thickness)</pre>
<div class="block">Draws a marker on a predefined position in an image.

 The function cv::drawMarker draws a marker on a given position in the image. For the moment several
 marker types are supported, see #MarkerTypes for more information.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - Image.</dd>
<dd><code>position</code> - The point where the crosshair is positioned.</dd>
<dd><code>color</code> - Line color.</dd>
<dd><code>markerType</code> - The specific type of marker you want to use, see #MarkerTypes</dd>
<dd><code>thickness</code> - Line thickness.</dd>
<dd><code>markerSize</code> - The length of the marker axis [default = 20 pixels]</dd>
</dl>
</li>
</ul>
<a name="drawMarker-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Scalar-int-int-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>drawMarker</h4>
<pre>public static&nbsp;void&nbsp;drawMarker(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                              <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;position,
                              <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
                              int&nbsp;markerType,
                              int&nbsp;markerSize,
                              int&nbsp;thickness,
                              int&nbsp;line_type)</pre>
<div class="block">Draws a marker on a predefined position in an image.

 The function cv::drawMarker draws a marker on a given position in the image. For the moment several
 marker types are supported, see #MarkerTypes for more information.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - Image.</dd>
<dd><code>position</code> - The point where the crosshair is positioned.</dd>
<dd><code>color</code> - Line color.</dd>
<dd><code>markerType</code> - The specific type of marker you want to use, see #MarkerTypes</dd>
<dd><code>thickness</code> - Line thickness.</dd>
<dd><code>line_type</code> - Type of the line, See #LineTypes</dd>
<dd><code>markerSize</code> - The length of the marker axis [default = 20 pixels]</dd>
</dl>
</li>
</ul>
<a name="ellipse-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Size-double-double-double-org.opencv.core.Scalar-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ellipse</h4>
<pre>public static&nbsp;void&nbsp;ellipse(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                           <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
                           <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;axes,
                           double&nbsp;angle,
                           double&nbsp;startAngle,
                           double&nbsp;endAngle,
                           <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color)</pre>
<div class="block">Draws a simple or thick elliptic arc or fills an ellipse sector.

 The function cv::ellipse with more parameters draws an ellipse outline, a filled ellipse, an elliptic
 arc, or a filled ellipse sector. The drawing code uses general parametric form.
 A piecewise-linear curve is used to approximate the elliptic arc
 boundary. If you need more control of the ellipse rendering, you can retrieve the curve using
 #ellipse2Poly and then render it with #polylines or fill it with #fillPoly. If you use the first
 variant of the function and want to draw the whole ellipse, not an arc, pass <code>startAngle=0</code> and
 <code>endAngle=360</code>. If <code>startAngle</code> is greater than <code>endAngle</code>, they are swapped. The figure below explains
 the meaning of the parameters to draw the blue arc.

 ![Parameters of Elliptic Arc](pics/ellipse.svg)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - Image.</dd>
<dd><code>center</code> - Center of the ellipse.</dd>
<dd><code>axes</code> - Half of the size of the ellipse main axes.</dd>
<dd><code>angle</code> - Ellipse rotation angle in degrees.</dd>
<dd><code>startAngle</code> - Starting angle of the elliptic arc in degrees.</dd>
<dd><code>endAngle</code> - Ending angle of the elliptic arc in degrees.</dd>
<dd><code>color</code> - Ellipse color.
 a filled ellipse sector is to be drawn.</dd>
</dl>
</li>
</ul>
<a name="ellipse-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Size-double-double-double-org.opencv.core.Scalar-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ellipse</h4>
<pre>public static&nbsp;void&nbsp;ellipse(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                           <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
                           <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;axes,
                           double&nbsp;angle,
                           double&nbsp;startAngle,
                           double&nbsp;endAngle,
                           <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
                           int&nbsp;thickness)</pre>
<div class="block">Draws a simple or thick elliptic arc or fills an ellipse sector.

 The function cv::ellipse with more parameters draws an ellipse outline, a filled ellipse, an elliptic
 arc, or a filled ellipse sector. The drawing code uses general parametric form.
 A piecewise-linear curve is used to approximate the elliptic arc
 boundary. If you need more control of the ellipse rendering, you can retrieve the curve using
 #ellipse2Poly and then render it with #polylines or fill it with #fillPoly. If you use the first
 variant of the function and want to draw the whole ellipse, not an arc, pass <code>startAngle=0</code> and
 <code>endAngle=360</code>. If <code>startAngle</code> is greater than <code>endAngle</code>, they are swapped. The figure below explains
 the meaning of the parameters to draw the blue arc.

 ![Parameters of Elliptic Arc](pics/ellipse.svg)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - Image.</dd>
<dd><code>center</code> - Center of the ellipse.</dd>
<dd><code>axes</code> - Half of the size of the ellipse main axes.</dd>
<dd><code>angle</code> - Ellipse rotation angle in degrees.</dd>
<dd><code>startAngle</code> - Starting angle of the elliptic arc in degrees.</dd>
<dd><code>endAngle</code> - Ending angle of the elliptic arc in degrees.</dd>
<dd><code>color</code> - Ellipse color.</dd>
<dd><code>thickness</code> - Thickness of the ellipse arc outline, if positive. Otherwise, this indicates that
 a filled ellipse sector is to be drawn.</dd>
</dl>
</li>
</ul>
<a name="ellipse-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Size-double-double-double-org.opencv.core.Scalar-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ellipse</h4>
<pre>public static&nbsp;void&nbsp;ellipse(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                           <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
                           <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;axes,
                           double&nbsp;angle,
                           double&nbsp;startAngle,
                           double&nbsp;endAngle,
                           <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
                           int&nbsp;thickness,
                           int&nbsp;lineType)</pre>
<div class="block">Draws a simple or thick elliptic arc or fills an ellipse sector.

 The function cv::ellipse with more parameters draws an ellipse outline, a filled ellipse, an elliptic
 arc, or a filled ellipse sector. The drawing code uses general parametric form.
 A piecewise-linear curve is used to approximate the elliptic arc
 boundary. If you need more control of the ellipse rendering, you can retrieve the curve using
 #ellipse2Poly and then render it with #polylines or fill it with #fillPoly. If you use the first
 variant of the function and want to draw the whole ellipse, not an arc, pass <code>startAngle=0</code> and
 <code>endAngle=360</code>. If <code>startAngle</code> is greater than <code>endAngle</code>, they are swapped. The figure below explains
 the meaning of the parameters to draw the blue arc.

 ![Parameters of Elliptic Arc](pics/ellipse.svg)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - Image.</dd>
<dd><code>center</code> - Center of the ellipse.</dd>
<dd><code>axes</code> - Half of the size of the ellipse main axes.</dd>
<dd><code>angle</code> - Ellipse rotation angle in degrees.</dd>
<dd><code>startAngle</code> - Starting angle of the elliptic arc in degrees.</dd>
<dd><code>endAngle</code> - Ending angle of the elliptic arc in degrees.</dd>
<dd><code>color</code> - Ellipse color.</dd>
<dd><code>thickness</code> - Thickness of the ellipse arc outline, if positive. Otherwise, this indicates that
 a filled ellipse sector is to be drawn.</dd>
<dd><code>lineType</code> - Type of the ellipse boundary. See #LineTypes</dd>
</dl>
</li>
</ul>
<a name="ellipse-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Size-double-double-double-org.opencv.core.Scalar-int-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ellipse</h4>
<pre>public static&nbsp;void&nbsp;ellipse(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                           <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
                           <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;axes,
                           double&nbsp;angle,
                           double&nbsp;startAngle,
                           double&nbsp;endAngle,
                           <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
                           int&nbsp;thickness,
                           int&nbsp;lineType,
                           int&nbsp;shift)</pre>
<div class="block">Draws a simple or thick elliptic arc or fills an ellipse sector.

 The function cv::ellipse with more parameters draws an ellipse outline, a filled ellipse, an elliptic
 arc, or a filled ellipse sector. The drawing code uses general parametric form.
 A piecewise-linear curve is used to approximate the elliptic arc
 boundary. If you need more control of the ellipse rendering, you can retrieve the curve using
 #ellipse2Poly and then render it with #polylines or fill it with #fillPoly. If you use the first
 variant of the function and want to draw the whole ellipse, not an arc, pass <code>startAngle=0</code> and
 <code>endAngle=360</code>. If <code>startAngle</code> is greater than <code>endAngle</code>, they are swapped. The figure below explains
 the meaning of the parameters to draw the blue arc.

 ![Parameters of Elliptic Arc](pics/ellipse.svg)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - Image.</dd>
<dd><code>center</code> - Center of the ellipse.</dd>
<dd><code>axes</code> - Half of the size of the ellipse main axes.</dd>
<dd><code>angle</code> - Ellipse rotation angle in degrees.</dd>
<dd><code>startAngle</code> - Starting angle of the elliptic arc in degrees.</dd>
<dd><code>endAngle</code> - Ending angle of the elliptic arc in degrees.</dd>
<dd><code>color</code> - Ellipse color.</dd>
<dd><code>thickness</code> - Thickness of the ellipse arc outline, if positive. Otherwise, this indicates that
 a filled ellipse sector is to be drawn.</dd>
<dd><code>lineType</code> - Type of the ellipse boundary. See #LineTypes</dd>
<dd><code>shift</code> - Number of fractional bits in the coordinates of the center and values of axes.</dd>
</dl>
</li>
</ul>
<a name="ellipse-org.opencv.core.Mat-org.opencv.core.RotatedRect-org.opencv.core.Scalar-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ellipse</h4>
<pre>public static&nbsp;void&nbsp;ellipse(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                           <a href="../../../org/opencv/core/RotatedRect.html" title="class in org.opencv.core">RotatedRect</a>&nbsp;box,
                           <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - Image.</dd>
<dd><code>box</code> - Alternative ellipse representation via RotatedRect. This means that the function draws
 an ellipse inscribed in the rotated rectangle.</dd>
<dd><code>color</code> - Ellipse color.
 a filled ellipse sector is to be drawn.</dd>
</dl>
</li>
</ul>
<a name="ellipse-org.opencv.core.Mat-org.opencv.core.RotatedRect-org.opencv.core.Scalar-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ellipse</h4>
<pre>public static&nbsp;void&nbsp;ellipse(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                           <a href="../../../org/opencv/core/RotatedRect.html" title="class in org.opencv.core">RotatedRect</a>&nbsp;box,
                           <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
                           int&nbsp;thickness)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - Image.</dd>
<dd><code>box</code> - Alternative ellipse representation via RotatedRect. This means that the function draws
 an ellipse inscribed in the rotated rectangle.</dd>
<dd><code>color</code> - Ellipse color.</dd>
<dd><code>thickness</code> - Thickness of the ellipse arc outline, if positive. Otherwise, this indicates that
 a filled ellipse sector is to be drawn.</dd>
</dl>
</li>
</ul>
<a name="ellipse-org.opencv.core.Mat-org.opencv.core.RotatedRect-org.opencv.core.Scalar-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ellipse</h4>
<pre>public static&nbsp;void&nbsp;ellipse(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                           <a href="../../../org/opencv/core/RotatedRect.html" title="class in org.opencv.core">RotatedRect</a>&nbsp;box,
                           <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
                           int&nbsp;thickness,
                           int&nbsp;lineType)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - Image.</dd>
<dd><code>box</code> - Alternative ellipse representation via RotatedRect. This means that the function draws
 an ellipse inscribed in the rotated rectangle.</dd>
<dd><code>color</code> - Ellipse color.</dd>
<dd><code>thickness</code> - Thickness of the ellipse arc outline, if positive. Otherwise, this indicates that
 a filled ellipse sector is to be drawn.</dd>
<dd><code>lineType</code> - Type of the ellipse boundary. See #LineTypes</dd>
</dl>
</li>
</ul>
<a name="ellipse2Poly-org.opencv.core.Point-org.opencv.core.Size-int-int-int-int-org.opencv.core.MatOfPoint-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ellipse2Poly</h4>
<pre>public static&nbsp;void&nbsp;ellipse2Poly(<a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
                                <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;axes,
                                int&nbsp;angle,
                                int&nbsp;arcStart,
                                int&nbsp;arcEnd,
                                int&nbsp;delta,
                                <a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&nbsp;pts)</pre>
<div class="block">Approximates an elliptic arc with a polyline.

 The function ellipse2Poly computes the vertices of a polyline that approximates the specified
 elliptic arc. It is used by #ellipse. If <code>arcStart</code> is greater than <code>arcEnd</code>, they are swapped.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>center</code> - Center of the arc.</dd>
<dd><code>axes</code> - Half of the size of the ellipse main axes. See #ellipse for details.</dd>
<dd><code>angle</code> - Rotation angle of the ellipse in degrees. See #ellipse for details.</dd>
<dd><code>arcStart</code> - Starting angle of the elliptic arc in degrees.</dd>
<dd><code>arcEnd</code> - Ending angle of the elliptic arc in degrees.</dd>
<dd><code>delta</code> - Angle between the subsequent polyline vertices. It defines the approximation
 accuracy.</dd>
<dd><code>pts</code> - Output vector of polyline vertices.</dd>
</dl>
</li>
</ul>
<a name="EMD-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>EMD</h4>
<pre>public static&nbsp;float&nbsp;EMD(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;signature1,
                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;signature2,
                        int&nbsp;distType)</pre>
<div class="block">Computes the "minimal work" distance between two weighted point configurations.

 The function computes the earth mover distance and/or a lower boundary of the distance between the
 two weighted point configurations. One of the applications described in CITE: RubnerSept98,
 CITE: Rubner2000 is multi-dimensional histogram comparison for image retrieval. EMD is a transportation
 problem that is solved using some modification of a simplex algorithm, thus the complexity is
 exponential in the worst case, though, on average it is much faster. In the case of a real metric
 the lower boundary can be calculated even faster (using linear-time algorithm) and it can be used
 to determine roughly whether the two signatures are far enough so that they cannot relate to the
 same object.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>signature1</code> - First signature, a \(\texttt{size1}\times \texttt{dims}+1\) floating-point matrix.
 Each row stores the point weight followed by the point coordinates. The matrix is allowed to have
 a single column (weights only) if the user-defined cost matrix is used. The weights must be
 non-negative and have at least one non-zero value.</dd>
<dd><code>signature2</code> - Second signature of the same format as signature1 , though the number of rows
 may be different. The total weights may be different. In this case an extra "dummy" point is added
 to either signature1 or signature2. The weights must be non-negative and have at least one non-zero
 value.</dd>
<dd><code>distType</code> - Used metric. See #DistanceTypes.
 is used, lower boundary lowerBound cannot be calculated because it needs a metric function.
 signatures that is a distance between mass centers. The lower boundary may not be calculated if
 the user-defined cost matrix is used, the total weights of point configurations are not equal, or
 if the signatures consist of weights only (the signature matrices have a single column). You
 <b>must</b> initialize \*lowerBound . If the calculated distance between mass centers is greater or
 equal to \*lowerBound (it means that the signatures are far enough), the function does not
 calculate EMD. In any case \*lowerBound is set to the calculated distance between mass centers on
 return. Thus, if you want to calculate both distance between mass centers and EMD, \*lowerBound
 should be set to 0.
 a flow from \(i\) -th point of signature1 to \(j\) -th point of signature2 .</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="EMD-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>EMD</h4>
<pre>public static&nbsp;float&nbsp;EMD(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;signature1,
                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;signature2,
                        int&nbsp;distType,
                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cost)</pre>
<div class="block">Computes the "minimal work" distance between two weighted point configurations.

 The function computes the earth mover distance and/or a lower boundary of the distance between the
 two weighted point configurations. One of the applications described in CITE: RubnerSept98,
 CITE: Rubner2000 is multi-dimensional histogram comparison for image retrieval. EMD is a transportation
 problem that is solved using some modification of a simplex algorithm, thus the complexity is
 exponential in the worst case, though, on average it is much faster. In the case of a real metric
 the lower boundary can be calculated even faster (using linear-time algorithm) and it can be used
 to determine roughly whether the two signatures are far enough so that they cannot relate to the
 same object.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>signature1</code> - First signature, a \(\texttt{size1}\times \texttt{dims}+1\) floating-point matrix.
 Each row stores the point weight followed by the point coordinates. The matrix is allowed to have
 a single column (weights only) if the user-defined cost matrix is used. The weights must be
 non-negative and have at least one non-zero value.</dd>
<dd><code>signature2</code> - Second signature of the same format as signature1 , though the number of rows
 may be different. The total weights may be different. In this case an extra "dummy" point is added
 to either signature1 or signature2. The weights must be non-negative and have at least one non-zero
 value.</dd>
<dd><code>distType</code> - Used metric. See #DistanceTypes.</dd>
<dd><code>cost</code> - User-defined \(\texttt{size1}\times \texttt{size2}\) cost matrix. Also, if a cost matrix
 is used, lower boundary lowerBound cannot be calculated because it needs a metric function.
 signatures that is a distance between mass centers. The lower boundary may not be calculated if
 the user-defined cost matrix is used, the total weights of point configurations are not equal, or
 if the signatures consist of weights only (the signature matrices have a single column). You
 <b>must</b> initialize \*lowerBound . If the calculated distance between mass centers is greater or
 equal to \*lowerBound (it means that the signatures are far enough), the function does not
 calculate EMD. In any case \*lowerBound is set to the calculated distance between mass centers on
 return. Thus, if you want to calculate both distance between mass centers and EMD, \*lowerBound
 should be set to 0.
 a flow from \(i\) -th point of signature1 to \(j\) -th point of signature2 .</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="EMD-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>EMD</h4>
<pre>public static&nbsp;float&nbsp;EMD(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;signature1,
                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;signature2,
                        int&nbsp;distType,
                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cost,
                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;flow)</pre>
<div class="block">Computes the "minimal work" distance between two weighted point configurations.

 The function computes the earth mover distance and/or a lower boundary of the distance between the
 two weighted point configurations. One of the applications described in CITE: RubnerSept98,
 CITE: Rubner2000 is multi-dimensional histogram comparison for image retrieval. EMD is a transportation
 problem that is solved using some modification of a simplex algorithm, thus the complexity is
 exponential in the worst case, though, on average it is much faster. In the case of a real metric
 the lower boundary can be calculated even faster (using linear-time algorithm) and it can be used
 to determine roughly whether the two signatures are far enough so that they cannot relate to the
 same object.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>signature1</code> - First signature, a \(\texttt{size1}\times \texttt{dims}+1\) floating-point matrix.
 Each row stores the point weight followed by the point coordinates. The matrix is allowed to have
 a single column (weights only) if the user-defined cost matrix is used. The weights must be
 non-negative and have at least one non-zero value.</dd>
<dd><code>signature2</code> - Second signature of the same format as signature1 , though the number of rows
 may be different. The total weights may be different. In this case an extra "dummy" point is added
 to either signature1 or signature2. The weights must be non-negative and have at least one non-zero
 value.</dd>
<dd><code>distType</code> - Used metric. See #DistanceTypes.</dd>
<dd><code>cost</code> - User-defined \(\texttt{size1}\times \texttt{size2}\) cost matrix. Also, if a cost matrix
 is used, lower boundary lowerBound cannot be calculated because it needs a metric function.
 signatures that is a distance between mass centers. The lower boundary may not be calculated if
 the user-defined cost matrix is used, the total weights of point configurations are not equal, or
 if the signatures consist of weights only (the signature matrices have a single column). You
 <b>must</b> initialize \*lowerBound . If the calculated distance between mass centers is greater or
 equal to \*lowerBound (it means that the signatures are far enough), the function does not
 calculate EMD. In any case \*lowerBound is set to the calculated distance between mass centers on
 return. Thus, if you want to calculate both distance between mass centers and EMD, \*lowerBound
 should be set to 0.</dd>
<dd><code>flow</code> - Resultant \(\texttt{size1} \times \texttt{size2}\) flow matrix: \(\texttt{flow}_{i,j}\) is
 a flow from \(i\) -th point of signature1 to \(j\) -th point of signature2 .</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="equalizeHist-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>equalizeHist</h4>
<pre>public static&nbsp;void&nbsp;equalizeHist(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block">Equalizes the histogram of a grayscale image.

 The function equalizes the histogram of the input image using the following algorithm:

 <ul>
   <li>
  Calculate the histogram \(H\) for src .
   </li>
   <li>
  Normalize the histogram so that the sum of histogram bins is 255.
   </li>
   <li>
  Compute the integral of the histogram:
 \(H'_i =  \sum _{0  \le j &lt; i} H(j)\)
   </li>
   <li>
  Transform the image using \(H'\) as a look-up table: \(\texttt{dst}(x,y) = H'(\texttt{src}(x,y))\)
   </li>
 </ul>

 The algorithm normalizes the brightness and increases the contrast of the image.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Source 8-bit single channel image.</dd>
<dd><code>dst</code> - Destination image of the same size and type as src .</dd>
</dl>
</li>
</ul>
<a name="erode-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>erode</h4>
<pre>public static&nbsp;void&nbsp;erode(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel)</pre>
<div class="block">Erodes an image by using a specific structuring element.

 The function erodes the source image using the specified structuring element that determines the
 shape of a pixel neighborhood over which the minimum is taken:

 \(\texttt{dst} (x,y) =  \min _{(x',y'):  \, \texttt{element} (x',y') \ne0 } \texttt{src} (x+x',y+y')\)

 The function supports the in-place mode. Erosion can be applied several ( iterations ) times. In
 case of multi-channel images, each channel is processed independently.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image; the number of channels can be arbitrary, but the depth should be one of
 CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.</dd>
<dd><code>dst</code> - output image of the same size and type as src.</dd>
<dd><code>kernel</code> - structuring element used for erosion; if <code>element=Mat()</code>, a <code>3 x 3</code> rectangular
 structuring element is used. Kernel can be created using #getStructuringElement.
 anchor is at the element center.
 SEE:  dilate, morphologyEx, getStructuringElement</dd>
</dl>
</li>
</ul>
<a name="erode-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Point-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>erode</h4>
<pre>public static&nbsp;void&nbsp;erode(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel,
                         <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor)</pre>
<div class="block">Erodes an image by using a specific structuring element.

 The function erodes the source image using the specified structuring element that determines the
 shape of a pixel neighborhood over which the minimum is taken:

 \(\texttt{dst} (x,y) =  \min _{(x',y'):  \, \texttt{element} (x',y') \ne0 } \texttt{src} (x+x',y+y')\)

 The function supports the in-place mode. Erosion can be applied several ( iterations ) times. In
 case of multi-channel images, each channel is processed independently.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image; the number of channels can be arbitrary, but the depth should be one of
 CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.</dd>
<dd><code>dst</code> - output image of the same size and type as src.</dd>
<dd><code>kernel</code> - structuring element used for erosion; if <code>element=Mat()</code>, a <code>3 x 3</code> rectangular
 structuring element is used. Kernel can be created using #getStructuringElement.</dd>
<dd><code>anchor</code> - position of the anchor within the element; default value (-1, -1) means that the
 anchor is at the element center.
 SEE:  dilate, morphologyEx, getStructuringElement</dd>
</dl>
</li>
</ul>
<a name="erode-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Point-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>erode</h4>
<pre>public static&nbsp;void&nbsp;erode(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel,
                         <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
                         int&nbsp;iterations)</pre>
<div class="block">Erodes an image by using a specific structuring element.

 The function erodes the source image using the specified structuring element that determines the
 shape of a pixel neighborhood over which the minimum is taken:

 \(\texttt{dst} (x,y) =  \min _{(x',y'):  \, \texttt{element} (x',y') \ne0 } \texttt{src} (x+x',y+y')\)

 The function supports the in-place mode. Erosion can be applied several ( iterations ) times. In
 case of multi-channel images, each channel is processed independently.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image; the number of channels can be arbitrary, but the depth should be one of
 CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.</dd>
<dd><code>dst</code> - output image of the same size and type as src.</dd>
<dd><code>kernel</code> - structuring element used for erosion; if <code>element=Mat()</code>, a <code>3 x 3</code> rectangular
 structuring element is used. Kernel can be created using #getStructuringElement.</dd>
<dd><code>anchor</code> - position of the anchor within the element; default value (-1, -1) means that the
 anchor is at the element center.</dd>
<dd><code>iterations</code> - number of times erosion is applied.
 SEE:  dilate, morphologyEx, getStructuringElement</dd>
</dl>
</li>
</ul>
<a name="erode-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Point-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>erode</h4>
<pre>public static&nbsp;void&nbsp;erode(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel,
                         <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
                         int&nbsp;iterations,
                         int&nbsp;borderType)</pre>
<div class="block">Erodes an image by using a specific structuring element.

 The function erodes the source image using the specified structuring element that determines the
 shape of a pixel neighborhood over which the minimum is taken:

 \(\texttt{dst} (x,y) =  \min _{(x',y'):  \, \texttt{element} (x',y') \ne0 } \texttt{src} (x+x',y+y')\)

 The function supports the in-place mode. Erosion can be applied several ( iterations ) times. In
 case of multi-channel images, each channel is processed independently.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image; the number of channels can be arbitrary, but the depth should be one of
 CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.</dd>
<dd><code>dst</code> - output image of the same size and type as src.</dd>
<dd><code>kernel</code> - structuring element used for erosion; if <code>element=Mat()</code>, a <code>3 x 3</code> rectangular
 structuring element is used. Kernel can be created using #getStructuringElement.</dd>
<dd><code>anchor</code> - position of the anchor within the element; default value (-1, -1) means that the
 anchor is at the element center.</dd>
<dd><code>iterations</code> - number of times erosion is applied.</dd>
<dd><code>borderType</code> - pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported.
 SEE:  dilate, morphologyEx, getStructuringElement</dd>
</dl>
</li>
</ul>
<a name="erode-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Point-int-int-org.opencv.core.Scalar-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>erode</h4>
<pre>public static&nbsp;void&nbsp;erode(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel,
                         <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
                         int&nbsp;iterations,
                         int&nbsp;borderType,
                         <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;borderValue)</pre>
<div class="block">Erodes an image by using a specific structuring element.

 The function erodes the source image using the specified structuring element that determines the
 shape of a pixel neighborhood over which the minimum is taken:

 \(\texttt{dst} (x,y) =  \min _{(x',y'):  \, \texttt{element} (x',y') \ne0 } \texttt{src} (x+x',y+y')\)

 The function supports the in-place mode. Erosion can be applied several ( iterations ) times. In
 case of multi-channel images, each channel is processed independently.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image; the number of channels can be arbitrary, but the depth should be one of
 CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.</dd>
<dd><code>dst</code> - output image of the same size and type as src.</dd>
<dd><code>kernel</code> - structuring element used for erosion; if <code>element=Mat()</code>, a <code>3 x 3</code> rectangular
 structuring element is used. Kernel can be created using #getStructuringElement.</dd>
<dd><code>anchor</code> - position of the anchor within the element; default value (-1, -1) means that the
 anchor is at the element center.</dd>
<dd><code>iterations</code> - number of times erosion is applied.</dd>
<dd><code>borderType</code> - pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported.</dd>
<dd><code>borderValue</code> - border value in case of a constant border
 SEE:  dilate, morphologyEx, getStructuringElement</dd>
</dl>
</li>
</ul>
<a name="fillConvexPoly-org.opencv.core.Mat-org.opencv.core.MatOfPoint-org.opencv.core.Scalar-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fillConvexPoly</h4>
<pre>public static&nbsp;void&nbsp;fillConvexPoly(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                                  <a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&nbsp;points,
                                  <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color)</pre>
<div class="block">Fills a convex polygon.

 The function cv::fillConvexPoly draws a filled convex polygon. This function is much faster than the
 function #fillPoly . It can fill not only convex polygons but any monotonic polygon without
 self-intersections, that is, a polygon whose contour intersects every horizontal line (scan line)
 twice at the most (though, its top-most and/or the bottom edge could be horizontal).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - Image.</dd>
<dd><code>points</code> - Polygon vertices.</dd>
<dd><code>color</code> - Polygon color.</dd>
</dl>
</li>
</ul>
<a name="fillConvexPoly-org.opencv.core.Mat-org.opencv.core.MatOfPoint-org.opencv.core.Scalar-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fillConvexPoly</h4>
<pre>public static&nbsp;void&nbsp;fillConvexPoly(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                                  <a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&nbsp;points,
                                  <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
                                  int&nbsp;lineType)</pre>
<div class="block">Fills a convex polygon.

 The function cv::fillConvexPoly draws a filled convex polygon. This function is much faster than the
 function #fillPoly . It can fill not only convex polygons but any monotonic polygon without
 self-intersections, that is, a polygon whose contour intersects every horizontal line (scan line)
 twice at the most (though, its top-most and/or the bottom edge could be horizontal).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - Image.</dd>
<dd><code>points</code> - Polygon vertices.</dd>
<dd><code>color</code> - Polygon color.</dd>
<dd><code>lineType</code> - Type of the polygon boundaries. See #LineTypes</dd>
</dl>
</li>
</ul>
<a name="fillConvexPoly-org.opencv.core.Mat-org.opencv.core.MatOfPoint-org.opencv.core.Scalar-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fillConvexPoly</h4>
<pre>public static&nbsp;void&nbsp;fillConvexPoly(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                                  <a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&nbsp;points,
                                  <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
                                  int&nbsp;lineType,
                                  int&nbsp;shift)</pre>
<div class="block">Fills a convex polygon.

 The function cv::fillConvexPoly draws a filled convex polygon. This function is much faster than the
 function #fillPoly . It can fill not only convex polygons but any monotonic polygon without
 self-intersections, that is, a polygon whose contour intersects every horizontal line (scan line)
 twice at the most (though, its top-most and/or the bottom edge could be horizontal).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - Image.</dd>
<dd><code>points</code> - Polygon vertices.</dd>
<dd><code>color</code> - Polygon color.</dd>
<dd><code>lineType</code> - Type of the polygon boundaries. See #LineTypes</dd>
<dd><code>shift</code> - Number of fractional bits in the vertex coordinates.</dd>
</dl>
</li>
</ul>
<a name="fillPoly-org.opencv.core.Mat-java.util.List-org.opencv.core.Scalar-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fillPoly</h4>
<pre>public static&nbsp;void&nbsp;fillPoly(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                            java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;pts,
                            <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color)</pre>
<div class="block">Fills the area bounded by one or more polygons.

 The function cv::fillPoly fills an area bounded by several polygonal contours. The function can fill
 complex areas, for example, areas with holes, contours with self-intersections (some of their
 parts), and so forth.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - Image.</dd>
<dd><code>pts</code> - Array of polygons where each polygon is represented as an array of points.</dd>
<dd><code>color</code> - Polygon color.</dd>
</dl>
</li>
</ul>
<a name="fillPoly-org.opencv.core.Mat-java.util.List-org.opencv.core.Scalar-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fillPoly</h4>
<pre>public static&nbsp;void&nbsp;fillPoly(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                            java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;pts,
                            <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
                            int&nbsp;lineType)</pre>
<div class="block">Fills the area bounded by one or more polygons.

 The function cv::fillPoly fills an area bounded by several polygonal contours. The function can fill
 complex areas, for example, areas with holes, contours with self-intersections (some of their
 parts), and so forth.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - Image.</dd>
<dd><code>pts</code> - Array of polygons where each polygon is represented as an array of points.</dd>
<dd><code>color</code> - Polygon color.</dd>
<dd><code>lineType</code> - Type of the polygon boundaries. See #LineTypes</dd>
</dl>
</li>
</ul>
<a name="fillPoly-org.opencv.core.Mat-java.util.List-org.opencv.core.Scalar-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fillPoly</h4>
<pre>public static&nbsp;void&nbsp;fillPoly(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                            java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;pts,
                            <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
                            int&nbsp;lineType,
                            int&nbsp;shift)</pre>
<div class="block">Fills the area bounded by one or more polygons.

 The function cv::fillPoly fills an area bounded by several polygonal contours. The function can fill
 complex areas, for example, areas with holes, contours with self-intersections (some of their
 parts), and so forth.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - Image.</dd>
<dd><code>pts</code> - Array of polygons where each polygon is represented as an array of points.</dd>
<dd><code>color</code> - Polygon color.</dd>
<dd><code>lineType</code> - Type of the polygon boundaries. See #LineTypes</dd>
<dd><code>shift</code> - Number of fractional bits in the vertex coordinates.</dd>
</dl>
</li>
</ul>
<a name="fillPoly-org.opencv.core.Mat-java.util.List-org.opencv.core.Scalar-int-int-org.opencv.core.Point-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fillPoly</h4>
<pre>public static&nbsp;void&nbsp;fillPoly(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                            java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;pts,
                            <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
                            int&nbsp;lineType,
                            int&nbsp;shift,
                            <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;offset)</pre>
<div class="block">Fills the area bounded by one or more polygons.

 The function cv::fillPoly fills an area bounded by several polygonal contours. The function can fill
 complex areas, for example, areas with holes, contours with self-intersections (some of their
 parts), and so forth.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - Image.</dd>
<dd><code>pts</code> - Array of polygons where each polygon is represented as an array of points.</dd>
<dd><code>color</code> - Polygon color.</dd>
<dd><code>lineType</code> - Type of the polygon boundaries. See #LineTypes</dd>
<dd><code>shift</code> - Number of fractional bits in the vertex coordinates.</dd>
<dd><code>offset</code> - Optional offset of all points of the contours.</dd>
</dl>
</li>
</ul>
<a name="filter2D-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filter2D</h4>
<pre>public static&nbsp;void&nbsp;filter2D(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                            int&nbsp;ddepth,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel)</pre>
<div class="block">Convolves an image with the kernel.

 The function applies an arbitrary linear filter to an image. In-place operation is supported. When
 the aperture is partially outside the image, the function interpolates outlier pixel values
 according to the specified border mode.

 The function does actually compute correlation, not the convolution:

 \(\texttt{dst} (x,y) =  \sum _{ \substack{0\leq x' &lt; \texttt{kernel.cols}\\{0\leq y' &lt; \texttt{kernel.rows}}}}  \texttt{kernel} (x',y')* \texttt{src} (x+x'- \texttt{anchor.x} ,y+y'- \texttt{anchor.y} )\)

 That is, the kernel is not mirrored around the anchor point. If you need a real convolution, flip
 the kernel using #flip and set the new anchor to `(kernel.cols - anchor.x - 1, kernel.rows -
 anchor.y - 1)`.

 The function uses the DFT-based algorithm in case of sufficiently large kernels (~<code>11 x 11</code> or
 larger) and the direct algorithm for small kernels.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image.</dd>
<dd><code>dst</code> - output image of the same size and the same number of channels as src.</dd>
<dd><code>ddepth</code> - desired depth of the destination image, see REF: filter_depths "combinations"</dd>
<dd><code>kernel</code> - convolution kernel (or rather a correlation kernel), a single-channel floating point
 matrix; if you want to apply different kernels to different channels, split the image into
 separate color planes using split and process them individually.
 the kernel; the anchor should lie within the kernel; default value (-1,-1) means that the anchor
 is at the kernel center.
 SEE:  sepFilter2D, dft, matchTemplate</dd>
</dl>
</li>
</ul>
<a name="filter2D-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Mat-org.opencv.core.Point-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filter2D</h4>
<pre>public static&nbsp;void&nbsp;filter2D(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                            int&nbsp;ddepth,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel,
                            <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor)</pre>
<div class="block">Convolves an image with the kernel.

 The function applies an arbitrary linear filter to an image. In-place operation is supported. When
 the aperture is partially outside the image, the function interpolates outlier pixel values
 according to the specified border mode.

 The function does actually compute correlation, not the convolution:

 \(\texttt{dst} (x,y) =  \sum _{ \substack{0\leq x' &lt; \texttt{kernel.cols}\\{0\leq y' &lt; \texttt{kernel.rows}}}}  \texttt{kernel} (x',y')* \texttt{src} (x+x'- \texttt{anchor.x} ,y+y'- \texttt{anchor.y} )\)

 That is, the kernel is not mirrored around the anchor point. If you need a real convolution, flip
 the kernel using #flip and set the new anchor to `(kernel.cols - anchor.x - 1, kernel.rows -
 anchor.y - 1)`.

 The function uses the DFT-based algorithm in case of sufficiently large kernels (~<code>11 x 11</code> or
 larger) and the direct algorithm for small kernels.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image.</dd>
<dd><code>dst</code> - output image of the same size and the same number of channels as src.</dd>
<dd><code>ddepth</code> - desired depth of the destination image, see REF: filter_depths "combinations"</dd>
<dd><code>kernel</code> - convolution kernel (or rather a correlation kernel), a single-channel floating point
 matrix; if you want to apply different kernels to different channels, split the image into
 separate color planes using split and process them individually.</dd>
<dd><code>anchor</code> - anchor of the kernel that indicates the relative position of a filtered point within
 the kernel; the anchor should lie within the kernel; default value (-1,-1) means that the anchor
 is at the kernel center.
 SEE:  sepFilter2D, dft, matchTemplate</dd>
</dl>
</li>
</ul>
<a name="filter2D-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Mat-org.opencv.core.Point-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filter2D</h4>
<pre>public static&nbsp;void&nbsp;filter2D(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                            int&nbsp;ddepth,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel,
                            <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
                            double&nbsp;delta)</pre>
<div class="block">Convolves an image with the kernel.

 The function applies an arbitrary linear filter to an image. In-place operation is supported. When
 the aperture is partially outside the image, the function interpolates outlier pixel values
 according to the specified border mode.

 The function does actually compute correlation, not the convolution:

 \(\texttt{dst} (x,y) =  \sum _{ \substack{0\leq x' &lt; \texttt{kernel.cols}\\{0\leq y' &lt; \texttt{kernel.rows}}}}  \texttt{kernel} (x',y')* \texttt{src} (x+x'- \texttt{anchor.x} ,y+y'- \texttt{anchor.y} )\)

 That is, the kernel is not mirrored around the anchor point. If you need a real convolution, flip
 the kernel using #flip and set the new anchor to `(kernel.cols - anchor.x - 1, kernel.rows -
 anchor.y - 1)`.

 The function uses the DFT-based algorithm in case of sufficiently large kernels (~<code>11 x 11</code> or
 larger) and the direct algorithm for small kernels.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image.</dd>
<dd><code>dst</code> - output image of the same size and the same number of channels as src.</dd>
<dd><code>ddepth</code> - desired depth of the destination image, see REF: filter_depths "combinations"</dd>
<dd><code>kernel</code> - convolution kernel (or rather a correlation kernel), a single-channel floating point
 matrix; if you want to apply different kernels to different channels, split the image into
 separate color planes using split and process them individually.</dd>
<dd><code>anchor</code> - anchor of the kernel that indicates the relative position of a filtered point within
 the kernel; the anchor should lie within the kernel; default value (-1,-1) means that the anchor
 is at the kernel center.</dd>
<dd><code>delta</code> - optional value added to the filtered pixels before storing them in dst.
 SEE:  sepFilter2D, dft, matchTemplate</dd>
</dl>
</li>
</ul>
<a name="filter2D-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Mat-org.opencv.core.Point-double-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filter2D</h4>
<pre>public static&nbsp;void&nbsp;filter2D(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                            int&nbsp;ddepth,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel,
                            <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
                            double&nbsp;delta,
                            int&nbsp;borderType)</pre>
<div class="block">Convolves an image with the kernel.

 The function applies an arbitrary linear filter to an image. In-place operation is supported. When
 the aperture is partially outside the image, the function interpolates outlier pixel values
 according to the specified border mode.

 The function does actually compute correlation, not the convolution:

 \(\texttt{dst} (x,y) =  \sum _{ \substack{0\leq x' &lt; \texttt{kernel.cols}\\{0\leq y' &lt; \texttt{kernel.rows}}}}  \texttt{kernel} (x',y')* \texttt{src} (x+x'- \texttt{anchor.x} ,y+y'- \texttt{anchor.y} )\)

 That is, the kernel is not mirrored around the anchor point. If you need a real convolution, flip
 the kernel using #flip and set the new anchor to `(kernel.cols - anchor.x - 1, kernel.rows -
 anchor.y - 1)`.

 The function uses the DFT-based algorithm in case of sufficiently large kernels (~<code>11 x 11</code> or
 larger) and the direct algorithm for small kernels.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image.</dd>
<dd><code>dst</code> - output image of the same size and the same number of channels as src.</dd>
<dd><code>ddepth</code> - desired depth of the destination image, see REF: filter_depths "combinations"</dd>
<dd><code>kernel</code> - convolution kernel (or rather a correlation kernel), a single-channel floating point
 matrix; if you want to apply different kernels to different channels, split the image into
 separate color planes using split and process them individually.</dd>
<dd><code>anchor</code> - anchor of the kernel that indicates the relative position of a filtered point within
 the kernel; the anchor should lie within the kernel; default value (-1,-1) means that the anchor
 is at the kernel center.</dd>
<dd><code>delta</code> - optional value added to the filtered pixels before storing them in dst.</dd>
<dd><code>borderType</code> - pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported.
 SEE:  sepFilter2D, dft, matchTemplate</dd>
</dl>
</li>
</ul>
<a name="findContours-org.opencv.core.Mat-java.util.List-org.opencv.core.Mat-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findContours</h4>
<pre>public static&nbsp;void&nbsp;findContours(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;contours,
                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;hierarchy,
                                int&nbsp;mode,
                                int&nbsp;method)</pre>
<div class="block">Finds contours in a binary image.

 The function retrieves contours from the binary image using the algorithm CITE: Suzuki85 . The contours
 are a useful tool for shape analysis and object detection and recognition. See squares.cpp in the
 OpenCV sample directory.
 <b>Note:</b> Since opencv 3.2 source image is not modified by this function.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - Source, an 8-bit single-channel image. Non-zero pixels are treated as 1's. Zero
 pixels remain 0's, so the image is treated as binary . You can use #compare, #inRange, #threshold ,
 #adaptiveThreshold, #Canny, and others to create a binary image out of a grayscale or color one.
 If mode equals to #RETR_CCOMP or #RETR_FLOODFILL, the input can also be a 32-bit integer image of labels (CV_32SC1).</dd>
<dd><code>contours</code> - Detected contours. Each contour is stored as a vector of points (e.g.
 std::vector&lt;std::vector&lt;cv::Point&gt; &gt;).</dd>
<dd><code>hierarchy</code> - Optional output vector (e.g. std::vector&lt;cv::Vec4i&gt;), containing information about the image topology. It has
 as many elements as the number of contours. For each i-th contour contours[i], the elements
 hierarchy[i][0] , hierarchy[i][1] , hierarchy[i][2] , and hierarchy[i][3] are set to 0-based indices
 in contours of the next and previous contours at the same hierarchical level, the first child
 contour and the parent contour, respectively. If for the contour i there are no next, previous,
 parent, or nested contours, the corresponding elements of hierarchy[i] will be negative.
 <b>Note:</b> In Python, hierarchy is nested inside a top level array. Use hierarchy[0][i] to access hierarchical elements of i-th contour.</dd>
<dd><code>mode</code> - Contour retrieval mode, see #RetrievalModes</dd>
<dd><code>method</code> - Contour approximation method, see #ContourApproximationModes
 contours are extracted from the image ROI and then they should be analyzed in the whole image
 context.</dd>
</dl>
</li>
</ul>
<a name="findContours-org.opencv.core.Mat-java.util.List-org.opencv.core.Mat-int-int-org.opencv.core.Point-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findContours</h4>
<pre>public static&nbsp;void&nbsp;findContours(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;contours,
                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;hierarchy,
                                int&nbsp;mode,
                                int&nbsp;method,
                                <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;offset)</pre>
<div class="block">Finds contours in a binary image.

 The function retrieves contours from the binary image using the algorithm CITE: Suzuki85 . The contours
 are a useful tool for shape analysis and object detection and recognition. See squares.cpp in the
 OpenCV sample directory.
 <b>Note:</b> Since opencv 3.2 source image is not modified by this function.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - Source, an 8-bit single-channel image. Non-zero pixels are treated as 1's. Zero
 pixels remain 0's, so the image is treated as binary . You can use #compare, #inRange, #threshold ,
 #adaptiveThreshold, #Canny, and others to create a binary image out of a grayscale or color one.
 If mode equals to #RETR_CCOMP or #RETR_FLOODFILL, the input can also be a 32-bit integer image of labels (CV_32SC1).</dd>
<dd><code>contours</code> - Detected contours. Each contour is stored as a vector of points (e.g.
 std::vector&lt;std::vector&lt;cv::Point&gt; &gt;).</dd>
<dd><code>hierarchy</code> - Optional output vector (e.g. std::vector&lt;cv::Vec4i&gt;), containing information about the image topology. It has
 as many elements as the number of contours. For each i-th contour contours[i], the elements
 hierarchy[i][0] , hierarchy[i][1] , hierarchy[i][2] , and hierarchy[i][3] are set to 0-based indices
 in contours of the next and previous contours at the same hierarchical level, the first child
 contour and the parent contour, respectively. If for the contour i there are no next, previous,
 parent, or nested contours, the corresponding elements of hierarchy[i] will be negative.
 <b>Note:</b> In Python, hierarchy is nested inside a top level array. Use hierarchy[0][i] to access hierarchical elements of i-th contour.</dd>
<dd><code>mode</code> - Contour retrieval mode, see #RetrievalModes</dd>
<dd><code>method</code> - Contour approximation method, see #ContourApproximationModes</dd>
<dd><code>offset</code> - Optional offset by which every contour point is shifted. This is useful if the
 contours are extracted from the image ROI and then they should be analyzed in the whole image
 context.</dd>
</dl>
</li>
</ul>
<a name="fitEllipse-org.opencv.core.MatOfPoint2f-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fitEllipse</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/RotatedRect.html" title="class in org.opencv.core">RotatedRect</a>&nbsp;fitEllipse(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points)</pre>
<div class="block">Fits an ellipse around a set of 2D points.

 The function calculates the ellipse that fits (in a least-squares sense) a set of 2D points best of
 all. It returns the rotated rectangle in which the ellipse is inscribed. The first algorithm described by CITE: Fitzgibbon95
 is used. Developer should keep in mind that it is possible that the returned
 ellipse/rotatedRect data contains negative indices, due to the data points being close to the
 border of the containing Mat element.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points</code> - Input 2D point set, stored in std::vector&lt;&gt; or Mat</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="fitEllipseAMS-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fitEllipseAMS</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/RotatedRect.html" title="class in org.opencv.core">RotatedRect</a>&nbsp;fitEllipseAMS(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points)</pre>
<div class="block">Fits an ellipse around a set of 2D points.

  The function calculates the ellipse that fits a set of 2D points.
  It returns the rotated rectangle in which the ellipse is inscribed.
  The Approximate Mean Square (AMS) proposed by CITE: Taubin1991 is used.

  For an ellipse, this basis set is \( \chi= \left(x^2, x y, y^2, x, y, 1\right) \),
  which is a set of six free coefficients \( A^T=\left\{A_{\text{xx}},A_{\text{xy}},A_{\text{yy}},A_x,A_y,A_0\right\} \).
  However, to specify an ellipse, all that is needed is five numbers; the major and minor axes lengths \( (a,b) \),
  the position \( (x_0,y_0) \), and the orientation \( \theta \). This is because the basis set includes lines,
  quadratics, parabolic and hyperbolic functions as well as elliptical functions as possible fits.
  If the fit is found to be a parabolic or hyperbolic function then the standard #fitEllipse method is used.
  The AMS method restricts the fit to parabolic, hyperbolic and elliptical curves
  by imposing the condition that \( A^T ( D_x^T D_x  +   D_y^T D_y) A = 1 \) where
  the matrices \( Dx \) and \( Dy \) are the partial derivatives of the design matrix \( D \) with
  respect to x and y. The matrices are formed row by row applying the following to
  each of the points in the set:
  \(align*}{
  D(i,:)&amp;=\left\{x_i^2, x_i y_i, y_i^2, x_i, y_i, 1\right\} &amp;
  D_x(i,:)&amp;=\left\{2 x_i,y_i,0,1,0,0\right\} &amp;
  D_y(i,:)&amp;=\left\{0,x_i,2 y_i,0,1,0\right\}
  \)
  The AMS method minimizes the cost function
  \(equation*}{
  \epsilon ^2=\frac{ A^T D^T D A }{ A^T (D_x^T D_x +  D_y^T D_y) A^T }
  \)

  The minimum cost is found by solving the generalized eigenvalue problem.

  \(equation*}{
  D^T D A = \lambda  \left( D_x^T D_x +  D_y^T D_y\right) A
  \)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points</code> - Input 2D point set, stored in std::vector&lt;&gt; or Mat</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="fitEllipseDirect-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fitEllipseDirect</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/RotatedRect.html" title="class in org.opencv.core">RotatedRect</a>&nbsp;fitEllipseDirect(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points)</pre>
<div class="block">Fits an ellipse around a set of 2D points.

  The function calculates the ellipse that fits a set of 2D points.
  It returns the rotated rectangle in which the ellipse is inscribed.
  The Direct least square (Direct) method by CITE: Fitzgibbon1999 is used.

  For an ellipse, this basis set is \( \chi= \left(x^2, x y, y^2, x, y, 1\right) \),
  which is a set of six free coefficients \( A^T=\left\{A_{\text{xx}},A_{\text{xy}},A_{\text{yy}},A_x,A_y,A_0\right\} \).
  However, to specify an ellipse, all that is needed is five numbers; the major and minor axes lengths \( (a,b) \),
  the position \( (x_0,y_0) \), and the orientation \( \theta \). This is because the basis set includes lines,
  quadratics, parabolic and hyperbolic functions as well as elliptical functions as possible fits.
  The Direct method confines the fit to ellipses by ensuring that \( 4 A_{xx} A_{yy}- A_{xy}^2 &gt; 0 \).
  The condition imposed is that \( 4 A_{xx} A_{yy}- A_{xy}^2=1 \) which satisfies the inequality
  and as the coefficients can be arbitrarily scaled is not overly restrictive.

  \(equation*}{
  \epsilon ^2= A^T D^T D A \quad \text{with} \quad A^T C A =1 \quad \text{and} \quad C=\left(\begin{matrix}
  0 &amp; 0  &amp; 2  &amp; 0  &amp; 0  &amp;  0  \\
  0 &amp; -1  &amp; 0  &amp; 0  &amp; 0  &amp;  0 \\
  2 &amp; 0  &amp; 0  &amp; 0  &amp; 0  &amp;  0 \\
  0 &amp; 0  &amp; 0  &amp; 0  &amp; 0  &amp;  0 \\
  0 &amp; 0  &amp; 0  &amp; 0  &amp; 0  &amp;  0 \\
  0 &amp; 0  &amp; 0  &amp; 0  &amp; 0  &amp;  0
  \end{matrix} \right)
  \)

  The minimum cost is found by solving the generalized eigenvalue problem.

  \(equation*}{
  D^T D A = \lambda  \left( C\right) A
  \)

  The system produces only one positive eigenvalue \( \lambda\) which is chosen as the solution
  with its eigenvector \(\mathbf{u}\). These are used to find the coefficients

  \(equation*}{
  A = \sqrt{\frac{1}{\mathbf{u}^T C \mathbf{u}}}  \mathbf{u}
  \)
  The scaling factor guarantees that  \(A^T C A =1\).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points</code> - Input 2D point set, stored in std::vector&lt;&gt; or Mat</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="fitLine-org.opencv.core.Mat-org.opencv.core.Mat-int-double-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fitLine</h4>
<pre>public static&nbsp;void&nbsp;fitLine(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points,
                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;line,
                           int&nbsp;distType,
                           double&nbsp;param,
                           double&nbsp;reps,
                           double&nbsp;aeps)</pre>
<div class="block">Fits a line to a 2D or 3D point set.

 The function fitLine fits a line to a 2D or 3D point set by minimizing \(\sum_i \rho(r_i)\) where
 \(r_i\) is a distance between the \(i^{th}\) point, the line and \(\rho(r)\) is a distance function, one
 of the following:
 <ul>
   <li>
   DIST_L2
 \(\rho (r) = r^2/2  \quad \text{(the simplest and the fastest least-squares method)}\)
   </li>
   <li>
  DIST_L1
 \(\rho (r) = r\)
   </li>
   <li>
  DIST_L12
 \(\rho (r) = 2  \cdot ( \sqrt{1 + \frac{r^2}{2}} - 1)\)
   </li>
   <li>
  DIST_FAIR
 \(\rho \left (r \right ) = C^2  \cdot \left (  \frac{r}{C} -  \log{\left(1 + \frac{r}{C}\right)} \right )  \quad \text{where} \quad C=1.3998\)
   </li>
   <li>
  DIST_WELSCH
 \(\rho \left (r \right ) =  \frac{C^2}{2} \cdot \left ( 1 -  \exp{\left(-\left(\frac{r}{C}\right)^2\right)} \right )  \quad \text{where} \quad C=2.9846\)
   </li>
   <li>
  DIST_HUBER
 \(\rho (r) =  \fork{r^2/2}{if \(r &lt; C\)}{C \cdot (r-C/2)}{otherwise} \quad \text{where} \quad C=1.345\)
   </li>
 </ul>

 The algorithm is based on the M-estimator ( &lt;http://en.wikipedia.org/wiki/M-estimator&gt; ) technique
 that iteratively fits the line using the weighted least-squares algorithm. After each iteration the
 weights \(w_i\) are adjusted to be inversely proportional to \(\rho(r_i)\) .</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points</code> - Input vector of 2D or 3D points, stored in std::vector&lt;&gt; or Mat.</dd>
<dd><code>line</code> - Output line parameters. In case of 2D fitting, it should be a vector of 4 elements
 (like Vec4f) - (vx, vy, x0, y0), where (vx, vy) is a normalized vector collinear to the line and
 (x0, y0) is a point on the line. In case of 3D fitting, it should be a vector of 6 elements (like
 Vec6f) - (vx, vy, vz, x0, y0, z0), where (vx, vy, vz) is a normalized vector collinear to the line
 and (x0, y0, z0) is a point on the line.</dd>
<dd><code>distType</code> - Distance used by the M-estimator, see #DistanceTypes</dd>
<dd><code>param</code> - Numerical parameter ( C ) for some types of distances. If it is 0, an optimal value
 is chosen.</dd>
<dd><code>reps</code> - Sufficient accuracy for the radius (distance between the coordinate origin and the line).</dd>
<dd><code>aeps</code> - Sufficient accuracy for the angle. 0.01 would be a good default value for reps and aeps.</dd>
</dl>
</li>
</ul>
<a name="floodFill-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Scalar-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>floodFill</h4>
<pre>public static&nbsp;int&nbsp;floodFill(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                            <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;seedPoint,
                            <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;newVal)</pre>
<div class="block">Fills a connected component with the given color.

 The function cv::floodFill fills a connected component starting from the seed point with the specified
 color. The connectivity is determined by the color/brightness closeness of the neighbor pixels. The
 pixel at \((x,y)\) is considered to belong to the repainted domain if:

 <ul>
   <li>
  in case of a grayscale image and floating range
 \(\texttt{src} (x',y')- \texttt{loDiff} \leq \texttt{src} (x,y)  \leq \texttt{src} (x',y')+ \texttt{upDiff}\)
   </li>
 </ul>


 <ul>
   <li>
  in case of a grayscale image and fixed range
 \(\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)- \texttt{loDiff} \leq \texttt{src} (x,y)  \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)+ \texttt{upDiff}\)
   </li>
 </ul>


 <ul>
   <li>
  in case of a color image and floating range
 \(\texttt{src} (x',y')_r- \texttt{loDiff} _r \leq \texttt{src} (x,y)_r \leq \texttt{src} (x',y')_r+ \texttt{upDiff} _r,\)
 \(\texttt{src} (x',y')_g- \texttt{loDiff} _g \leq \texttt{src} (x,y)_g \leq \texttt{src} (x',y')_g+ \texttt{upDiff} _g\)
 and
 \(\texttt{src} (x',y')_b- \texttt{loDiff} _b \leq \texttt{src} (x,y)_b \leq \texttt{src} (x',y')_b+ \texttt{upDiff} _b\)
   </li>
 </ul>


 <ul>
   <li>
  in case of a color image and fixed range
 \(\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_r- \texttt{loDiff} _r \leq \texttt{src} (x,y)_r \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_r+ \texttt{upDiff} _r,\)
 \(\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_g- \texttt{loDiff} _g \leq \texttt{src} (x,y)_g \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_g+ \texttt{upDiff} _g\)
 and
 \(\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_b- \texttt{loDiff} _b \leq \texttt{src} (x,y)_b \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_b+ \texttt{upDiff} _b\)
   </li>
 </ul>


 where \(src(x',y')\) is the value of one of pixel neighbors that is already known to belong to the
 component. That is, to be added to the connected component, a color/brightness of the pixel should
 be close enough to:
 <ul>
   <li>
  Color/brightness of one of its neighbors that already belong to the connected component in case
 of a floating range.
   </li>
   <li>
  Color/brightness of the seed point in case of a fixed range.
   </li>
 </ul>

 Use these functions to either mark a connected component with the specified color in-place, or build
 a mask and then extract the contour, or copy the region to another image, and so on.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - Input/output 1- or 3-channel, 8-bit, or floating-point image. It is modified by the
 function unless the #FLOODFILL_MASK_ONLY flag is set in the second variant of the function. See
 the details below.</dd>
<dd><code>mask</code> - Operation mask that should be a single-channel 8-bit image, 2 pixels wider and 2 pixels
 taller than image. If an empty Mat is passed it will be created automatically. Since this is both an
 input and output parameter, you must take responsibility of initializing it.
 Flood-filling cannot go across non-zero pixels in the input mask. For example,
 an edge detector output can be used as a mask to stop filling at edges. On output, pixels in the
 mask corresponding to filled pixels in the image are set to 1 or to the specified value in flags
 as described below. Additionally, the function fills the border of the mask with ones to simplify
 internal processing. It is therefore possible to use the same mask in multiple calls to the function
 to make sure the filled areas do not overlap.</dd>
<dd><code>seedPoint</code> - Starting point.</dd>
<dd><code>newVal</code> - New value of the repainted domain pixels.
 one of its neighbors belonging to the component, or a seed pixel being added to the component.
 one of its neighbors belonging to the component, or a seed pixel being added to the component.
 repainted domain.
 4 means that only the four nearest neighbor pixels (those that share an edge) are considered. A
 connectivity value of 8 means that the eight nearest neighbor pixels (those that share a corner)
 will be considered. The next 8 bits (8-16) contain a value between 1 and 255 with which to fill
 the mask (the default value is 1). For example, 4 | ( 255 &lt;&lt; 8 ) will consider 4 nearest
 neighbours and fill the mask with a value of 255. The following additional options occupy higher
 bits and therefore may be further combined with the connectivity and mask fill values using
 bit-wise or (|), see #FloodFillFlags.

 <b>Note:</b> Since the mask is larger than the filled image, a pixel \((x, y)\) in image corresponds to the
 pixel \((x+1, y+1)\) in the mask .

 SEE: findContours</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="floodFill-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Scalar-org.opencv.core.Rect-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>floodFill</h4>
<pre>public static&nbsp;int&nbsp;floodFill(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                            <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;seedPoint,
                            <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;newVal,
                            <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;rect)</pre>
<div class="block">Fills a connected component with the given color.

 The function cv::floodFill fills a connected component starting from the seed point with the specified
 color. The connectivity is determined by the color/brightness closeness of the neighbor pixels. The
 pixel at \((x,y)\) is considered to belong to the repainted domain if:

 <ul>
   <li>
  in case of a grayscale image and floating range
 \(\texttt{src} (x',y')- \texttt{loDiff} \leq \texttt{src} (x,y)  \leq \texttt{src} (x',y')+ \texttt{upDiff}\)
   </li>
 </ul>


 <ul>
   <li>
  in case of a grayscale image and fixed range
 \(\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)- \texttt{loDiff} \leq \texttt{src} (x,y)  \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)+ \texttt{upDiff}\)
   </li>
 </ul>


 <ul>
   <li>
  in case of a color image and floating range
 \(\texttt{src} (x',y')_r- \texttt{loDiff} _r \leq \texttt{src} (x,y)_r \leq \texttt{src} (x',y')_r+ \texttt{upDiff} _r,\)
 \(\texttt{src} (x',y')_g- \texttt{loDiff} _g \leq \texttt{src} (x,y)_g \leq \texttt{src} (x',y')_g+ \texttt{upDiff} _g\)
 and
 \(\texttt{src} (x',y')_b- \texttt{loDiff} _b \leq \texttt{src} (x,y)_b \leq \texttt{src} (x',y')_b+ \texttt{upDiff} _b\)
   </li>
 </ul>


 <ul>
   <li>
  in case of a color image and fixed range
 \(\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_r- \texttt{loDiff} _r \leq \texttt{src} (x,y)_r \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_r+ \texttt{upDiff} _r,\)
 \(\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_g- \texttt{loDiff} _g \leq \texttt{src} (x,y)_g \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_g+ \texttt{upDiff} _g\)
 and
 \(\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_b- \texttt{loDiff} _b \leq \texttt{src} (x,y)_b \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_b+ \texttt{upDiff} _b\)
   </li>
 </ul>


 where \(src(x',y')\) is the value of one of pixel neighbors that is already known to belong to the
 component. That is, to be added to the connected component, a color/brightness of the pixel should
 be close enough to:
 <ul>
   <li>
  Color/brightness of one of its neighbors that already belong to the connected component in case
 of a floating range.
   </li>
   <li>
  Color/brightness of the seed point in case of a fixed range.
   </li>
 </ul>

 Use these functions to either mark a connected component with the specified color in-place, or build
 a mask and then extract the contour, or copy the region to another image, and so on.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - Input/output 1- or 3-channel, 8-bit, or floating-point image. It is modified by the
 function unless the #FLOODFILL_MASK_ONLY flag is set in the second variant of the function. See
 the details below.</dd>
<dd><code>mask</code> - Operation mask that should be a single-channel 8-bit image, 2 pixels wider and 2 pixels
 taller than image. If an empty Mat is passed it will be created automatically. Since this is both an
 input and output parameter, you must take responsibility of initializing it.
 Flood-filling cannot go across non-zero pixels in the input mask. For example,
 an edge detector output can be used as a mask to stop filling at edges. On output, pixels in the
 mask corresponding to filled pixels in the image are set to 1 or to the specified value in flags
 as described below. Additionally, the function fills the border of the mask with ones to simplify
 internal processing. It is therefore possible to use the same mask in multiple calls to the function
 to make sure the filled areas do not overlap.</dd>
<dd><code>seedPoint</code> - Starting point.</dd>
<dd><code>newVal</code> - New value of the repainted domain pixels.
 one of its neighbors belonging to the component, or a seed pixel being added to the component.
 one of its neighbors belonging to the component, or a seed pixel being added to the component.</dd>
<dd><code>rect</code> - Optional output parameter set by the function to the minimum bounding rectangle of the
 repainted domain.
 4 means that only the four nearest neighbor pixels (those that share an edge) are considered. A
 connectivity value of 8 means that the eight nearest neighbor pixels (those that share a corner)
 will be considered. The next 8 bits (8-16) contain a value between 1 and 255 with which to fill
 the mask (the default value is 1). For example, 4 | ( 255 &lt;&lt; 8 ) will consider 4 nearest
 neighbours and fill the mask with a value of 255. The following additional options occupy higher
 bits and therefore may be further combined with the connectivity and mask fill values using
 bit-wise or (|), see #FloodFillFlags.

 <b>Note:</b> Since the mask is larger than the filled image, a pixel \((x, y)\) in image corresponds to the
 pixel \((x+1, y+1)\) in the mask .

 SEE: findContours</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="floodFill-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Scalar-org.opencv.core.Rect-org.opencv.core.Scalar-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>floodFill</h4>
<pre>public static&nbsp;int&nbsp;floodFill(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                            <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;seedPoint,
                            <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;newVal,
                            <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;rect,
                            <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;loDiff)</pre>
<div class="block">Fills a connected component with the given color.

 The function cv::floodFill fills a connected component starting from the seed point with the specified
 color. The connectivity is determined by the color/brightness closeness of the neighbor pixels. The
 pixel at \((x,y)\) is considered to belong to the repainted domain if:

 <ul>
   <li>
  in case of a grayscale image and floating range
 \(\texttt{src} (x',y')- \texttt{loDiff} \leq \texttt{src} (x,y)  \leq \texttt{src} (x',y')+ \texttt{upDiff}\)
   </li>
 </ul>


 <ul>
   <li>
  in case of a grayscale image and fixed range
 \(\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)- \texttt{loDiff} \leq \texttt{src} (x,y)  \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)+ \texttt{upDiff}\)
   </li>
 </ul>


 <ul>
   <li>
  in case of a color image and floating range
 \(\texttt{src} (x',y')_r- \texttt{loDiff} _r \leq \texttt{src} (x,y)_r \leq \texttt{src} (x',y')_r+ \texttt{upDiff} _r,\)
 \(\texttt{src} (x',y')_g- \texttt{loDiff} _g \leq \texttt{src} (x,y)_g \leq \texttt{src} (x',y')_g+ \texttt{upDiff} _g\)
 and
 \(\texttt{src} (x',y')_b- \texttt{loDiff} _b \leq \texttt{src} (x,y)_b \leq \texttt{src} (x',y')_b+ \texttt{upDiff} _b\)
   </li>
 </ul>


 <ul>
   <li>
  in case of a color image and fixed range
 \(\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_r- \texttt{loDiff} _r \leq \texttt{src} (x,y)_r \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_r+ \texttt{upDiff} _r,\)
 \(\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_g- \texttt{loDiff} _g \leq \texttt{src} (x,y)_g \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_g+ \texttt{upDiff} _g\)
 and
 \(\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_b- \texttt{loDiff} _b \leq \texttt{src} (x,y)_b \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_b+ \texttt{upDiff} _b\)
   </li>
 </ul>


 where \(src(x',y')\) is the value of one of pixel neighbors that is already known to belong to the
 component. That is, to be added to the connected component, a color/brightness of the pixel should
 be close enough to:
 <ul>
   <li>
  Color/brightness of one of its neighbors that already belong to the connected component in case
 of a floating range.
   </li>
   <li>
  Color/brightness of the seed point in case of a fixed range.
   </li>
 </ul>

 Use these functions to either mark a connected component with the specified color in-place, or build
 a mask and then extract the contour, or copy the region to another image, and so on.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - Input/output 1- or 3-channel, 8-bit, or floating-point image. It is modified by the
 function unless the #FLOODFILL_MASK_ONLY flag is set in the second variant of the function. See
 the details below.</dd>
<dd><code>mask</code> - Operation mask that should be a single-channel 8-bit image, 2 pixels wider and 2 pixels
 taller than image. If an empty Mat is passed it will be created automatically. Since this is both an
 input and output parameter, you must take responsibility of initializing it.
 Flood-filling cannot go across non-zero pixels in the input mask. For example,
 an edge detector output can be used as a mask to stop filling at edges. On output, pixels in the
 mask corresponding to filled pixels in the image are set to 1 or to the specified value in flags
 as described below. Additionally, the function fills the border of the mask with ones to simplify
 internal processing. It is therefore possible to use the same mask in multiple calls to the function
 to make sure the filled areas do not overlap.</dd>
<dd><code>seedPoint</code> - Starting point.</dd>
<dd><code>newVal</code> - New value of the repainted domain pixels.</dd>
<dd><code>loDiff</code> - Maximal lower brightness/color difference between the currently observed pixel and
 one of its neighbors belonging to the component, or a seed pixel being added to the component.
 one of its neighbors belonging to the component, or a seed pixel being added to the component.</dd>
<dd><code>rect</code> - Optional output parameter set by the function to the minimum bounding rectangle of the
 repainted domain.
 4 means that only the four nearest neighbor pixels (those that share an edge) are considered. A
 connectivity value of 8 means that the eight nearest neighbor pixels (those that share a corner)
 will be considered. The next 8 bits (8-16) contain a value between 1 and 255 with which to fill
 the mask (the default value is 1). For example, 4 | ( 255 &lt;&lt; 8 ) will consider 4 nearest
 neighbours and fill the mask with a value of 255. The following additional options occupy higher
 bits and therefore may be further combined with the connectivity and mask fill values using
 bit-wise or (|), see #FloodFillFlags.

 <b>Note:</b> Since the mask is larger than the filled image, a pixel \((x, y)\) in image corresponds to the
 pixel \((x+1, y+1)\) in the mask .

 SEE: findContours</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="floodFill-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Scalar-org.opencv.core.Rect-org.opencv.core.Scalar-org.opencv.core.Scalar-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>floodFill</h4>
<pre>public static&nbsp;int&nbsp;floodFill(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                            <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;seedPoint,
                            <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;newVal,
                            <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;rect,
                            <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;loDiff,
                            <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;upDiff)</pre>
<div class="block">Fills a connected component with the given color.

 The function cv::floodFill fills a connected component starting from the seed point with the specified
 color. The connectivity is determined by the color/brightness closeness of the neighbor pixels. The
 pixel at \((x,y)\) is considered to belong to the repainted domain if:

 <ul>
   <li>
  in case of a grayscale image and floating range
 \(\texttt{src} (x',y')- \texttt{loDiff} \leq \texttt{src} (x,y)  \leq \texttt{src} (x',y')+ \texttt{upDiff}\)
   </li>
 </ul>


 <ul>
   <li>
  in case of a grayscale image and fixed range
 \(\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)- \texttt{loDiff} \leq \texttt{src} (x,y)  \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)+ \texttt{upDiff}\)
   </li>
 </ul>


 <ul>
   <li>
  in case of a color image and floating range
 \(\texttt{src} (x',y')_r- \texttt{loDiff} _r \leq \texttt{src} (x,y)_r \leq \texttt{src} (x',y')_r+ \texttt{upDiff} _r,\)
 \(\texttt{src} (x',y')_g- \texttt{loDiff} _g \leq \texttt{src} (x,y)_g \leq \texttt{src} (x',y')_g+ \texttt{upDiff} _g\)
 and
 \(\texttt{src} (x',y')_b- \texttt{loDiff} _b \leq \texttt{src} (x,y)_b \leq \texttt{src} (x',y')_b+ \texttt{upDiff} _b\)
   </li>
 </ul>


 <ul>
   <li>
  in case of a color image and fixed range
 \(\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_r- \texttt{loDiff} _r \leq \texttt{src} (x,y)_r \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_r+ \texttt{upDiff} _r,\)
 \(\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_g- \texttt{loDiff} _g \leq \texttt{src} (x,y)_g \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_g+ \texttt{upDiff} _g\)
 and
 \(\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_b- \texttt{loDiff} _b \leq \texttt{src} (x,y)_b \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_b+ \texttt{upDiff} _b\)
   </li>
 </ul>


 where \(src(x',y')\) is the value of one of pixel neighbors that is already known to belong to the
 component. That is, to be added to the connected component, a color/brightness of the pixel should
 be close enough to:
 <ul>
   <li>
  Color/brightness of one of its neighbors that already belong to the connected component in case
 of a floating range.
   </li>
   <li>
  Color/brightness of the seed point in case of a fixed range.
   </li>
 </ul>

 Use these functions to either mark a connected component with the specified color in-place, or build
 a mask and then extract the contour, or copy the region to another image, and so on.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - Input/output 1- or 3-channel, 8-bit, or floating-point image. It is modified by the
 function unless the #FLOODFILL_MASK_ONLY flag is set in the second variant of the function. See
 the details below.</dd>
<dd><code>mask</code> - Operation mask that should be a single-channel 8-bit image, 2 pixels wider and 2 pixels
 taller than image. If an empty Mat is passed it will be created automatically. Since this is both an
 input and output parameter, you must take responsibility of initializing it.
 Flood-filling cannot go across non-zero pixels in the input mask. For example,
 an edge detector output can be used as a mask to stop filling at edges. On output, pixels in the
 mask corresponding to filled pixels in the image are set to 1 or to the specified value in flags
 as described below. Additionally, the function fills the border of the mask with ones to simplify
 internal processing. It is therefore possible to use the same mask in multiple calls to the function
 to make sure the filled areas do not overlap.</dd>
<dd><code>seedPoint</code> - Starting point.</dd>
<dd><code>newVal</code> - New value of the repainted domain pixels.</dd>
<dd><code>loDiff</code> - Maximal lower brightness/color difference between the currently observed pixel and
 one of its neighbors belonging to the component, or a seed pixel being added to the component.</dd>
<dd><code>upDiff</code> - Maximal upper brightness/color difference between the currently observed pixel and
 one of its neighbors belonging to the component, or a seed pixel being added to the component.</dd>
<dd><code>rect</code> - Optional output parameter set by the function to the minimum bounding rectangle of the
 repainted domain.
 4 means that only the four nearest neighbor pixels (those that share an edge) are considered. A
 connectivity value of 8 means that the eight nearest neighbor pixels (those that share a corner)
 will be considered. The next 8 bits (8-16) contain a value between 1 and 255 with which to fill
 the mask (the default value is 1). For example, 4 | ( 255 &lt;&lt; 8 ) will consider 4 nearest
 neighbours and fill the mask with a value of 255. The following additional options occupy higher
 bits and therefore may be further combined with the connectivity and mask fill values using
 bit-wise or (|), see #FloodFillFlags.

 <b>Note:</b> Since the mask is larger than the filled image, a pixel \((x, y)\) in image corresponds to the
 pixel \((x+1, y+1)\) in the mask .

 SEE: findContours</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="floodFill-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Scalar-org.opencv.core.Rect-org.opencv.core.Scalar-org.opencv.core.Scalar-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>floodFill</h4>
<pre>public static&nbsp;int&nbsp;floodFill(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                            <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;seedPoint,
                            <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;newVal,
                            <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;rect,
                            <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;loDiff,
                            <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;upDiff,
                            int&nbsp;flags)</pre>
<div class="block">Fills a connected component with the given color.

 The function cv::floodFill fills a connected component starting from the seed point with the specified
 color. The connectivity is determined by the color/brightness closeness of the neighbor pixels. The
 pixel at \((x,y)\) is considered to belong to the repainted domain if:

 <ul>
   <li>
  in case of a grayscale image and floating range
 \(\texttt{src} (x',y')- \texttt{loDiff} \leq \texttt{src} (x,y)  \leq \texttt{src} (x',y')+ \texttt{upDiff}\)
   </li>
 </ul>


 <ul>
   <li>
  in case of a grayscale image and fixed range
 \(\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)- \texttt{loDiff} \leq \texttt{src} (x,y)  \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)+ \texttt{upDiff}\)
   </li>
 </ul>


 <ul>
   <li>
  in case of a color image and floating range
 \(\texttt{src} (x',y')_r- \texttt{loDiff} _r \leq \texttt{src} (x,y)_r \leq \texttt{src} (x',y')_r+ \texttt{upDiff} _r,\)
 \(\texttt{src} (x',y')_g- \texttt{loDiff} _g \leq \texttt{src} (x,y)_g \leq \texttt{src} (x',y')_g+ \texttt{upDiff} _g\)
 and
 \(\texttt{src} (x',y')_b- \texttt{loDiff} _b \leq \texttt{src} (x,y)_b \leq \texttt{src} (x',y')_b+ \texttt{upDiff} _b\)
   </li>
 </ul>


 <ul>
   <li>
  in case of a color image and fixed range
 \(\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_r- \texttt{loDiff} _r \leq \texttt{src} (x,y)_r \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_r+ \texttt{upDiff} _r,\)
 \(\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_g- \texttt{loDiff} _g \leq \texttt{src} (x,y)_g \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_g+ \texttt{upDiff} _g\)
 and
 \(\texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_b- \texttt{loDiff} _b \leq \texttt{src} (x,y)_b \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_b+ \texttt{upDiff} _b\)
   </li>
 </ul>


 where \(src(x',y')\) is the value of one of pixel neighbors that is already known to belong to the
 component. That is, to be added to the connected component, a color/brightness of the pixel should
 be close enough to:
 <ul>
   <li>
  Color/brightness of one of its neighbors that already belong to the connected component in case
 of a floating range.
   </li>
   <li>
  Color/brightness of the seed point in case of a fixed range.
   </li>
 </ul>

 Use these functions to either mark a connected component with the specified color in-place, or build
 a mask and then extract the contour, or copy the region to another image, and so on.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - Input/output 1- or 3-channel, 8-bit, or floating-point image. It is modified by the
 function unless the #FLOODFILL_MASK_ONLY flag is set in the second variant of the function. See
 the details below.</dd>
<dd><code>mask</code> - Operation mask that should be a single-channel 8-bit image, 2 pixels wider and 2 pixels
 taller than image. If an empty Mat is passed it will be created automatically. Since this is both an
 input and output parameter, you must take responsibility of initializing it.
 Flood-filling cannot go across non-zero pixels in the input mask. For example,
 an edge detector output can be used as a mask to stop filling at edges. On output, pixels in the
 mask corresponding to filled pixels in the image are set to 1 or to the specified value in flags
 as described below. Additionally, the function fills the border of the mask with ones to simplify
 internal processing. It is therefore possible to use the same mask in multiple calls to the function
 to make sure the filled areas do not overlap.</dd>
<dd><code>seedPoint</code> - Starting point.</dd>
<dd><code>newVal</code> - New value of the repainted domain pixels.</dd>
<dd><code>loDiff</code> - Maximal lower brightness/color difference between the currently observed pixel and
 one of its neighbors belonging to the component, or a seed pixel being added to the component.</dd>
<dd><code>upDiff</code> - Maximal upper brightness/color difference between the currently observed pixel and
 one of its neighbors belonging to the component, or a seed pixel being added to the component.</dd>
<dd><code>rect</code> - Optional output parameter set by the function to the minimum bounding rectangle of the
 repainted domain.</dd>
<dd><code>flags</code> - Operation flags. The first 8 bits contain a connectivity value. The default value of
 4 means that only the four nearest neighbor pixels (those that share an edge) are considered. A
 connectivity value of 8 means that the eight nearest neighbor pixels (those that share a corner)
 will be considered. The next 8 bits (8-16) contain a value between 1 and 255 with which to fill
 the mask (the default value is 1). For example, 4 | ( 255 &lt;&lt; 8 ) will consider 4 nearest
 neighbours and fill the mask with a value of 255. The following additional options occupy higher
 bits and therefore may be further combined with the connectivity and mask fill values using
 bit-wise or (|), see #FloodFillFlags.

 <b>Note:</b> Since the mask is larger than the filled image, a pixel \((x, y)\) in image corresponds to the
 pixel \((x+1, y+1)\) in the mask .

 SEE: findContours</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="GaussianBlur-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>GaussianBlur</h4>
<pre>public static&nbsp;void&nbsp;GaussianBlur(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
                                double&nbsp;sigmaX)</pre>
<div class="block">Blurs an image using a Gaussian filter.

 The function convolves the source image with the specified Gaussian kernel. In-place filtering is
 supported.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image; the image can have any number of channels, which are processed
 independently, but the depth should be CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.</dd>
<dd><code>dst</code> - output image of the same size and type as src.</dd>
<dd><code>ksize</code> - Gaussian kernel size. ksize.width and ksize.height can differ but they both must be
 positive and odd. Or, they can be zero's and then they are computed from sigma.</dd>
<dd><code>sigmaX</code> - Gaussian kernel standard deviation in X direction.
 equal to sigmaX, if both sigmas are zeros, they are computed from ksize.width and ksize.height,
 respectively (see #getGaussianKernel for details); to fully control the result regardless of
 possible future modifications of all this semantics, it is recommended to specify all of ksize,
 sigmaX, and sigmaY.

 SEE:  sepFilter2D, filter2D, blur, boxFilter, bilateralFilter, medianBlur</dd>
</dl>
</li>
</ul>
<a name="GaussianBlur-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>GaussianBlur</h4>
<pre>public static&nbsp;void&nbsp;GaussianBlur(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
                                double&nbsp;sigmaX,
                                double&nbsp;sigmaY)</pre>
<div class="block">Blurs an image using a Gaussian filter.

 The function convolves the source image with the specified Gaussian kernel. In-place filtering is
 supported.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image; the image can have any number of channels, which are processed
 independently, but the depth should be CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.</dd>
<dd><code>dst</code> - output image of the same size and type as src.</dd>
<dd><code>ksize</code> - Gaussian kernel size. ksize.width and ksize.height can differ but they both must be
 positive and odd. Or, they can be zero's and then they are computed from sigma.</dd>
<dd><code>sigmaX</code> - Gaussian kernel standard deviation in X direction.</dd>
<dd><code>sigmaY</code> - Gaussian kernel standard deviation in Y direction; if sigmaY is zero, it is set to be
 equal to sigmaX, if both sigmas are zeros, they are computed from ksize.width and ksize.height,
 respectively (see #getGaussianKernel for details); to fully control the result regardless of
 possible future modifications of all this semantics, it is recommended to specify all of ksize,
 sigmaX, and sigmaY.

 SEE:  sepFilter2D, filter2D, blur, boxFilter, bilateralFilter, medianBlur</dd>
</dl>
</li>
</ul>
<a name="GaussianBlur-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-double-double-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>GaussianBlur</h4>
<pre>public static&nbsp;void&nbsp;GaussianBlur(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
                                double&nbsp;sigmaX,
                                double&nbsp;sigmaY,
                                int&nbsp;borderType)</pre>
<div class="block">Blurs an image using a Gaussian filter.

 The function convolves the source image with the specified Gaussian kernel. In-place filtering is
 supported.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image; the image can have any number of channels, which are processed
 independently, but the depth should be CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.</dd>
<dd><code>dst</code> - output image of the same size and type as src.</dd>
<dd><code>ksize</code> - Gaussian kernel size. ksize.width and ksize.height can differ but they both must be
 positive and odd. Or, they can be zero's and then they are computed from sigma.</dd>
<dd><code>sigmaX</code> - Gaussian kernel standard deviation in X direction.</dd>
<dd><code>sigmaY</code> - Gaussian kernel standard deviation in Y direction; if sigmaY is zero, it is set to be
 equal to sigmaX, if both sigmas are zeros, they are computed from ksize.width and ksize.height,
 respectively (see #getGaussianKernel for details); to fully control the result regardless of
 possible future modifications of all this semantics, it is recommended to specify all of ksize,
 sigmaX, and sigmaY.</dd>
<dd><code>borderType</code> - pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported.

 SEE:  sepFilter2D, filter2D, blur, boxFilter, bilateralFilter, medianBlur</dd>
</dl>
</li>
</ul>
<a name="getAffineTransform-org.opencv.core.MatOfPoint2f-org.opencv.core.MatOfPoint2f-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getAffineTransform</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;getAffineTransform(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;src,
                                     <a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;dst)</pre>
</li>
</ul>
<a name="getDerivKernels-org.opencv.core.Mat-org.opencv.core.Mat-int-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDerivKernels</h4>
<pre>public static&nbsp;void&nbsp;getDerivKernels(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kx,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;ky,
                                   int&nbsp;dx,
                                   int&nbsp;dy,
                                   int&nbsp;ksize)</pre>
<div class="block">Returns filter coefficients for computing spatial image derivatives.

 The function computes and returns the filter coefficients for spatial image derivatives. When
 <code>ksize=FILTER_SCHARR</code>, the Scharr \(3 \times 3\) kernels are generated (see #Scharr). Otherwise, Sobel
 kernels are generated (see #Sobel). The filters are normally passed to #sepFilter2D or to</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>kx</code> - Output matrix of row filter coefficients. It has the type ktype .</dd>
<dd><code>ky</code> - Output matrix of column filter coefficients. It has the type ktype .</dd>
<dd><code>dx</code> - Derivative order in respect of x.</dd>
<dd><code>dy</code> - Derivative order in respect of y.</dd>
<dd><code>ksize</code> - Aperture size. It can be FILTER_SCHARR, 1, 3, 5, or 7.
 Theoretically, the coefficients should have the denominator \(=2^{ksize*2-dx-dy-2}\). If you are
 going to filter floating-point images, you are likely to use the normalized kernels. But if you
 compute derivatives of an 8-bit image, store the results in a 16-bit image, and wish to preserve
 all the fractional bits, you may want to set normalize=false .</dd>
</dl>
</li>
</ul>
<a name="getDerivKernels-org.opencv.core.Mat-org.opencv.core.Mat-int-int-int-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDerivKernels</h4>
<pre>public static&nbsp;void&nbsp;getDerivKernels(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kx,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;ky,
                                   int&nbsp;dx,
                                   int&nbsp;dy,
                                   int&nbsp;ksize,
                                   boolean&nbsp;normalize)</pre>
<div class="block">Returns filter coefficients for computing spatial image derivatives.

 The function computes and returns the filter coefficients for spatial image derivatives. When
 <code>ksize=FILTER_SCHARR</code>, the Scharr \(3 \times 3\) kernels are generated (see #Scharr). Otherwise, Sobel
 kernels are generated (see #Sobel). The filters are normally passed to #sepFilter2D or to</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>kx</code> - Output matrix of row filter coefficients. It has the type ktype .</dd>
<dd><code>ky</code> - Output matrix of column filter coefficients. It has the type ktype .</dd>
<dd><code>dx</code> - Derivative order in respect of x.</dd>
<dd><code>dy</code> - Derivative order in respect of y.</dd>
<dd><code>ksize</code> - Aperture size. It can be FILTER_SCHARR, 1, 3, 5, or 7.</dd>
<dd><code>normalize</code> - Flag indicating whether to normalize (scale down) the filter coefficients or not.
 Theoretically, the coefficients should have the denominator \(=2^{ksize*2-dx-dy-2}\). If you are
 going to filter floating-point images, you are likely to use the normalized kernels. But if you
 compute derivatives of an 8-bit image, store the results in a 16-bit image, and wish to preserve
 all the fractional bits, you may want to set normalize=false .</dd>
</dl>
</li>
</ul>
<a name="getDerivKernels-org.opencv.core.Mat-org.opencv.core.Mat-int-int-int-boolean-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDerivKernels</h4>
<pre>public static&nbsp;void&nbsp;getDerivKernels(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kx,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;ky,
                                   int&nbsp;dx,
                                   int&nbsp;dy,
                                   int&nbsp;ksize,
                                   boolean&nbsp;normalize,
                                   int&nbsp;ktype)</pre>
<div class="block">Returns filter coefficients for computing spatial image derivatives.

 The function computes and returns the filter coefficients for spatial image derivatives. When
 <code>ksize=FILTER_SCHARR</code>, the Scharr \(3 \times 3\) kernels are generated (see #Scharr). Otherwise, Sobel
 kernels are generated (see #Sobel). The filters are normally passed to #sepFilter2D or to</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>kx</code> - Output matrix of row filter coefficients. It has the type ktype .</dd>
<dd><code>ky</code> - Output matrix of column filter coefficients. It has the type ktype .</dd>
<dd><code>dx</code> - Derivative order in respect of x.</dd>
<dd><code>dy</code> - Derivative order in respect of y.</dd>
<dd><code>ksize</code> - Aperture size. It can be FILTER_SCHARR, 1, 3, 5, or 7.</dd>
<dd><code>normalize</code> - Flag indicating whether to normalize (scale down) the filter coefficients or not.
 Theoretically, the coefficients should have the denominator \(=2^{ksize*2-dx-dy-2}\). If you are
 going to filter floating-point images, you are likely to use the normalized kernels. But if you
 compute derivatives of an 8-bit image, store the results in a 16-bit image, and wish to preserve
 all the fractional bits, you may want to set normalize=false .</dd>
<dd><code>ktype</code> - Type of filter coefficients. It can be CV_32f or CV_64F .</dd>
</dl>
</li>
</ul>
<a name="getFontScaleFromHeight-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getFontScaleFromHeight</h4>
<pre>public static&nbsp;double&nbsp;getFontScaleFromHeight(int&nbsp;fontFace,
                                            int&nbsp;pixelHeight)</pre>
<div class="block">Calculates the font-specific size to use to achieve a given height in pixels.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>fontFace</code> - Font to use, see cv::HersheyFonts.</dd>
<dd><code>pixelHeight</code> - Pixel height to compute the fontScale for</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The fontSize to use for cv::putText

 SEE: cv::putText</dd>
</dl>
</li>
</ul>
<a name="getFontScaleFromHeight-int-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getFontScaleFromHeight</h4>
<pre>public static&nbsp;double&nbsp;getFontScaleFromHeight(int&nbsp;fontFace,
                                            int&nbsp;pixelHeight,
                                            int&nbsp;thickness)</pre>
<div class="block">Calculates the font-specific size to use to achieve a given height in pixels.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>fontFace</code> - Font to use, see cv::HersheyFonts.</dd>
<dd><code>pixelHeight</code> - Pixel height to compute the fontScale for</dd>
<dd><code>thickness</code> - Thickness of lines used to render the text.See putText for details.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The fontSize to use for cv::putText

 SEE: cv::putText</dd>
</dl>
</li>
</ul>
<a name="getGaborKernel-org.opencv.core.Size-double-double-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getGaborKernel</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;getGaborKernel(<a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
                                 double&nbsp;sigma,
                                 double&nbsp;theta,
                                 double&nbsp;lambd,
                                 double&nbsp;gamma)</pre>
<div class="block">Returns Gabor filter coefficients.

 For more details about gabor filter equations and parameters, see: [Gabor
 Filter](http://en.wikipedia.org/wiki/Gabor_filter).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>ksize</code> - Size of the filter returned.</dd>
<dd><code>sigma</code> - Standard deviation of the gaussian envelope.</dd>
<dd><code>theta</code> - Orientation of the normal to the parallel stripes of a Gabor function.</dd>
<dd><code>lambd</code> - Wavelength of the sinusoidal factor.</dd>
<dd><code>gamma</code> - Spatial aspect ratio.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="getGaborKernel-org.opencv.core.Size-double-double-double-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getGaborKernel</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;getGaborKernel(<a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
                                 double&nbsp;sigma,
                                 double&nbsp;theta,
                                 double&nbsp;lambd,
                                 double&nbsp;gamma,
                                 double&nbsp;psi)</pre>
<div class="block">Returns Gabor filter coefficients.

 For more details about gabor filter equations and parameters, see: [Gabor
 Filter](http://en.wikipedia.org/wiki/Gabor_filter).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>ksize</code> - Size of the filter returned.</dd>
<dd><code>sigma</code> - Standard deviation of the gaussian envelope.</dd>
<dd><code>theta</code> - Orientation of the normal to the parallel stripes of a Gabor function.</dd>
<dd><code>lambd</code> - Wavelength of the sinusoidal factor.</dd>
<dd><code>gamma</code> - Spatial aspect ratio.</dd>
<dd><code>psi</code> - Phase offset.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="getGaborKernel-org.opencv.core.Size-double-double-double-double-double-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getGaborKernel</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;getGaborKernel(<a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
                                 double&nbsp;sigma,
                                 double&nbsp;theta,
                                 double&nbsp;lambd,
                                 double&nbsp;gamma,
                                 double&nbsp;psi,
                                 int&nbsp;ktype)</pre>
<div class="block">Returns Gabor filter coefficients.

 For more details about gabor filter equations and parameters, see: [Gabor
 Filter](http://en.wikipedia.org/wiki/Gabor_filter).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>ksize</code> - Size of the filter returned.</dd>
<dd><code>sigma</code> - Standard deviation of the gaussian envelope.</dd>
<dd><code>theta</code> - Orientation of the normal to the parallel stripes of a Gabor function.</dd>
<dd><code>lambd</code> - Wavelength of the sinusoidal factor.</dd>
<dd><code>gamma</code> - Spatial aspect ratio.</dd>
<dd><code>psi</code> - Phase offset.</dd>
<dd><code>ktype</code> - Type of filter coefficients. It can be CV_32F or CV_64F .</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="getGaussianKernel-int-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getGaussianKernel</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;getGaussianKernel(int&nbsp;ksize,
                                    double&nbsp;sigma)</pre>
<div class="block">Returns Gaussian filter coefficients.

 The function computes and returns the \(\texttt{ksize} \times 1\) matrix of Gaussian filter
 coefficients:

 \(G_i= \alpha *e^{-(i-( \texttt{ksize} -1)/2)^2/(2* \texttt{sigma}^2)},\)

 where \(i=0..\texttt{ksize}-1\) and \(\alpha\) is the scale factor chosen so that \(\sum_i G_i=1\).

 Two of such generated kernels can be passed to sepFilter2D. Those functions automatically recognize
 smoothing kernels (a symmetrical kernel with sum of weights equal to 1) and handle them accordingly.
 You may also use the higher-level GaussianBlur.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>ksize</code> - Aperture size. It should be odd ( \(\texttt{ksize} \mod 2 = 1\) ) and positive.</dd>
<dd><code>sigma</code> - Gaussian standard deviation. If it is non-positive, it is computed from ksize as
 <code>sigma = 0.3*((ksize-1)*0.5 - 1) + 0.8</code>.
 SEE:  sepFilter2D, getDerivKernels, getStructuringElement, GaussianBlur</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="getGaussianKernel-int-double-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getGaussianKernel</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;getGaussianKernel(int&nbsp;ksize,
                                    double&nbsp;sigma,
                                    int&nbsp;ktype)</pre>
<div class="block">Returns Gaussian filter coefficients.

 The function computes and returns the \(\texttt{ksize} \times 1\) matrix of Gaussian filter
 coefficients:

 \(G_i= \alpha *e^{-(i-( \texttt{ksize} -1)/2)^2/(2* \texttt{sigma}^2)},\)

 where \(i=0..\texttt{ksize}-1\) and \(\alpha\) is the scale factor chosen so that \(\sum_i G_i=1\).

 Two of such generated kernels can be passed to sepFilter2D. Those functions automatically recognize
 smoothing kernels (a symmetrical kernel with sum of weights equal to 1) and handle them accordingly.
 You may also use the higher-level GaussianBlur.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>ksize</code> - Aperture size. It should be odd ( \(\texttt{ksize} \mod 2 = 1\) ) and positive.</dd>
<dd><code>sigma</code> - Gaussian standard deviation. If it is non-positive, it is computed from ksize as
 <code>sigma = 0.3*((ksize-1)*0.5 - 1) + 0.8</code>.</dd>
<dd><code>ktype</code> - Type of filter coefficients. It can be CV_32F or CV_64F .
 SEE:  sepFilter2D, getDerivKernels, getStructuringElement, GaussianBlur</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="getPerspectiveTransform-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPerspectiveTransform</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;getPerspectiveTransform(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block">Calculates a perspective transform from four pairs of the corresponding points.

 The function calculates the \(3 \times 3\) matrix of a perspective transform so that:

 \(\begin{bmatrix} t_i x'_i \\ t_i y'_i \\ t_i \end{bmatrix} = \texttt{map_matrix} \cdot \begin{bmatrix} x_i \\ y_i \\ 1 \end{bmatrix}\)

 where

 \(dst(i)=(x'_i,y'_i), src(i)=(x_i, y_i), i=0,1,2,3\)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Coordinates of quadrangle vertices in the source image.</dd>
<dd><code>dst</code> - Coordinates of the corresponding quadrangle vertices in the destination image.

 SEE:  findHomography, warpPerspective, perspectiveTransform</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="getPerspectiveTransform-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPerspectiveTransform</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;getPerspectiveTransform(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                          int&nbsp;solveMethod)</pre>
<div class="block">Calculates a perspective transform from four pairs of the corresponding points.

 The function calculates the \(3 \times 3\) matrix of a perspective transform so that:

 \(\begin{bmatrix} t_i x'_i \\ t_i y'_i \\ t_i \end{bmatrix} = \texttt{map_matrix} \cdot \begin{bmatrix} x_i \\ y_i \\ 1 \end{bmatrix}\)

 where

 \(dst(i)=(x'_i,y'_i), src(i)=(x_i, y_i), i=0,1,2,3\)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Coordinates of quadrangle vertices in the source image.</dd>
<dd><code>dst</code> - Coordinates of the corresponding quadrangle vertices in the destination image.</dd>
<dd><code>solveMethod</code> - method passed to cv::solve (#DecompTypes)

 SEE:  findHomography, warpPerspective, perspectiveTransform</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="getRectSubPix-org.opencv.core.Mat-org.opencv.core.Size-org.opencv.core.Point-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRectSubPix</h4>
<pre>public static&nbsp;void&nbsp;getRectSubPix(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                 <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;patchSize,
                                 <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;patch)</pre>
<div class="block">Retrieves a pixel rectangle from an image with sub-pixel accuracy.

 The function getRectSubPix extracts pixels from src:

 \(patch(x, y) = src(x +  \texttt{center.x} - ( \texttt{dst.cols} -1)*0.5, y +  \texttt{center.y} - ( \texttt{dst.rows} -1)*0.5)\)

 where the values of the pixels at non-integer coordinates are retrieved using bilinear
 interpolation. Every channel of multi-channel images is processed independently. Also
 the image should be a single channel or three channel image. While the center of the
 rectangle must be inside the image, parts of the rectangle may be outside.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - Source image.</dd>
<dd><code>patchSize</code> - Size of the extracted patch.</dd>
<dd><code>center</code> - Floating point coordinates of the center of the extracted rectangle within the
 source image. The center must be inside the image.</dd>
<dd><code>patch</code> - Extracted patch that has the size patchSize and the same number of channels as src .

 SEE:  warpAffine, warpPerspective</dd>
</dl>
</li>
</ul>
<a name="getRectSubPix-org.opencv.core.Mat-org.opencv.core.Size-org.opencv.core.Point-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRectSubPix</h4>
<pre>public static&nbsp;void&nbsp;getRectSubPix(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                 <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;patchSize,
                                 <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;patch,
                                 int&nbsp;patchType)</pre>
<div class="block">Retrieves a pixel rectangle from an image with sub-pixel accuracy.

 The function getRectSubPix extracts pixels from src:

 \(patch(x, y) = src(x +  \texttt{center.x} - ( \texttt{dst.cols} -1)*0.5, y +  \texttt{center.y} - ( \texttt{dst.rows} -1)*0.5)\)

 where the values of the pixels at non-integer coordinates are retrieved using bilinear
 interpolation. Every channel of multi-channel images is processed independently. Also
 the image should be a single channel or three channel image. While the center of the
 rectangle must be inside the image, parts of the rectangle may be outside.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - Source image.</dd>
<dd><code>patchSize</code> - Size of the extracted patch.</dd>
<dd><code>center</code> - Floating point coordinates of the center of the extracted rectangle within the
 source image. The center must be inside the image.</dd>
<dd><code>patch</code> - Extracted patch that has the size patchSize and the same number of channels as src .</dd>
<dd><code>patchType</code> - Depth of the extracted pixels. By default, they have the same depth as src .

 SEE:  warpAffine, warpPerspective</dd>
</dl>
</li>
</ul>
<a name="getRotationMatrix2D-org.opencv.core.Point-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRotationMatrix2D</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;getRotationMatrix2D(<a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
                                      double&nbsp;angle,
                                      double&nbsp;scale)</pre>
<div class="block">Calculates an affine matrix of 2D rotation.

 The function calculates the following matrix:

 \(\begin{bmatrix} \alpha &amp;  \beta &amp; (1- \alpha )  \cdot \texttt{center.x} -  \beta \cdot \texttt{center.y} \\ - \beta &amp;  \alpha &amp;  \beta \cdot \texttt{center.x} + (1- \alpha )  \cdot \texttt{center.y} \end{bmatrix}\)

 where

 \(\begin{array}{l} \alpha =  \texttt{scale} \cdot \cos \texttt{angle} , \\ \beta =  \texttt{scale} \cdot \sin \texttt{angle} \end{array}\)

 The transformation maps the rotation center to itself. If this is not the target, adjust the shift.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>center</code> - Center of the rotation in the source image.</dd>
<dd><code>angle</code> - Rotation angle in degrees. Positive values mean counter-clockwise rotation (the
 coordinate origin is assumed to be the top-left corner).</dd>
<dd><code>scale</code> - Isotropic scale factor.

 SEE:  getAffineTransform, warpAffine, transform</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="getStructuringElement-int-org.opencv.core.Size-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getStructuringElement</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;getStructuringElement(int&nbsp;shape,
                                        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize)</pre>
<div class="block">Returns a structuring element of the specified size and shape for morphological operations.

 The function constructs and returns the structuring element that can be further passed to #erode,
 #dilate or #morphologyEx. But you can also construct an arbitrary binary mask yourself and use it as
 the structuring element.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>shape</code> - Element shape that could be one of #MorphShapes</dd>
<dd><code>ksize</code> - Size of the structuring element.
 anchor is at the center. Note that only the shape of a cross-shaped element depends on the anchor
 position. In other cases the anchor just regulates how much the result of the morphological
 operation is shifted.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="getStructuringElement-int-org.opencv.core.Size-org.opencv.core.Point-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getStructuringElement</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;getStructuringElement(int&nbsp;shape,
                                        <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
                                        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor)</pre>
<div class="block">Returns a structuring element of the specified size and shape for morphological operations.

 The function constructs and returns the structuring element that can be further passed to #erode,
 #dilate or #morphologyEx. But you can also construct an arbitrary binary mask yourself and use it as
 the structuring element.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>shape</code> - Element shape that could be one of #MorphShapes</dd>
<dd><code>ksize</code> - Size of the structuring element.</dd>
<dd><code>anchor</code> - Anchor position within the element. The default value \((-1, -1)\) means that the
 anchor is at the center. Note that only the shape of a cross-shaped element depends on the anchor
 position. In other cases the anchor just regulates how much the result of the morphological
 operation is shifted.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="getTextSize-java.lang.String-int-double-int-int:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getTextSize</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;getTextSize(java.lang.String&nbsp;text,
                               int&nbsp;fontFace,
                               double&nbsp;fontScale,
                               int&nbsp;thickness,
                               int[]&nbsp;baseLine)</pre>
</li>
</ul>
<a name="goodFeaturesToTrack-org.opencv.core.Mat-org.opencv.core.MatOfPoint-int-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>goodFeaturesToTrack</h4>
<pre>public static&nbsp;void&nbsp;goodFeaturesToTrack(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                       <a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&nbsp;corners,
                                       int&nbsp;maxCorners,
                                       double&nbsp;qualityLevel,
                                       double&nbsp;minDistance)</pre>
<div class="block">Determines strong corners on an image.

 The function finds the most prominent corners in the image or in the specified image region, as
 described in CITE: Shi94

 <ul>
   <li>
    Function calculates the corner quality measure at every source image pixel using the
     #cornerMinEigenVal or #cornerHarris .
   </li>
   <li>
    Function performs a non-maximum suppression (the local maximums in *3 x 3* neighborhood are
     retained).
   </li>
   <li>
    The corners with the minimal eigenvalue less than
     \(\texttt{qualityLevel} \cdot \max_{x,y} qualityMeasureMap(x,y)\) are rejected.
   </li>
   <li>
    The remaining corners are sorted by the quality measure in the descending order.
   </li>
   <li>
    Function throws away each corner for which there is a stronger corner at a distance less than
     maxDistance.
   </li>
 </ul>

 The function can be used to initialize a point-based tracker of an object.

 <b>Note:</b> If the function is called with different values A and B of the parameter qualityLevel , and
 A &gt; B, the vector of returned corners with qualityLevel=A will be the prefix of the output vector
 with qualityLevel=B .</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - Input 8-bit or floating-point 32-bit, single-channel image.</dd>
<dd><code>corners</code> - Output vector of detected corners.</dd>
<dd><code>maxCorners</code> - Maximum number of corners to return. If there are more corners than are found,
 the strongest of them is returned. <code>maxCorners &amp;lt;= 0</code> implies that no limit on the maximum is set
 and all detected corners are returned.</dd>
<dd><code>qualityLevel</code> - Parameter characterizing the minimal accepted quality of image corners. The
 parameter value is multiplied by the best corner quality measure, which is the minimal eigenvalue
 (see #cornerMinEigenVal ) or the Harris function response (see #cornerHarris ). The corners with the
 quality measure less than the product are rejected. For example, if the best corner has the
 quality measure = 1500, and the qualityLevel=0.01 , then all the corners with the quality measure
 less than 15 are rejected.</dd>
<dd><code>minDistance</code> - Minimum possible Euclidean distance between the returned corners.
 CV_8UC1 and the same size as image ), it specifies the region in which the corners are detected.
 pixel neighborhood. See cornerEigenValsAndVecs .
 or #cornerMinEigenVal.

 SEE:  cornerMinEigenVal, cornerHarris, calcOpticalFlowPyrLK, estimateRigidTransform,</dd>
</dl>
</li>
</ul>
<a name="goodFeaturesToTrack-org.opencv.core.Mat-org.opencv.core.MatOfPoint-int-double-double-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>goodFeaturesToTrack</h4>
<pre>public static&nbsp;void&nbsp;goodFeaturesToTrack(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                       <a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&nbsp;corners,
                                       int&nbsp;maxCorners,
                                       double&nbsp;qualityLevel,
                                       double&nbsp;minDistance,
                                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
<div class="block">Determines strong corners on an image.

 The function finds the most prominent corners in the image or in the specified image region, as
 described in CITE: Shi94

 <ul>
   <li>
    Function calculates the corner quality measure at every source image pixel using the
     #cornerMinEigenVal or #cornerHarris .
   </li>
   <li>
    Function performs a non-maximum suppression (the local maximums in *3 x 3* neighborhood are
     retained).
   </li>
   <li>
    The corners with the minimal eigenvalue less than
     \(\texttt{qualityLevel} \cdot \max_{x,y} qualityMeasureMap(x,y)\) are rejected.
   </li>
   <li>
    The remaining corners are sorted by the quality measure in the descending order.
   </li>
   <li>
    Function throws away each corner for which there is a stronger corner at a distance less than
     maxDistance.
   </li>
 </ul>

 The function can be used to initialize a point-based tracker of an object.

 <b>Note:</b> If the function is called with different values A and B of the parameter qualityLevel , and
 A &gt; B, the vector of returned corners with qualityLevel=A will be the prefix of the output vector
 with qualityLevel=B .</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - Input 8-bit or floating-point 32-bit, single-channel image.</dd>
<dd><code>corners</code> - Output vector of detected corners.</dd>
<dd><code>maxCorners</code> - Maximum number of corners to return. If there are more corners than are found,
 the strongest of them is returned. <code>maxCorners &amp;lt;= 0</code> implies that no limit on the maximum is set
 and all detected corners are returned.</dd>
<dd><code>qualityLevel</code> - Parameter characterizing the minimal accepted quality of image corners. The
 parameter value is multiplied by the best corner quality measure, which is the minimal eigenvalue
 (see #cornerMinEigenVal ) or the Harris function response (see #cornerHarris ). The corners with the
 quality measure less than the product are rejected. For example, if the best corner has the
 quality measure = 1500, and the qualityLevel=0.01 , then all the corners with the quality measure
 less than 15 are rejected.</dd>
<dd><code>minDistance</code> - Minimum possible Euclidean distance between the returned corners.</dd>
<dd><code>mask</code> - Optional region of interest. If the image is not empty (it needs to have the type
 CV_8UC1 and the same size as image ), it specifies the region in which the corners are detected.
 pixel neighborhood. See cornerEigenValsAndVecs .
 or #cornerMinEigenVal.

 SEE:  cornerMinEigenVal, cornerHarris, calcOpticalFlowPyrLK, estimateRigidTransform,</dd>
</dl>
</li>
</ul>
<a name="goodFeaturesToTrack-org.opencv.core.Mat-org.opencv.core.MatOfPoint-int-double-double-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>goodFeaturesToTrack</h4>
<pre>public static&nbsp;void&nbsp;goodFeaturesToTrack(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                       <a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&nbsp;corners,
                                       int&nbsp;maxCorners,
                                       double&nbsp;qualityLevel,
                                       double&nbsp;minDistance,
                                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                                       int&nbsp;blockSize)</pre>
<div class="block">Determines strong corners on an image.

 The function finds the most prominent corners in the image or in the specified image region, as
 described in CITE: Shi94

 <ul>
   <li>
    Function calculates the corner quality measure at every source image pixel using the
     #cornerMinEigenVal or #cornerHarris .
   </li>
   <li>
    Function performs a non-maximum suppression (the local maximums in *3 x 3* neighborhood are
     retained).
   </li>
   <li>
    The corners with the minimal eigenvalue less than
     \(\texttt{qualityLevel} \cdot \max_{x,y} qualityMeasureMap(x,y)\) are rejected.
   </li>
   <li>
    The remaining corners are sorted by the quality measure in the descending order.
   </li>
   <li>
    Function throws away each corner for which there is a stronger corner at a distance less than
     maxDistance.
   </li>
 </ul>

 The function can be used to initialize a point-based tracker of an object.

 <b>Note:</b> If the function is called with different values A and B of the parameter qualityLevel , and
 A &gt; B, the vector of returned corners with qualityLevel=A will be the prefix of the output vector
 with qualityLevel=B .</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - Input 8-bit or floating-point 32-bit, single-channel image.</dd>
<dd><code>corners</code> - Output vector of detected corners.</dd>
<dd><code>maxCorners</code> - Maximum number of corners to return. If there are more corners than are found,
 the strongest of them is returned. <code>maxCorners &amp;lt;= 0</code> implies that no limit on the maximum is set
 and all detected corners are returned.</dd>
<dd><code>qualityLevel</code> - Parameter characterizing the minimal accepted quality of image corners. The
 parameter value is multiplied by the best corner quality measure, which is the minimal eigenvalue
 (see #cornerMinEigenVal ) or the Harris function response (see #cornerHarris ). The corners with the
 quality measure less than the product are rejected. For example, if the best corner has the
 quality measure = 1500, and the qualityLevel=0.01 , then all the corners with the quality measure
 less than 15 are rejected.</dd>
<dd><code>minDistance</code> - Minimum possible Euclidean distance between the returned corners.</dd>
<dd><code>mask</code> - Optional region of interest. If the image is not empty (it needs to have the type
 CV_8UC1 and the same size as image ), it specifies the region in which the corners are detected.</dd>
<dd><code>blockSize</code> - Size of an average block for computing a derivative covariation matrix over each
 pixel neighborhood. See cornerEigenValsAndVecs .
 or #cornerMinEigenVal.

 SEE:  cornerMinEigenVal, cornerHarris, calcOpticalFlowPyrLK, estimateRigidTransform,</dd>
</dl>
</li>
</ul>
<a name="goodFeaturesToTrack-org.opencv.core.Mat-org.opencv.core.MatOfPoint-int-double-double-org.opencv.core.Mat-int-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>goodFeaturesToTrack</h4>
<pre>public static&nbsp;void&nbsp;goodFeaturesToTrack(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                       <a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&nbsp;corners,
                                       int&nbsp;maxCorners,
                                       double&nbsp;qualityLevel,
                                       double&nbsp;minDistance,
                                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                                       int&nbsp;blockSize,
                                       boolean&nbsp;useHarrisDetector)</pre>
<div class="block">Determines strong corners on an image.

 The function finds the most prominent corners in the image or in the specified image region, as
 described in CITE: Shi94

 <ul>
   <li>
    Function calculates the corner quality measure at every source image pixel using the
     #cornerMinEigenVal or #cornerHarris .
   </li>
   <li>
    Function performs a non-maximum suppression (the local maximums in *3 x 3* neighborhood are
     retained).
   </li>
   <li>
    The corners with the minimal eigenvalue less than
     \(\texttt{qualityLevel} \cdot \max_{x,y} qualityMeasureMap(x,y)\) are rejected.
   </li>
   <li>
    The remaining corners are sorted by the quality measure in the descending order.
   </li>
   <li>
    Function throws away each corner for which there is a stronger corner at a distance less than
     maxDistance.
   </li>
 </ul>

 The function can be used to initialize a point-based tracker of an object.

 <b>Note:</b> If the function is called with different values A and B of the parameter qualityLevel , and
 A &gt; B, the vector of returned corners with qualityLevel=A will be the prefix of the output vector
 with qualityLevel=B .</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - Input 8-bit or floating-point 32-bit, single-channel image.</dd>
<dd><code>corners</code> - Output vector of detected corners.</dd>
<dd><code>maxCorners</code> - Maximum number of corners to return. If there are more corners than are found,
 the strongest of them is returned. <code>maxCorners &amp;lt;= 0</code> implies that no limit on the maximum is set
 and all detected corners are returned.</dd>
<dd><code>qualityLevel</code> - Parameter characterizing the minimal accepted quality of image corners. The
 parameter value is multiplied by the best corner quality measure, which is the minimal eigenvalue
 (see #cornerMinEigenVal ) or the Harris function response (see #cornerHarris ). The corners with the
 quality measure less than the product are rejected. For example, if the best corner has the
 quality measure = 1500, and the qualityLevel=0.01 , then all the corners with the quality measure
 less than 15 are rejected.</dd>
<dd><code>minDistance</code> - Minimum possible Euclidean distance between the returned corners.</dd>
<dd><code>mask</code> - Optional region of interest. If the image is not empty (it needs to have the type
 CV_8UC1 and the same size as image ), it specifies the region in which the corners are detected.</dd>
<dd><code>blockSize</code> - Size of an average block for computing a derivative covariation matrix over each
 pixel neighborhood. See cornerEigenValsAndVecs .</dd>
<dd><code>useHarrisDetector</code> - Parameter indicating whether to use a Harris detector (see #cornerHarris)
 or #cornerMinEigenVal.

 SEE:  cornerMinEigenVal, cornerHarris, calcOpticalFlowPyrLK, estimateRigidTransform,</dd>
</dl>
</li>
</ul>
<a name="goodFeaturesToTrack-org.opencv.core.Mat-org.opencv.core.MatOfPoint-int-double-double-org.opencv.core.Mat-int-boolean-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>goodFeaturesToTrack</h4>
<pre>public static&nbsp;void&nbsp;goodFeaturesToTrack(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                       <a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&nbsp;corners,
                                       int&nbsp;maxCorners,
                                       double&nbsp;qualityLevel,
                                       double&nbsp;minDistance,
                                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                                       int&nbsp;blockSize,
                                       boolean&nbsp;useHarrisDetector,
                                       double&nbsp;k)</pre>
<div class="block">Determines strong corners on an image.

 The function finds the most prominent corners in the image or in the specified image region, as
 described in CITE: Shi94

 <ul>
   <li>
    Function calculates the corner quality measure at every source image pixel using the
     #cornerMinEigenVal or #cornerHarris .
   </li>
   <li>
    Function performs a non-maximum suppression (the local maximums in *3 x 3* neighborhood are
     retained).
   </li>
   <li>
    The corners with the minimal eigenvalue less than
     \(\texttt{qualityLevel} \cdot \max_{x,y} qualityMeasureMap(x,y)\) are rejected.
   </li>
   <li>
    The remaining corners are sorted by the quality measure in the descending order.
   </li>
   <li>
    Function throws away each corner for which there is a stronger corner at a distance less than
     maxDistance.
   </li>
 </ul>

 The function can be used to initialize a point-based tracker of an object.

 <b>Note:</b> If the function is called with different values A and B of the parameter qualityLevel , and
 A &gt; B, the vector of returned corners with qualityLevel=A will be the prefix of the output vector
 with qualityLevel=B .</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - Input 8-bit or floating-point 32-bit, single-channel image.</dd>
<dd><code>corners</code> - Output vector of detected corners.</dd>
<dd><code>maxCorners</code> - Maximum number of corners to return. If there are more corners than are found,
 the strongest of them is returned. <code>maxCorners &amp;lt;= 0</code> implies that no limit on the maximum is set
 and all detected corners are returned.</dd>
<dd><code>qualityLevel</code> - Parameter characterizing the minimal accepted quality of image corners. The
 parameter value is multiplied by the best corner quality measure, which is the minimal eigenvalue
 (see #cornerMinEigenVal ) or the Harris function response (see #cornerHarris ). The corners with the
 quality measure less than the product are rejected. For example, if the best corner has the
 quality measure = 1500, and the qualityLevel=0.01 , then all the corners with the quality measure
 less than 15 are rejected.</dd>
<dd><code>minDistance</code> - Minimum possible Euclidean distance between the returned corners.</dd>
<dd><code>mask</code> - Optional region of interest. If the image is not empty (it needs to have the type
 CV_8UC1 and the same size as image ), it specifies the region in which the corners are detected.</dd>
<dd><code>blockSize</code> - Size of an average block for computing a derivative covariation matrix over each
 pixel neighborhood. See cornerEigenValsAndVecs .</dd>
<dd><code>useHarrisDetector</code> - Parameter indicating whether to use a Harris detector (see #cornerHarris)
 or #cornerMinEigenVal.</dd>
<dd><code>k</code> - Free parameter of the Harris detector.

 SEE:  cornerMinEigenVal, cornerHarris, calcOpticalFlowPyrLK, estimateRigidTransform,</dd>
</dl>
</li>
</ul>
<a name="goodFeaturesToTrack-org.opencv.core.Mat-org.opencv.core.MatOfPoint-int-double-double-org.opencv.core.Mat-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>goodFeaturesToTrack</h4>
<pre>public static&nbsp;void&nbsp;goodFeaturesToTrack(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                       <a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&nbsp;corners,
                                       int&nbsp;maxCorners,
                                       double&nbsp;qualityLevel,
                                       double&nbsp;minDistance,
                                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                                       int&nbsp;blockSize,
                                       int&nbsp;gradientSize)</pre>
</li>
</ul>
<a name="goodFeaturesToTrack-org.opencv.core.Mat-org.opencv.core.MatOfPoint-int-double-double-org.opencv.core.Mat-int-int-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>goodFeaturesToTrack</h4>
<pre>public static&nbsp;void&nbsp;goodFeaturesToTrack(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                       <a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&nbsp;corners,
                                       int&nbsp;maxCorners,
                                       double&nbsp;qualityLevel,
                                       double&nbsp;minDistance,
                                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                                       int&nbsp;blockSize,
                                       int&nbsp;gradientSize,
                                       boolean&nbsp;useHarrisDetector)</pre>
</li>
</ul>
<a name="goodFeaturesToTrack-org.opencv.core.Mat-org.opencv.core.MatOfPoint-int-double-double-org.opencv.core.Mat-int-int-boolean-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>goodFeaturesToTrack</h4>
<pre>public static&nbsp;void&nbsp;goodFeaturesToTrack(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                       <a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&nbsp;corners,
                                       int&nbsp;maxCorners,
                                       double&nbsp;qualityLevel,
                                       double&nbsp;minDistance,
                                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                                       int&nbsp;blockSize,
                                       int&nbsp;gradientSize,
                                       boolean&nbsp;useHarrisDetector,
                                       double&nbsp;k)</pre>
</li>
</ul>
<a name="goodFeaturesToTrackWithQuality-org.opencv.core.Mat-org.opencv.core.Mat-int-double-double-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>goodFeaturesToTrackWithQuality</h4>
<pre>public static&nbsp;void&nbsp;goodFeaturesToTrackWithQuality(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;corners,
                                                  int&nbsp;maxCorners,
                                                  double&nbsp;qualityLevel,
                                                  double&nbsp;minDistance,
                                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cornersQuality)</pre>
<div class="block">Same as above, but returns also quality measure of the detected corners.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - Input 8-bit or floating-point 32-bit, single-channel image.</dd>
<dd><code>corners</code> - Output vector of detected corners.</dd>
<dd><code>maxCorners</code> - Maximum number of corners to return. If there are more corners than are found,
 the strongest of them is returned. <code>maxCorners &amp;lt;= 0</code> implies that no limit on the maximum is set
 and all detected corners are returned.</dd>
<dd><code>qualityLevel</code> - Parameter characterizing the minimal accepted quality of image corners. The
 parameter value is multiplied by the best corner quality measure, which is the minimal eigenvalue
 (see #cornerMinEigenVal ) or the Harris function response (see #cornerHarris ). The corners with the
 quality measure less than the product are rejected. For example, if the best corner has the
 quality measure = 1500, and the qualityLevel=0.01 , then all the corners with the quality measure
 less than 15 are rejected.</dd>
<dd><code>minDistance</code> - Minimum possible Euclidean distance between the returned corners.</dd>
<dd><code>mask</code> - Region of interest. If the image is not empty (it needs to have the type
 CV_8UC1 and the same size as image ), it specifies the region in which the corners are detected.</dd>
<dd><code>cornersQuality</code> - Output vector of quality measure of the detected corners.
 pixel neighborhood. See cornerEigenValsAndVecs .
 See cornerEigenValsAndVecs .
 or #cornerMinEigenVal.</dd>
</dl>
</li>
</ul>
<a name="goodFeaturesToTrackWithQuality-org.opencv.core.Mat-org.opencv.core.Mat-int-double-double-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>goodFeaturesToTrackWithQuality</h4>
<pre>public static&nbsp;void&nbsp;goodFeaturesToTrackWithQuality(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;corners,
                                                  int&nbsp;maxCorners,
                                                  double&nbsp;qualityLevel,
                                                  double&nbsp;minDistance,
                                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cornersQuality,
                                                  int&nbsp;blockSize)</pre>
<div class="block">Same as above, but returns also quality measure of the detected corners.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - Input 8-bit or floating-point 32-bit, single-channel image.</dd>
<dd><code>corners</code> - Output vector of detected corners.</dd>
<dd><code>maxCorners</code> - Maximum number of corners to return. If there are more corners than are found,
 the strongest of them is returned. <code>maxCorners &amp;lt;= 0</code> implies that no limit on the maximum is set
 and all detected corners are returned.</dd>
<dd><code>qualityLevel</code> - Parameter characterizing the minimal accepted quality of image corners. The
 parameter value is multiplied by the best corner quality measure, which is the minimal eigenvalue
 (see #cornerMinEigenVal ) or the Harris function response (see #cornerHarris ). The corners with the
 quality measure less than the product are rejected. For example, if the best corner has the
 quality measure = 1500, and the qualityLevel=0.01 , then all the corners with the quality measure
 less than 15 are rejected.</dd>
<dd><code>minDistance</code> - Minimum possible Euclidean distance between the returned corners.</dd>
<dd><code>mask</code> - Region of interest. If the image is not empty (it needs to have the type
 CV_8UC1 and the same size as image ), it specifies the region in which the corners are detected.</dd>
<dd><code>cornersQuality</code> - Output vector of quality measure of the detected corners.</dd>
<dd><code>blockSize</code> - Size of an average block for computing a derivative covariation matrix over each
 pixel neighborhood. See cornerEigenValsAndVecs .
 See cornerEigenValsAndVecs .
 or #cornerMinEigenVal.</dd>
</dl>
</li>
</ul>
<a name="goodFeaturesToTrackWithQuality-org.opencv.core.Mat-org.opencv.core.Mat-int-double-double-org.opencv.core.Mat-org.opencv.core.Mat-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>goodFeaturesToTrackWithQuality</h4>
<pre>public static&nbsp;void&nbsp;goodFeaturesToTrackWithQuality(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;corners,
                                                  int&nbsp;maxCorners,
                                                  double&nbsp;qualityLevel,
                                                  double&nbsp;minDistance,
                                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cornersQuality,
                                                  int&nbsp;blockSize,
                                                  int&nbsp;gradientSize)</pre>
<div class="block">Same as above, but returns also quality measure of the detected corners.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - Input 8-bit or floating-point 32-bit, single-channel image.</dd>
<dd><code>corners</code> - Output vector of detected corners.</dd>
<dd><code>maxCorners</code> - Maximum number of corners to return. If there are more corners than are found,
 the strongest of them is returned. <code>maxCorners &amp;lt;= 0</code> implies that no limit on the maximum is set
 and all detected corners are returned.</dd>
<dd><code>qualityLevel</code> - Parameter characterizing the minimal accepted quality of image corners. The
 parameter value is multiplied by the best corner quality measure, which is the minimal eigenvalue
 (see #cornerMinEigenVal ) or the Harris function response (see #cornerHarris ). The corners with the
 quality measure less than the product are rejected. For example, if the best corner has the
 quality measure = 1500, and the qualityLevel=0.01 , then all the corners with the quality measure
 less than 15 are rejected.</dd>
<dd><code>minDistance</code> - Minimum possible Euclidean distance between the returned corners.</dd>
<dd><code>mask</code> - Region of interest. If the image is not empty (it needs to have the type
 CV_8UC1 and the same size as image ), it specifies the region in which the corners are detected.</dd>
<dd><code>cornersQuality</code> - Output vector of quality measure of the detected corners.</dd>
<dd><code>blockSize</code> - Size of an average block for computing a derivative covariation matrix over each
 pixel neighborhood. See cornerEigenValsAndVecs .</dd>
<dd><code>gradientSize</code> - Aperture parameter for the Sobel operator used for derivatives computation.
 See cornerEigenValsAndVecs .
 or #cornerMinEigenVal.</dd>
</dl>
</li>
</ul>
<a name="goodFeaturesToTrackWithQuality-org.opencv.core.Mat-org.opencv.core.Mat-int-double-double-org.opencv.core.Mat-org.opencv.core.Mat-int-int-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>goodFeaturesToTrackWithQuality</h4>
<pre>public static&nbsp;void&nbsp;goodFeaturesToTrackWithQuality(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;corners,
                                                  int&nbsp;maxCorners,
                                                  double&nbsp;qualityLevel,
                                                  double&nbsp;minDistance,
                                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cornersQuality,
                                                  int&nbsp;blockSize,
                                                  int&nbsp;gradientSize,
                                                  boolean&nbsp;useHarrisDetector)</pre>
<div class="block">Same as above, but returns also quality measure of the detected corners.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - Input 8-bit or floating-point 32-bit, single-channel image.</dd>
<dd><code>corners</code> - Output vector of detected corners.</dd>
<dd><code>maxCorners</code> - Maximum number of corners to return. If there are more corners than are found,
 the strongest of them is returned. <code>maxCorners &amp;lt;= 0</code> implies that no limit on the maximum is set
 and all detected corners are returned.</dd>
<dd><code>qualityLevel</code> - Parameter characterizing the minimal accepted quality of image corners. The
 parameter value is multiplied by the best corner quality measure, which is the minimal eigenvalue
 (see #cornerMinEigenVal ) or the Harris function response (see #cornerHarris ). The corners with the
 quality measure less than the product are rejected. For example, if the best corner has the
 quality measure = 1500, and the qualityLevel=0.01 , then all the corners with the quality measure
 less than 15 are rejected.</dd>
<dd><code>minDistance</code> - Minimum possible Euclidean distance between the returned corners.</dd>
<dd><code>mask</code> - Region of interest. If the image is not empty (it needs to have the type
 CV_8UC1 and the same size as image ), it specifies the region in which the corners are detected.</dd>
<dd><code>cornersQuality</code> - Output vector of quality measure of the detected corners.</dd>
<dd><code>blockSize</code> - Size of an average block for computing a derivative covariation matrix over each
 pixel neighborhood. See cornerEigenValsAndVecs .</dd>
<dd><code>gradientSize</code> - Aperture parameter for the Sobel operator used for derivatives computation.
 See cornerEigenValsAndVecs .</dd>
<dd><code>useHarrisDetector</code> - Parameter indicating whether to use a Harris detector (see #cornerHarris)
 or #cornerMinEigenVal.</dd>
</dl>
</li>
</ul>
<a name="goodFeaturesToTrackWithQuality-org.opencv.core.Mat-org.opencv.core.Mat-int-double-double-org.opencv.core.Mat-org.opencv.core.Mat-int-int-boolean-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>goodFeaturesToTrackWithQuality</h4>
<pre>public static&nbsp;void&nbsp;goodFeaturesToTrackWithQuality(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;corners,
                                                  int&nbsp;maxCorners,
                                                  double&nbsp;qualityLevel,
                                                  double&nbsp;minDistance,
                                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;cornersQuality,
                                                  int&nbsp;blockSize,
                                                  int&nbsp;gradientSize,
                                                  boolean&nbsp;useHarrisDetector,
                                                  double&nbsp;k)</pre>
<div class="block">Same as above, but returns also quality measure of the detected corners.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - Input 8-bit or floating-point 32-bit, single-channel image.</dd>
<dd><code>corners</code> - Output vector of detected corners.</dd>
<dd><code>maxCorners</code> - Maximum number of corners to return. If there are more corners than are found,
 the strongest of them is returned. <code>maxCorners &amp;lt;= 0</code> implies that no limit on the maximum is set
 and all detected corners are returned.</dd>
<dd><code>qualityLevel</code> - Parameter characterizing the minimal accepted quality of image corners. The
 parameter value is multiplied by the best corner quality measure, which is the minimal eigenvalue
 (see #cornerMinEigenVal ) or the Harris function response (see #cornerHarris ). The corners with the
 quality measure less than the product are rejected. For example, if the best corner has the
 quality measure = 1500, and the qualityLevel=0.01 , then all the corners with the quality measure
 less than 15 are rejected.</dd>
<dd><code>minDistance</code> - Minimum possible Euclidean distance between the returned corners.</dd>
<dd><code>mask</code> - Region of interest. If the image is not empty (it needs to have the type
 CV_8UC1 and the same size as image ), it specifies the region in which the corners are detected.</dd>
<dd><code>cornersQuality</code> - Output vector of quality measure of the detected corners.</dd>
<dd><code>blockSize</code> - Size of an average block for computing a derivative covariation matrix over each
 pixel neighborhood. See cornerEigenValsAndVecs .</dd>
<dd><code>gradientSize</code> - Aperture parameter for the Sobel operator used for derivatives computation.
 See cornerEigenValsAndVecs .</dd>
<dd><code>useHarrisDetector</code> - Parameter indicating whether to use a Harris detector (see #cornerHarris)
 or #cornerMinEigenVal.</dd>
<dd><code>k</code> - Free parameter of the Harris detector.</dd>
</dl>
</li>
</ul>
<a name="grabCut-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Rect-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>grabCut</h4>
<pre>public static&nbsp;void&nbsp;grabCut(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                           <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;rect,
                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;bgdModel,
                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;fgdModel,
                           int&nbsp;iterCount)</pre>
<div class="block">Runs the GrabCut algorithm.

 The function implements the [GrabCut image segmentation algorithm](http://en.wikipedia.org/wiki/GrabCut).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - Input 8-bit 3-channel image.</dd>
<dd><code>mask</code> - Input/output 8-bit single-channel mask. The mask is initialized by the function when
 mode is set to #GC_INIT_WITH_RECT. Its elements may have one of the #GrabCutClasses.</dd>
<dd><code>rect</code> - ROI containing a segmented object. The pixels outside of the ROI are marked as
 "obvious background". The parameter is only used when mode==#GC_INIT_WITH_RECT .</dd>
<dd><code>bgdModel</code> - Temporary array for the background model. Do not modify it while you are
 processing the same image.</dd>
<dd><code>fgdModel</code> - Temporary arrays for the foreground model. Do not modify it while you are
 processing the same image.</dd>
<dd><code>iterCount</code> - Number of iterations the algorithm should make before returning the result. Note
 that the result can be refined with further calls with mode==#GC_INIT_WITH_MASK or
 mode==GC_EVAL .</dd>
</dl>
</li>
</ul>
<a name="grabCut-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Rect-org.opencv.core.Mat-org.opencv.core.Mat-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>grabCut</h4>
<pre>public static&nbsp;void&nbsp;grabCut(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                           <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;rect,
                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;bgdModel,
                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;fgdModel,
                           int&nbsp;iterCount,
                           int&nbsp;mode)</pre>
<div class="block">Runs the GrabCut algorithm.

 The function implements the [GrabCut image segmentation algorithm](http://en.wikipedia.org/wiki/GrabCut).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - Input 8-bit 3-channel image.</dd>
<dd><code>mask</code> - Input/output 8-bit single-channel mask. The mask is initialized by the function when
 mode is set to #GC_INIT_WITH_RECT. Its elements may have one of the #GrabCutClasses.</dd>
<dd><code>rect</code> - ROI containing a segmented object. The pixels outside of the ROI are marked as
 "obvious background". The parameter is only used when mode==#GC_INIT_WITH_RECT .</dd>
<dd><code>bgdModel</code> - Temporary array for the background model. Do not modify it while you are
 processing the same image.</dd>
<dd><code>fgdModel</code> - Temporary arrays for the foreground model. Do not modify it while you are
 processing the same image.</dd>
<dd><code>iterCount</code> - Number of iterations the algorithm should make before returning the result. Note
 that the result can be refined with further calls with mode==#GC_INIT_WITH_MASK or
 mode==GC_EVAL .</dd>
<dd><code>mode</code> - Operation mode that could be one of the #GrabCutModes</dd>
</dl>
</li>
</ul>
<a name="HoughCircles-org.opencv.core.Mat-org.opencv.core.Mat-int-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>HoughCircles</h4>
<pre>public static&nbsp;void&nbsp;HoughCircles(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;circles,
                                int&nbsp;method,
                                double&nbsp;dp,
                                double&nbsp;minDist)</pre>
<div class="block">Finds circles in a grayscale image using the Hough transform.

 The function finds circles in a grayscale image using a modification of the Hough transform.

 Example: :
 INCLUDE: snippets/imgproc_HoughLinesCircles.cpp

 <b>Note:</b> Usually the function detects the centers of circles well. However, it may fail to find correct
 radii. You can assist to the function by specifying the radius range ( minRadius and maxRadius ) if
 you know it. Or, in the case of #HOUGH_GRADIENT method you may set maxRadius to a negative number
 to return centers only without radius search, and find the correct radius using an additional procedure.

 It also helps to smooth image a bit unless it's already soft. For example,
 GaussianBlur() with 7x7 kernel and 1.5x1.5 sigma or similar blurring may help.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - 8-bit, single-channel, grayscale input image.</dd>
<dd><code>circles</code> - Output vector of found circles. Each vector is encoded as  3 or 4 element
 floating-point vector \((x, y, radius)\) or \((x, y, radius, votes)\) .</dd>
<dd><code>method</code> - Detection method, see #HoughModes. The available methods are #HOUGH_GRADIENT and #HOUGH_GRADIENT_ALT.</dd>
<dd><code>dp</code> - Inverse ratio of the accumulator resolution to the image resolution. For example, if
 dp=1 , the accumulator has the same resolution as the input image. If dp=2 , the accumulator has
 half as big width and height. For #HOUGH_GRADIENT_ALT the recommended value is dp=1.5,
 unless some small very circles need to be detected.</dd>
<dd><code>minDist</code> - Minimum distance between the centers of the detected circles. If the parameter is
 too small, multiple neighbor circles may be falsely detected in addition to a true one. If it is
 too large, some circles may be missed.
 it is the higher threshold of the two passed to the Canny edge detector (the lower one is twice smaller).
 Note that #HOUGH_GRADIENT_ALT uses #Scharr algorithm to compute image derivatives, so the threshold value
 shough normally be higher, such as 300 or normally exposed and contrasty images.
 accumulator threshold for the circle centers at the detection stage. The smaller it is, the more
 false circles may be detected. Circles, corresponding to the larger accumulator values, will be
 returned first. In the case of #HOUGH_GRADIENT_ALT algorithm, this is the circle "perfectness" measure.
 The closer it to 1, the better shaped circles algorithm selects. In most cases 0.9 should be fine.
 If you want get better detection of small circles, you may decrease it to 0.85, 0.8 or even less.
 But then also try to limit the search range [minRadius, maxRadius] to avoid many false circles.
 centers without finding the radius. #HOUGH_GRADIENT_ALT always computes circle radiuses.

 SEE: fitEllipse, minEnclosingCircle</dd>
</dl>
</li>
</ul>
<a name="HoughCircles-org.opencv.core.Mat-org.opencv.core.Mat-int-double-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>HoughCircles</h4>
<pre>public static&nbsp;void&nbsp;HoughCircles(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;circles,
                                int&nbsp;method,
                                double&nbsp;dp,
                                double&nbsp;minDist,
                                double&nbsp;param1)</pre>
<div class="block">Finds circles in a grayscale image using the Hough transform.

 The function finds circles in a grayscale image using a modification of the Hough transform.

 Example: :
 INCLUDE: snippets/imgproc_HoughLinesCircles.cpp

 <b>Note:</b> Usually the function detects the centers of circles well. However, it may fail to find correct
 radii. You can assist to the function by specifying the radius range ( minRadius and maxRadius ) if
 you know it. Or, in the case of #HOUGH_GRADIENT method you may set maxRadius to a negative number
 to return centers only without radius search, and find the correct radius using an additional procedure.

 It also helps to smooth image a bit unless it's already soft. For example,
 GaussianBlur() with 7x7 kernel and 1.5x1.5 sigma or similar blurring may help.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - 8-bit, single-channel, grayscale input image.</dd>
<dd><code>circles</code> - Output vector of found circles. Each vector is encoded as  3 or 4 element
 floating-point vector \((x, y, radius)\) or \((x, y, radius, votes)\) .</dd>
<dd><code>method</code> - Detection method, see #HoughModes. The available methods are #HOUGH_GRADIENT and #HOUGH_GRADIENT_ALT.</dd>
<dd><code>dp</code> - Inverse ratio of the accumulator resolution to the image resolution. For example, if
 dp=1 , the accumulator has the same resolution as the input image. If dp=2 , the accumulator has
 half as big width and height. For #HOUGH_GRADIENT_ALT the recommended value is dp=1.5,
 unless some small very circles need to be detected.</dd>
<dd><code>minDist</code> - Minimum distance between the centers of the detected circles. If the parameter is
 too small, multiple neighbor circles may be falsely detected in addition to a true one. If it is
 too large, some circles may be missed.</dd>
<dd><code>param1</code> - First method-specific parameter. In case of #HOUGH_GRADIENT and #HOUGH_GRADIENT_ALT,
 it is the higher threshold of the two passed to the Canny edge detector (the lower one is twice smaller).
 Note that #HOUGH_GRADIENT_ALT uses #Scharr algorithm to compute image derivatives, so the threshold value
 shough normally be higher, such as 300 or normally exposed and contrasty images.
 accumulator threshold for the circle centers at the detection stage. The smaller it is, the more
 false circles may be detected. Circles, corresponding to the larger accumulator values, will be
 returned first. In the case of #HOUGH_GRADIENT_ALT algorithm, this is the circle "perfectness" measure.
 The closer it to 1, the better shaped circles algorithm selects. In most cases 0.9 should be fine.
 If you want get better detection of small circles, you may decrease it to 0.85, 0.8 or even less.
 But then also try to limit the search range [minRadius, maxRadius] to avoid many false circles.
 centers without finding the radius. #HOUGH_GRADIENT_ALT always computes circle radiuses.

 SEE: fitEllipse, minEnclosingCircle</dd>
</dl>
</li>
</ul>
<a name="HoughCircles-org.opencv.core.Mat-org.opencv.core.Mat-int-double-double-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>HoughCircles</h4>
<pre>public static&nbsp;void&nbsp;HoughCircles(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;circles,
                                int&nbsp;method,
                                double&nbsp;dp,
                                double&nbsp;minDist,
                                double&nbsp;param1,
                                double&nbsp;param2)</pre>
<div class="block">Finds circles in a grayscale image using the Hough transform.

 The function finds circles in a grayscale image using a modification of the Hough transform.

 Example: :
 INCLUDE: snippets/imgproc_HoughLinesCircles.cpp

 <b>Note:</b> Usually the function detects the centers of circles well. However, it may fail to find correct
 radii. You can assist to the function by specifying the radius range ( minRadius and maxRadius ) if
 you know it. Or, in the case of #HOUGH_GRADIENT method you may set maxRadius to a negative number
 to return centers only without radius search, and find the correct radius using an additional procedure.

 It also helps to smooth image a bit unless it's already soft. For example,
 GaussianBlur() with 7x7 kernel and 1.5x1.5 sigma or similar blurring may help.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - 8-bit, single-channel, grayscale input image.</dd>
<dd><code>circles</code> - Output vector of found circles. Each vector is encoded as  3 or 4 element
 floating-point vector \((x, y, radius)\) or \((x, y, radius, votes)\) .</dd>
<dd><code>method</code> - Detection method, see #HoughModes. The available methods are #HOUGH_GRADIENT and #HOUGH_GRADIENT_ALT.</dd>
<dd><code>dp</code> - Inverse ratio of the accumulator resolution to the image resolution. For example, if
 dp=1 , the accumulator has the same resolution as the input image. If dp=2 , the accumulator has
 half as big width and height. For #HOUGH_GRADIENT_ALT the recommended value is dp=1.5,
 unless some small very circles need to be detected.</dd>
<dd><code>minDist</code> - Minimum distance between the centers of the detected circles. If the parameter is
 too small, multiple neighbor circles may be falsely detected in addition to a true one. If it is
 too large, some circles may be missed.</dd>
<dd><code>param1</code> - First method-specific parameter. In case of #HOUGH_GRADIENT and #HOUGH_GRADIENT_ALT,
 it is the higher threshold of the two passed to the Canny edge detector (the lower one is twice smaller).
 Note that #HOUGH_GRADIENT_ALT uses #Scharr algorithm to compute image derivatives, so the threshold value
 shough normally be higher, such as 300 or normally exposed and contrasty images.</dd>
<dd><code>param2</code> - Second method-specific parameter. In case of #HOUGH_GRADIENT, it is the
 accumulator threshold for the circle centers at the detection stage. The smaller it is, the more
 false circles may be detected. Circles, corresponding to the larger accumulator values, will be
 returned first. In the case of #HOUGH_GRADIENT_ALT algorithm, this is the circle "perfectness" measure.
 The closer it to 1, the better shaped circles algorithm selects. In most cases 0.9 should be fine.
 If you want get better detection of small circles, you may decrease it to 0.85, 0.8 or even less.
 But then also try to limit the search range [minRadius, maxRadius] to avoid many false circles.
 centers without finding the radius. #HOUGH_GRADIENT_ALT always computes circle radiuses.

 SEE: fitEllipse, minEnclosingCircle</dd>
</dl>
</li>
</ul>
<a name="HoughCircles-org.opencv.core.Mat-org.opencv.core.Mat-int-double-double-double-double-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>HoughCircles</h4>
<pre>public static&nbsp;void&nbsp;HoughCircles(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;circles,
                                int&nbsp;method,
                                double&nbsp;dp,
                                double&nbsp;minDist,
                                double&nbsp;param1,
                                double&nbsp;param2,
                                int&nbsp;minRadius)</pre>
<div class="block">Finds circles in a grayscale image using the Hough transform.

 The function finds circles in a grayscale image using a modification of the Hough transform.

 Example: :
 INCLUDE: snippets/imgproc_HoughLinesCircles.cpp

 <b>Note:</b> Usually the function detects the centers of circles well. However, it may fail to find correct
 radii. You can assist to the function by specifying the radius range ( minRadius and maxRadius ) if
 you know it. Or, in the case of #HOUGH_GRADIENT method you may set maxRadius to a negative number
 to return centers only without radius search, and find the correct radius using an additional procedure.

 It also helps to smooth image a bit unless it's already soft. For example,
 GaussianBlur() with 7x7 kernel and 1.5x1.5 sigma or similar blurring may help.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - 8-bit, single-channel, grayscale input image.</dd>
<dd><code>circles</code> - Output vector of found circles. Each vector is encoded as  3 or 4 element
 floating-point vector \((x, y, radius)\) or \((x, y, radius, votes)\) .</dd>
<dd><code>method</code> - Detection method, see #HoughModes. The available methods are #HOUGH_GRADIENT and #HOUGH_GRADIENT_ALT.</dd>
<dd><code>dp</code> - Inverse ratio of the accumulator resolution to the image resolution. For example, if
 dp=1 , the accumulator has the same resolution as the input image. If dp=2 , the accumulator has
 half as big width and height. For #HOUGH_GRADIENT_ALT the recommended value is dp=1.5,
 unless some small very circles need to be detected.</dd>
<dd><code>minDist</code> - Minimum distance between the centers of the detected circles. If the parameter is
 too small, multiple neighbor circles may be falsely detected in addition to a true one. If it is
 too large, some circles may be missed.</dd>
<dd><code>param1</code> - First method-specific parameter. In case of #HOUGH_GRADIENT and #HOUGH_GRADIENT_ALT,
 it is the higher threshold of the two passed to the Canny edge detector (the lower one is twice smaller).
 Note that #HOUGH_GRADIENT_ALT uses #Scharr algorithm to compute image derivatives, so the threshold value
 shough normally be higher, such as 300 or normally exposed and contrasty images.</dd>
<dd><code>param2</code> - Second method-specific parameter. In case of #HOUGH_GRADIENT, it is the
 accumulator threshold for the circle centers at the detection stage. The smaller it is, the more
 false circles may be detected. Circles, corresponding to the larger accumulator values, will be
 returned first. In the case of #HOUGH_GRADIENT_ALT algorithm, this is the circle "perfectness" measure.
 The closer it to 1, the better shaped circles algorithm selects. In most cases 0.9 should be fine.
 If you want get better detection of small circles, you may decrease it to 0.85, 0.8 or even less.
 But then also try to limit the search range [minRadius, maxRadius] to avoid many false circles.</dd>
<dd><code>minRadius</code> - Minimum circle radius.
 centers without finding the radius. #HOUGH_GRADIENT_ALT always computes circle radiuses.

 SEE: fitEllipse, minEnclosingCircle</dd>
</dl>
</li>
</ul>
<a name="HoughCircles-org.opencv.core.Mat-org.opencv.core.Mat-int-double-double-double-double-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>HoughCircles</h4>
<pre>public static&nbsp;void&nbsp;HoughCircles(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;circles,
                                int&nbsp;method,
                                double&nbsp;dp,
                                double&nbsp;minDist,
                                double&nbsp;param1,
                                double&nbsp;param2,
                                int&nbsp;minRadius,
                                int&nbsp;maxRadius)</pre>
<div class="block">Finds circles in a grayscale image using the Hough transform.

 The function finds circles in a grayscale image using a modification of the Hough transform.

 Example: :
 INCLUDE: snippets/imgproc_HoughLinesCircles.cpp

 <b>Note:</b> Usually the function detects the centers of circles well. However, it may fail to find correct
 radii. You can assist to the function by specifying the radius range ( minRadius and maxRadius ) if
 you know it. Or, in the case of #HOUGH_GRADIENT method you may set maxRadius to a negative number
 to return centers only without radius search, and find the correct radius using an additional procedure.

 It also helps to smooth image a bit unless it's already soft. For example,
 GaussianBlur() with 7x7 kernel and 1.5x1.5 sigma or similar blurring may help.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - 8-bit, single-channel, grayscale input image.</dd>
<dd><code>circles</code> - Output vector of found circles. Each vector is encoded as  3 or 4 element
 floating-point vector \((x, y, radius)\) or \((x, y, radius, votes)\) .</dd>
<dd><code>method</code> - Detection method, see #HoughModes. The available methods are #HOUGH_GRADIENT and #HOUGH_GRADIENT_ALT.</dd>
<dd><code>dp</code> - Inverse ratio of the accumulator resolution to the image resolution. For example, if
 dp=1 , the accumulator has the same resolution as the input image. If dp=2 , the accumulator has
 half as big width and height. For #HOUGH_GRADIENT_ALT the recommended value is dp=1.5,
 unless some small very circles need to be detected.</dd>
<dd><code>minDist</code> - Minimum distance between the centers of the detected circles. If the parameter is
 too small, multiple neighbor circles may be falsely detected in addition to a true one. If it is
 too large, some circles may be missed.</dd>
<dd><code>param1</code> - First method-specific parameter. In case of #HOUGH_GRADIENT and #HOUGH_GRADIENT_ALT,
 it is the higher threshold of the two passed to the Canny edge detector (the lower one is twice smaller).
 Note that #HOUGH_GRADIENT_ALT uses #Scharr algorithm to compute image derivatives, so the threshold value
 shough normally be higher, such as 300 or normally exposed and contrasty images.</dd>
<dd><code>param2</code> - Second method-specific parameter. In case of #HOUGH_GRADIENT, it is the
 accumulator threshold for the circle centers at the detection stage. The smaller it is, the more
 false circles may be detected. Circles, corresponding to the larger accumulator values, will be
 returned first. In the case of #HOUGH_GRADIENT_ALT algorithm, this is the circle "perfectness" measure.
 The closer it to 1, the better shaped circles algorithm selects. In most cases 0.9 should be fine.
 If you want get better detection of small circles, you may decrease it to 0.85, 0.8 or even less.
 But then also try to limit the search range [minRadius, maxRadius] to avoid many false circles.</dd>
<dd><code>minRadius</code> - Minimum circle radius.</dd>
<dd><code>maxRadius</code> - Maximum circle radius. If &lt;= 0, uses the maximum image dimension. If &lt; 0, #HOUGH_GRADIENT returns
 centers without finding the radius. #HOUGH_GRADIENT_ALT always computes circle radiuses.

 SEE: fitEllipse, minEnclosingCircle</dd>
</dl>
</li>
</ul>
<a name="HoughLines-org.opencv.core.Mat-org.opencv.core.Mat-double-double-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>HoughLines</h4>
<pre>public static&nbsp;void&nbsp;HoughLines(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;lines,
                              double&nbsp;rho,
                              double&nbsp;theta,
                              int&nbsp;threshold)</pre>
<div class="block">Finds lines in a binary image using the standard Hough transform.

 The function implements the standard or standard multi-scale Hough transform algorithm for line
 detection. See &lt;http://homepages.inf.ed.ac.uk/rbf/HIPR2/hough.htm&gt; for a good explanation of Hough
 transform.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - 8-bit, single-channel binary source image. The image may be modified by the function.</dd>
<dd><code>lines</code> - Output vector of lines. Each line is represented by a 2 or 3 element vector
 \((\rho, \theta)\) or \((\rho, \theta, \textrm{votes})\), where \(\rho\) is the distance from
 the coordinate origin \((0,0)\) (top-left corner of the image), \(\theta\) is the line rotation
 angle in radians ( \(0 \sim \textrm{vertical line}, \pi/2 \sim \textrm{horizontal line}\) ), and
 \(\textrm{votes}\) is the value of accumulator.</dd>
<dd><code>rho</code> - Distance resolution of the accumulator in pixels.</dd>
<dd><code>theta</code> - Angle resolution of the accumulator in radians.</dd>
<dd><code>threshold</code> - %Accumulator threshold parameter. Only those lines are returned that get enough
 votes ( \(&gt;\texttt{threshold}\) ).
 The coarse accumulator distance resolution is rho and the accurate accumulator resolution is
 rho/srn. If both srn=0 and stn=0, the classical Hough transform is used. Otherwise, both these
 parameters should be positive.
 Must fall between 0 and max_theta.
 Must fall between min_theta and CV_PI. The actual maximum angle in the accumulator may be slightly
 less than max_theta, depending on the parameters min_theta and theta.</dd>
</dl>
</li>
</ul>
<a name="HoughLines-org.opencv.core.Mat-org.opencv.core.Mat-double-double-int-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>HoughLines</h4>
<pre>public static&nbsp;void&nbsp;HoughLines(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;lines,
                              double&nbsp;rho,
                              double&nbsp;theta,
                              int&nbsp;threshold,
                              double&nbsp;srn)</pre>
<div class="block">Finds lines in a binary image using the standard Hough transform.

 The function implements the standard or standard multi-scale Hough transform algorithm for line
 detection. See &lt;http://homepages.inf.ed.ac.uk/rbf/HIPR2/hough.htm&gt; for a good explanation of Hough
 transform.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - 8-bit, single-channel binary source image. The image may be modified by the function.</dd>
<dd><code>lines</code> - Output vector of lines. Each line is represented by a 2 or 3 element vector
 \((\rho, \theta)\) or \((\rho, \theta, \textrm{votes})\), where \(\rho\) is the distance from
 the coordinate origin \((0,0)\) (top-left corner of the image), \(\theta\) is the line rotation
 angle in radians ( \(0 \sim \textrm{vertical line}, \pi/2 \sim \textrm{horizontal line}\) ), and
 \(\textrm{votes}\) is the value of accumulator.</dd>
<dd><code>rho</code> - Distance resolution of the accumulator in pixels.</dd>
<dd><code>theta</code> - Angle resolution of the accumulator in radians.</dd>
<dd><code>threshold</code> - %Accumulator threshold parameter. Only those lines are returned that get enough
 votes ( \(&gt;\texttt{threshold}\) ).</dd>
<dd><code>srn</code> - For the multi-scale Hough transform, it is a divisor for the distance resolution rho.
 The coarse accumulator distance resolution is rho and the accurate accumulator resolution is
 rho/srn. If both srn=0 and stn=0, the classical Hough transform is used. Otherwise, both these
 parameters should be positive.
 Must fall between 0 and max_theta.
 Must fall between min_theta and CV_PI. The actual maximum angle in the accumulator may be slightly
 less than max_theta, depending on the parameters min_theta and theta.</dd>
</dl>
</li>
</ul>
<a name="HoughLines-org.opencv.core.Mat-org.opencv.core.Mat-double-double-int-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>HoughLines</h4>
<pre>public static&nbsp;void&nbsp;HoughLines(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;lines,
                              double&nbsp;rho,
                              double&nbsp;theta,
                              int&nbsp;threshold,
                              double&nbsp;srn,
                              double&nbsp;stn)</pre>
<div class="block">Finds lines in a binary image using the standard Hough transform.

 The function implements the standard or standard multi-scale Hough transform algorithm for line
 detection. See &lt;http://homepages.inf.ed.ac.uk/rbf/HIPR2/hough.htm&gt; for a good explanation of Hough
 transform.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - 8-bit, single-channel binary source image. The image may be modified by the function.</dd>
<dd><code>lines</code> - Output vector of lines. Each line is represented by a 2 or 3 element vector
 \((\rho, \theta)\) or \((\rho, \theta, \textrm{votes})\), where \(\rho\) is the distance from
 the coordinate origin \((0,0)\) (top-left corner of the image), \(\theta\) is the line rotation
 angle in radians ( \(0 \sim \textrm{vertical line}, \pi/2 \sim \textrm{horizontal line}\) ), and
 \(\textrm{votes}\) is the value of accumulator.</dd>
<dd><code>rho</code> - Distance resolution of the accumulator in pixels.</dd>
<dd><code>theta</code> - Angle resolution of the accumulator in radians.</dd>
<dd><code>threshold</code> - %Accumulator threshold parameter. Only those lines are returned that get enough
 votes ( \(&gt;\texttt{threshold}\) ).</dd>
<dd><code>srn</code> - For the multi-scale Hough transform, it is a divisor for the distance resolution rho.
 The coarse accumulator distance resolution is rho and the accurate accumulator resolution is
 rho/srn. If both srn=0 and stn=0, the classical Hough transform is used. Otherwise, both these
 parameters should be positive.</dd>
<dd><code>stn</code> - For the multi-scale Hough transform, it is a divisor for the distance resolution theta.
 Must fall between 0 and max_theta.
 Must fall between min_theta and CV_PI. The actual maximum angle in the accumulator may be slightly
 less than max_theta, depending on the parameters min_theta and theta.</dd>
</dl>
</li>
</ul>
<a name="HoughLines-org.opencv.core.Mat-org.opencv.core.Mat-double-double-int-double-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>HoughLines</h4>
<pre>public static&nbsp;void&nbsp;HoughLines(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;lines,
                              double&nbsp;rho,
                              double&nbsp;theta,
                              int&nbsp;threshold,
                              double&nbsp;srn,
                              double&nbsp;stn,
                              double&nbsp;min_theta)</pre>
<div class="block">Finds lines in a binary image using the standard Hough transform.

 The function implements the standard or standard multi-scale Hough transform algorithm for line
 detection. See &lt;http://homepages.inf.ed.ac.uk/rbf/HIPR2/hough.htm&gt; for a good explanation of Hough
 transform.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - 8-bit, single-channel binary source image. The image may be modified by the function.</dd>
<dd><code>lines</code> - Output vector of lines. Each line is represented by a 2 or 3 element vector
 \((\rho, \theta)\) or \((\rho, \theta, \textrm{votes})\), where \(\rho\) is the distance from
 the coordinate origin \((0,0)\) (top-left corner of the image), \(\theta\) is the line rotation
 angle in radians ( \(0 \sim \textrm{vertical line}, \pi/2 \sim \textrm{horizontal line}\) ), and
 \(\textrm{votes}\) is the value of accumulator.</dd>
<dd><code>rho</code> - Distance resolution of the accumulator in pixels.</dd>
<dd><code>theta</code> - Angle resolution of the accumulator in radians.</dd>
<dd><code>threshold</code> - %Accumulator threshold parameter. Only those lines are returned that get enough
 votes ( \(&gt;\texttt{threshold}\) ).</dd>
<dd><code>srn</code> - For the multi-scale Hough transform, it is a divisor for the distance resolution rho.
 The coarse accumulator distance resolution is rho and the accurate accumulator resolution is
 rho/srn. If both srn=0 and stn=0, the classical Hough transform is used. Otherwise, both these
 parameters should be positive.</dd>
<dd><code>stn</code> - For the multi-scale Hough transform, it is a divisor for the distance resolution theta.</dd>
<dd><code>min_theta</code> - For standard and multi-scale Hough transform, minimum angle to check for lines.
 Must fall between 0 and max_theta.
 Must fall between min_theta and CV_PI. The actual maximum angle in the accumulator may be slightly
 less than max_theta, depending on the parameters min_theta and theta.</dd>
</dl>
</li>
</ul>
<a name="HoughLines-org.opencv.core.Mat-org.opencv.core.Mat-double-double-int-double-double-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>HoughLines</h4>
<pre>public static&nbsp;void&nbsp;HoughLines(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;lines,
                              double&nbsp;rho,
                              double&nbsp;theta,
                              int&nbsp;threshold,
                              double&nbsp;srn,
                              double&nbsp;stn,
                              double&nbsp;min_theta,
                              double&nbsp;max_theta)</pre>
<div class="block">Finds lines in a binary image using the standard Hough transform.

 The function implements the standard or standard multi-scale Hough transform algorithm for line
 detection. See &lt;http://homepages.inf.ed.ac.uk/rbf/HIPR2/hough.htm&gt; for a good explanation of Hough
 transform.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - 8-bit, single-channel binary source image. The image may be modified by the function.</dd>
<dd><code>lines</code> - Output vector of lines. Each line is represented by a 2 or 3 element vector
 \((\rho, \theta)\) or \((\rho, \theta, \textrm{votes})\), where \(\rho\) is the distance from
 the coordinate origin \((0,0)\) (top-left corner of the image), \(\theta\) is the line rotation
 angle in radians ( \(0 \sim \textrm{vertical line}, \pi/2 \sim \textrm{horizontal line}\) ), and
 \(\textrm{votes}\) is the value of accumulator.</dd>
<dd><code>rho</code> - Distance resolution of the accumulator in pixels.</dd>
<dd><code>theta</code> - Angle resolution of the accumulator in radians.</dd>
<dd><code>threshold</code> - %Accumulator threshold parameter. Only those lines are returned that get enough
 votes ( \(&gt;\texttt{threshold}\) ).</dd>
<dd><code>srn</code> - For the multi-scale Hough transform, it is a divisor for the distance resolution rho.
 The coarse accumulator distance resolution is rho and the accurate accumulator resolution is
 rho/srn. If both srn=0 and stn=0, the classical Hough transform is used. Otherwise, both these
 parameters should be positive.</dd>
<dd><code>stn</code> - For the multi-scale Hough transform, it is a divisor for the distance resolution theta.</dd>
<dd><code>min_theta</code> - For standard and multi-scale Hough transform, minimum angle to check for lines.
 Must fall between 0 and max_theta.</dd>
<dd><code>max_theta</code> - For standard and multi-scale Hough transform, an upper bound for the angle.
 Must fall between min_theta and CV_PI. The actual maximum angle in the accumulator may be slightly
 less than max_theta, depending on the parameters min_theta and theta.</dd>
</dl>
</li>
</ul>
<a name="HoughLinesP-org.opencv.core.Mat-org.opencv.core.Mat-double-double-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>HoughLinesP</h4>
<pre>public static&nbsp;void&nbsp;HoughLinesP(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;lines,
                               double&nbsp;rho,
                               double&nbsp;theta,
                               int&nbsp;threshold)</pre>
<div class="block">Finds line segments in a binary image using the probabilistic Hough transform.

 The function implements the probabilistic Hough transform algorithm for line detection, described
 in CITE: Matas00

 See the line detection example below:
 INCLUDE: snippets/imgproc_HoughLinesP.cpp
 This is a sample picture the function parameters have been tuned for:

 ![image](pics/building.jpg)

 And this is the output of the above program in case of the probabilistic Hough transform:

 ![image](pics/houghp.png)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - 8-bit, single-channel binary source image. The image may be modified by the function.</dd>
<dd><code>lines</code> - Output vector of lines. Each line is represented by a 4-element vector
 \((x_1, y_1, x_2, y_2)\) , where \((x_1,y_1)\) and \((x_2, y_2)\) are the ending points of each detected
 line segment.</dd>
<dd><code>rho</code> - Distance resolution of the accumulator in pixels.</dd>
<dd><code>theta</code> - Angle resolution of the accumulator in radians.</dd>
<dd><code>threshold</code> - %Accumulator threshold parameter. Only those lines are returned that get enough
 votes ( \(&gt;\texttt{threshold}\) ).

 SEE: LineSegmentDetector</dd>
</dl>
</li>
</ul>
<a name="HoughLinesP-org.opencv.core.Mat-org.opencv.core.Mat-double-double-int-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>HoughLinesP</h4>
<pre>public static&nbsp;void&nbsp;HoughLinesP(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;lines,
                               double&nbsp;rho,
                               double&nbsp;theta,
                               int&nbsp;threshold,
                               double&nbsp;minLineLength)</pre>
<div class="block">Finds line segments in a binary image using the probabilistic Hough transform.

 The function implements the probabilistic Hough transform algorithm for line detection, described
 in CITE: Matas00

 See the line detection example below:
 INCLUDE: snippets/imgproc_HoughLinesP.cpp
 This is a sample picture the function parameters have been tuned for:

 ![image](pics/building.jpg)

 And this is the output of the above program in case of the probabilistic Hough transform:

 ![image](pics/houghp.png)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - 8-bit, single-channel binary source image. The image may be modified by the function.</dd>
<dd><code>lines</code> - Output vector of lines. Each line is represented by a 4-element vector
 \((x_1, y_1, x_2, y_2)\) , where \((x_1,y_1)\) and \((x_2, y_2)\) are the ending points of each detected
 line segment.</dd>
<dd><code>rho</code> - Distance resolution of the accumulator in pixels.</dd>
<dd><code>theta</code> - Angle resolution of the accumulator in radians.</dd>
<dd><code>threshold</code> - %Accumulator threshold parameter. Only those lines are returned that get enough
 votes ( \(&gt;\texttt{threshold}\) ).</dd>
<dd><code>minLineLength</code> - Minimum line length. Line segments shorter than that are rejected.

 SEE: LineSegmentDetector</dd>
</dl>
</li>
</ul>
<a name="HoughLinesP-org.opencv.core.Mat-org.opencv.core.Mat-double-double-int-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>HoughLinesP</h4>
<pre>public static&nbsp;void&nbsp;HoughLinesP(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;lines,
                               double&nbsp;rho,
                               double&nbsp;theta,
                               int&nbsp;threshold,
                               double&nbsp;minLineLength,
                               double&nbsp;maxLineGap)</pre>
<div class="block">Finds line segments in a binary image using the probabilistic Hough transform.

 The function implements the probabilistic Hough transform algorithm for line detection, described
 in CITE: Matas00

 See the line detection example below:
 INCLUDE: snippets/imgproc_HoughLinesP.cpp
 This is a sample picture the function parameters have been tuned for:

 ![image](pics/building.jpg)

 And this is the output of the above program in case of the probabilistic Hough transform:

 ![image](pics/houghp.png)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - 8-bit, single-channel binary source image. The image may be modified by the function.</dd>
<dd><code>lines</code> - Output vector of lines. Each line is represented by a 4-element vector
 \((x_1, y_1, x_2, y_2)\) , where \((x_1,y_1)\) and \((x_2, y_2)\) are the ending points of each detected
 line segment.</dd>
<dd><code>rho</code> - Distance resolution of the accumulator in pixels.</dd>
<dd><code>theta</code> - Angle resolution of the accumulator in radians.</dd>
<dd><code>threshold</code> - %Accumulator threshold parameter. Only those lines are returned that get enough
 votes ( \(&gt;\texttt{threshold}\) ).</dd>
<dd><code>minLineLength</code> - Minimum line length. Line segments shorter than that are rejected.</dd>
<dd><code>maxLineGap</code> - Maximum allowed gap between points on the same line to link them.

 SEE: LineSegmentDetector</dd>
</dl>
</li>
</ul>
<a name="HoughLinesPointSet-org.opencv.core.Mat-org.opencv.core.Mat-int-int-double-double-double-double-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>HoughLinesPointSet</h4>
<pre>public static&nbsp;void&nbsp;HoughLinesPointSet(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;point,
                                      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;lines,
                                      int&nbsp;lines_max,
                                      int&nbsp;threshold,
                                      double&nbsp;min_rho,
                                      double&nbsp;max_rho,
                                      double&nbsp;rho_step,
                                      double&nbsp;min_theta,
                                      double&nbsp;max_theta,
                                      double&nbsp;theta_step)</pre>
<div class="block">Finds lines in a set of points using the standard Hough transform.

 The function finds lines in a set of points using a modification of the Hough transform.
 INCLUDE: snippets/imgproc_HoughLinesPointSet.cpp</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>point</code> - Input vector of points. Each vector must be encoded as a Point vector \((x,y)\). Type must be CV_32FC2 or CV_32SC2.</dd>
<dd><code>lines</code> - Output vector of found lines. Each vector is encoded as a vector&lt;Vec3d&gt; \((votes, rho, theta)\).
 The larger the value of 'votes', the higher the reliability of the Hough line.</dd>
<dd><code>lines_max</code> - Max count of Hough lines.</dd>
<dd><code>threshold</code> - %Accumulator threshold parameter. Only those lines are returned that get enough
 votes ( \(&gt;\texttt{threshold}\) ).</dd>
<dd><code>min_rho</code> - Minimum value for \(\rho\) for the accumulator (Note: \(\rho\) can be negative. The absolute value \(|\rho|\) is the distance of a line to the origin.).</dd>
<dd><code>max_rho</code> - Maximum value for \(\rho\) for the accumulator.</dd>
<dd><code>rho_step</code> - Distance resolution of the accumulator.</dd>
<dd><code>min_theta</code> - Minimum angle value of the accumulator in radians.</dd>
<dd><code>max_theta</code> - Upper bound for the angle value of the accumulator in radians. The actual maximum
 angle may be slightly less than max_theta, depending on the parameters min_theta and theta_step.</dd>
<dd><code>theta_step</code> - Angle resolution of the accumulator in radians.</dd>
</dl>
</li>
</ul>
<a name="HoughLinesWithAccumulator-org.opencv.core.Mat-org.opencv.core.Mat-double-double-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>HoughLinesWithAccumulator</h4>
<pre>public static&nbsp;void&nbsp;HoughLinesWithAccumulator(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;lines,
                                             double&nbsp;rho,
                                             double&nbsp;theta,
                                             int&nbsp;threshold)</pre>
<div class="block">Finds lines in a binary image using the standard Hough transform and get accumulator.

 <b>Note:</b> This function is for bindings use only. Use original function in C++ code

 SEE: HoughLines</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - automatically generated</dd>
<dd><code>lines</code> - automatically generated</dd>
<dd><code>rho</code> - automatically generated</dd>
<dd><code>theta</code> - automatically generated</dd>
<dd><code>threshold</code> - automatically generated</dd>
</dl>
</li>
</ul>
<a name="HoughLinesWithAccumulator-org.opencv.core.Mat-org.opencv.core.Mat-double-double-int-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>HoughLinesWithAccumulator</h4>
<pre>public static&nbsp;void&nbsp;HoughLinesWithAccumulator(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;lines,
                                             double&nbsp;rho,
                                             double&nbsp;theta,
                                             int&nbsp;threshold,
                                             double&nbsp;srn)</pre>
<div class="block">Finds lines in a binary image using the standard Hough transform and get accumulator.

 <b>Note:</b> This function is for bindings use only. Use original function in C++ code

 SEE: HoughLines</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - automatically generated</dd>
<dd><code>lines</code> - automatically generated</dd>
<dd><code>rho</code> - automatically generated</dd>
<dd><code>theta</code> - automatically generated</dd>
<dd><code>threshold</code> - automatically generated</dd>
<dd><code>srn</code> - automatically generated</dd>
</dl>
</li>
</ul>
<a name="HoughLinesWithAccumulator-org.opencv.core.Mat-org.opencv.core.Mat-double-double-int-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>HoughLinesWithAccumulator</h4>
<pre>public static&nbsp;void&nbsp;HoughLinesWithAccumulator(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;lines,
                                             double&nbsp;rho,
                                             double&nbsp;theta,
                                             int&nbsp;threshold,
                                             double&nbsp;srn,
                                             double&nbsp;stn)</pre>
<div class="block">Finds lines in a binary image using the standard Hough transform and get accumulator.

 <b>Note:</b> This function is for bindings use only. Use original function in C++ code

 SEE: HoughLines</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - automatically generated</dd>
<dd><code>lines</code> - automatically generated</dd>
<dd><code>rho</code> - automatically generated</dd>
<dd><code>theta</code> - automatically generated</dd>
<dd><code>threshold</code> - automatically generated</dd>
<dd><code>srn</code> - automatically generated</dd>
<dd><code>stn</code> - automatically generated</dd>
</dl>
</li>
</ul>
<a name="HoughLinesWithAccumulator-org.opencv.core.Mat-org.opencv.core.Mat-double-double-int-double-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>HoughLinesWithAccumulator</h4>
<pre>public static&nbsp;void&nbsp;HoughLinesWithAccumulator(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;lines,
                                             double&nbsp;rho,
                                             double&nbsp;theta,
                                             int&nbsp;threshold,
                                             double&nbsp;srn,
                                             double&nbsp;stn,
                                             double&nbsp;min_theta)</pre>
<div class="block">Finds lines in a binary image using the standard Hough transform and get accumulator.

 <b>Note:</b> This function is for bindings use only. Use original function in C++ code

 SEE: HoughLines</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - automatically generated</dd>
<dd><code>lines</code> - automatically generated</dd>
<dd><code>rho</code> - automatically generated</dd>
<dd><code>theta</code> - automatically generated</dd>
<dd><code>threshold</code> - automatically generated</dd>
<dd><code>srn</code> - automatically generated</dd>
<dd><code>stn</code> - automatically generated</dd>
<dd><code>min_theta</code> - automatically generated</dd>
</dl>
</li>
</ul>
<a name="HoughLinesWithAccumulator-org.opencv.core.Mat-org.opencv.core.Mat-double-double-int-double-double-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>HoughLinesWithAccumulator</h4>
<pre>public static&nbsp;void&nbsp;HoughLinesWithAccumulator(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;lines,
                                             double&nbsp;rho,
                                             double&nbsp;theta,
                                             int&nbsp;threshold,
                                             double&nbsp;srn,
                                             double&nbsp;stn,
                                             double&nbsp;min_theta,
                                             double&nbsp;max_theta)</pre>
<div class="block">Finds lines in a binary image using the standard Hough transform and get accumulator.

 <b>Note:</b> This function is for bindings use only. Use original function in C++ code

 SEE: HoughLines</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - automatically generated</dd>
<dd><code>lines</code> - automatically generated</dd>
<dd><code>rho</code> - automatically generated</dd>
<dd><code>theta</code> - automatically generated</dd>
<dd><code>threshold</code> - automatically generated</dd>
<dd><code>srn</code> - automatically generated</dd>
<dd><code>stn</code> - automatically generated</dd>
<dd><code>min_theta</code> - automatically generated</dd>
<dd><code>max_theta</code> - automatically generated</dd>
</dl>
</li>
</ul>
<a name="HuMoments-org.opencv.imgproc.Moments-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>HuMoments</h4>
<pre>public static&nbsp;void&nbsp;HuMoments(<a href="../../../org/opencv/imgproc/Moments.html" title="class in org.opencv.imgproc">Moments</a>&nbsp;m,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;hu)</pre>
</li>
</ul>
<a name="integral-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>integral</h4>
<pre>public static&nbsp;void&nbsp;integral(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sum)</pre>
</li>
</ul>
<a name="integral-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>integral</h4>
<pre>public static&nbsp;void&nbsp;integral(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sum,
                            int&nbsp;sdepth)</pre>
</li>
</ul>
<a name="integral2-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>integral2</h4>
<pre>public static&nbsp;void&nbsp;integral2(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sum,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sqsum)</pre>
</li>
</ul>
<a name="integral2-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>integral2</h4>
<pre>public static&nbsp;void&nbsp;integral2(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sum,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sqsum,
                             int&nbsp;sdepth)</pre>
</li>
</ul>
<a name="integral2-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>integral2</h4>
<pre>public static&nbsp;void&nbsp;integral2(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sum,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sqsum,
                             int&nbsp;sdepth,
                             int&nbsp;sqdepth)</pre>
</li>
</ul>
<a name="integral3-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>integral3</h4>
<pre>public static&nbsp;void&nbsp;integral3(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sum,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sqsum,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tilted)</pre>
<div class="block">Calculates the integral of an image.

 The function calculates one or more integral images for the source image as follows:

 \(\texttt{sum} (X,Y) =  \sum _{x&lt;X,y&lt;Y}  \texttt{image} (x,y)\)

 \(\texttt{sqsum} (X,Y) =  \sum _{x&lt;X,y&lt;Y}  \texttt{image} (x,y)^2\)

 \(\texttt{tilted} (X,Y) =  \sum _{y&lt;Y,abs(x-X+1) \leq Y-y-1}  \texttt{image} (x,y)\)

 Using these integral images, you can calculate sum, mean, and standard deviation over a specific
 up-right or rotated rectangular region of the image in a constant time, for example:

 \(\sum _{x_1 \leq x &lt; x_2,  \, y_1  \leq y &lt; y_2}  \texttt{image} (x,y) =  \texttt{sum} (x_2,y_2)- \texttt{sum} (x_1,y_2)- \texttt{sum} (x_2,y_1)+ \texttt{sum} (x_1,y_1)\)

 It makes possible to do a fast blurring or fast block correlation with a variable window size, for
 example. In case of multi-channel images, sums for each channel are accumulated independently.

 As a practical example, the next figure shows the calculation of the integral of a straight
 rectangle Rect(4,4,3,2) and of a tilted rectangle Rect(5,1,2,3) . The selected pixels in the
 original image are shown, as well as the relative pixels in the integral images sum and tilted .

 ![integral calculation example](pics/integral.png)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image as \(W \times H\), 8-bit or floating-point (32f or 64f).</dd>
<dd><code>sum</code> - integral image as \((W+1)\times (H+1)\) , 32-bit integer or floating-point (32f or 64f).</dd>
<dd><code>sqsum</code> - integral image for squared pixel values; it is \((W+1)\times (H+1)\), double-precision
 floating-point (64f) array.</dd>
<dd><code>tilted</code> - integral for the image rotated by 45 degrees; it is \((W+1)\times (H+1)\) array with
 the same data type as sum.
 CV_64F.</dd>
</dl>
</li>
</ul>
<a name="integral3-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>integral3</h4>
<pre>public static&nbsp;void&nbsp;integral3(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sum,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sqsum,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tilted,
                             int&nbsp;sdepth)</pre>
<div class="block">Calculates the integral of an image.

 The function calculates one or more integral images for the source image as follows:

 \(\texttt{sum} (X,Y) =  \sum _{x&lt;X,y&lt;Y}  \texttt{image} (x,y)\)

 \(\texttt{sqsum} (X,Y) =  \sum _{x&lt;X,y&lt;Y}  \texttt{image} (x,y)^2\)

 \(\texttt{tilted} (X,Y) =  \sum _{y&lt;Y,abs(x-X+1) \leq Y-y-1}  \texttt{image} (x,y)\)

 Using these integral images, you can calculate sum, mean, and standard deviation over a specific
 up-right or rotated rectangular region of the image in a constant time, for example:

 \(\sum _{x_1 \leq x &lt; x_2,  \, y_1  \leq y &lt; y_2}  \texttt{image} (x,y) =  \texttt{sum} (x_2,y_2)- \texttt{sum} (x_1,y_2)- \texttt{sum} (x_2,y_1)+ \texttt{sum} (x_1,y_1)\)

 It makes possible to do a fast blurring or fast block correlation with a variable window size, for
 example. In case of multi-channel images, sums for each channel are accumulated independently.

 As a practical example, the next figure shows the calculation of the integral of a straight
 rectangle Rect(4,4,3,2) and of a tilted rectangle Rect(5,1,2,3) . The selected pixels in the
 original image are shown, as well as the relative pixels in the integral images sum and tilted .

 ![integral calculation example](pics/integral.png)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image as \(W \times H\), 8-bit or floating-point (32f or 64f).</dd>
<dd><code>sum</code> - integral image as \((W+1)\times (H+1)\) , 32-bit integer or floating-point (32f or 64f).</dd>
<dd><code>sqsum</code> - integral image for squared pixel values; it is \((W+1)\times (H+1)\), double-precision
 floating-point (64f) array.</dd>
<dd><code>tilted</code> - integral for the image rotated by 45 degrees; it is \((W+1)\times (H+1)\) array with
 the same data type as sum.</dd>
<dd><code>sdepth</code> - desired depth of the integral and the tilted integral images, CV_32S, CV_32F, or
 CV_64F.</dd>
</dl>
</li>
</ul>
<a name="integral3-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>integral3</h4>
<pre>public static&nbsp;void&nbsp;integral3(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sum,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;sqsum,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;tilted,
                             int&nbsp;sdepth,
                             int&nbsp;sqdepth)</pre>
<div class="block">Calculates the integral of an image.

 The function calculates one or more integral images for the source image as follows:

 \(\texttt{sum} (X,Y) =  \sum _{x&lt;X,y&lt;Y}  \texttt{image} (x,y)\)

 \(\texttt{sqsum} (X,Y) =  \sum _{x&lt;X,y&lt;Y}  \texttt{image} (x,y)^2\)

 \(\texttt{tilted} (X,Y) =  \sum _{y&lt;Y,abs(x-X+1) \leq Y-y-1}  \texttt{image} (x,y)\)

 Using these integral images, you can calculate sum, mean, and standard deviation over a specific
 up-right or rotated rectangular region of the image in a constant time, for example:

 \(\sum _{x_1 \leq x &lt; x_2,  \, y_1  \leq y &lt; y_2}  \texttt{image} (x,y) =  \texttt{sum} (x_2,y_2)- \texttt{sum} (x_1,y_2)- \texttt{sum} (x_2,y_1)+ \texttt{sum} (x_1,y_1)\)

 It makes possible to do a fast blurring or fast block correlation with a variable window size, for
 example. In case of multi-channel images, sums for each channel are accumulated independently.

 As a practical example, the next figure shows the calculation of the integral of a straight
 rectangle Rect(4,4,3,2) and of a tilted rectangle Rect(5,1,2,3) . The selected pixels in the
 original image are shown, as well as the relative pixels in the integral images sum and tilted .

 ![integral calculation example](pics/integral.png)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image as \(W \times H\), 8-bit or floating-point (32f or 64f).</dd>
<dd><code>sum</code> - integral image as \((W+1)\times (H+1)\) , 32-bit integer or floating-point (32f or 64f).</dd>
<dd><code>sqsum</code> - integral image for squared pixel values; it is \((W+1)\times (H+1)\), double-precision
 floating-point (64f) array.</dd>
<dd><code>tilted</code> - integral for the image rotated by 45 degrees; it is \((W+1)\times (H+1)\) array with
 the same data type as sum.</dd>
<dd><code>sdepth</code> - desired depth of the integral and the tilted integral images, CV_32S, CV_32F, or
 CV_64F.</dd>
<dd><code>sqdepth</code> - desired depth of the integral image of squared pixel values, CV_32F or CV_64F.</dd>
</dl>
</li>
</ul>
<a name="intersectConvexConvex-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>intersectConvexConvex</h4>
<pre>public static&nbsp;float&nbsp;intersectConvexConvex(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;p1,
                                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;p2,
                                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;p12)</pre>
<div class="block">Finds intersection of two convex polygons</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>p1</code> - First polygon</dd>
<dd><code>p2</code> - Second polygon</dd>
<dd><code>p12</code> - Output polygon describing the intersecting area
 When false, no intersection is found. If the polygons share a side or the vertex of one polygon lies on an edge
 of the other, they are not considered nested and an intersection will be found regardless of the value of handleNested.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Absolute value of area of intersecting polygon

 <b>Note:</b> intersectConvexConvex doesn't confirm that both polygons are convex and will return invalid results if they aren't.</dd>
</dl>
</li>
</ul>
<a name="intersectConvexConvex-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>intersectConvexConvex</h4>
<pre>public static&nbsp;float&nbsp;intersectConvexConvex(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;p1,
                                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;p2,
                                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;p12,
                                          boolean&nbsp;handleNested)</pre>
<div class="block">Finds intersection of two convex polygons</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>p1</code> - First polygon</dd>
<dd><code>p2</code> - Second polygon</dd>
<dd><code>p12</code> - Output polygon describing the intersecting area</dd>
<dd><code>handleNested</code> - When true, an intersection is found if one of the polygons is fully enclosed in the other.
 When false, no intersection is found. If the polygons share a side or the vertex of one polygon lies on an edge
 of the other, they are not considered nested and an intersection will be found regardless of the value of handleNested.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Absolute value of area of intersecting polygon

 <b>Note:</b> intersectConvexConvex doesn't confirm that both polygons are convex and will return invalid results if they aren't.</dd>
</dl>
</li>
</ul>
<a name="invertAffineTransform-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>invertAffineTransform</h4>
<pre>public static&nbsp;void&nbsp;invertAffineTransform(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;M,
                                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;iM)</pre>
<div class="block">Inverts an affine transformation.

 The function computes an inverse affine transformation represented by \(2 \times 3\) matrix M:

 \(\begin{bmatrix} a_{11} &amp; a_{12} &amp; b_1  \\ a_{21} &amp; a_{22} &amp; b_2 \end{bmatrix}\)

 The result is also a \(2 \times 3\) matrix of the same type as M.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>M</code> - Original affine transformation.</dd>
<dd><code>iM</code> - Output reverse affine transformation.</dd>
</dl>
</li>
</ul>
<a name="isContourConvex-org.opencv.core.MatOfPoint-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isContourConvex</h4>
<pre>public static&nbsp;boolean&nbsp;isContourConvex(<a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&nbsp;contour)</pre>
<div class="block">Tests a contour convexity.

 The function tests whether the input contour is convex or not. The contour must be simple, that is,
 without self-intersections. Otherwise, the function output is undefined.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>contour</code> - Input vector of 2D points, stored in std::vector&lt;&gt; or Mat</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="Laplacian-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Laplacian</h4>
<pre>public static&nbsp;void&nbsp;Laplacian(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                             int&nbsp;ddepth)</pre>
<div class="block">Calculates the Laplacian of an image.

 The function calculates the Laplacian of the source image by adding up the second x and y
 derivatives calculated using the Sobel operator:

 \(\texttt{dst} =  \Delta \texttt{src} =  \frac{\partial^2 \texttt{src}}{\partial x^2} +  \frac{\partial^2 \texttt{src}}{\partial y^2}\)

 This is done when <code>ksize &amp;gt; 1</code>. When <code>ksize == 1</code>, the Laplacian is computed by filtering the image
 with the following \(3 \times 3\) aperture:

 \(\vecthreethree {0}{1}{0}{1}{-4}{1}{0}{1}{0}\)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Source image.</dd>
<dd><code>dst</code> - Destination image of the same size and the same number of channels as src .</dd>
<dd><code>ddepth</code> - Desired depth of the destination image, see REF: filter_depths "combinations".
 details. The size must be positive and odd.
 applied. See #getDerivKernels for details.
 SEE:  Sobel, Scharr</dd>
</dl>
</li>
</ul>
<a name="Laplacian-org.opencv.core.Mat-org.opencv.core.Mat-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Laplacian</h4>
<pre>public static&nbsp;void&nbsp;Laplacian(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                             int&nbsp;ddepth,
                             int&nbsp;ksize)</pre>
<div class="block">Calculates the Laplacian of an image.

 The function calculates the Laplacian of the source image by adding up the second x and y
 derivatives calculated using the Sobel operator:

 \(\texttt{dst} =  \Delta \texttt{src} =  \frac{\partial^2 \texttt{src}}{\partial x^2} +  \frac{\partial^2 \texttt{src}}{\partial y^2}\)

 This is done when <code>ksize &amp;gt; 1</code>. When <code>ksize == 1</code>, the Laplacian is computed by filtering the image
 with the following \(3 \times 3\) aperture:

 \(\vecthreethree {0}{1}{0}{1}{-4}{1}{0}{1}{0}\)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Source image.</dd>
<dd><code>dst</code> - Destination image of the same size and the same number of channels as src .</dd>
<dd><code>ddepth</code> - Desired depth of the destination image, see REF: filter_depths "combinations".</dd>
<dd><code>ksize</code> - Aperture size used to compute the second-derivative filters. See #getDerivKernels for
 details. The size must be positive and odd.
 applied. See #getDerivKernels for details.
 SEE:  Sobel, Scharr</dd>
</dl>
</li>
</ul>
<a name="Laplacian-org.opencv.core.Mat-org.opencv.core.Mat-int-int-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Laplacian</h4>
<pre>public static&nbsp;void&nbsp;Laplacian(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                             int&nbsp;ddepth,
                             int&nbsp;ksize,
                             double&nbsp;scale)</pre>
<div class="block">Calculates the Laplacian of an image.

 The function calculates the Laplacian of the source image by adding up the second x and y
 derivatives calculated using the Sobel operator:

 \(\texttt{dst} =  \Delta \texttt{src} =  \frac{\partial^2 \texttt{src}}{\partial x^2} +  \frac{\partial^2 \texttt{src}}{\partial y^2}\)

 This is done when <code>ksize &amp;gt; 1</code>. When <code>ksize == 1</code>, the Laplacian is computed by filtering the image
 with the following \(3 \times 3\) aperture:

 \(\vecthreethree {0}{1}{0}{1}{-4}{1}{0}{1}{0}\)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Source image.</dd>
<dd><code>dst</code> - Destination image of the same size and the same number of channels as src .</dd>
<dd><code>ddepth</code> - Desired depth of the destination image, see REF: filter_depths "combinations".</dd>
<dd><code>ksize</code> - Aperture size used to compute the second-derivative filters. See #getDerivKernels for
 details. The size must be positive and odd.</dd>
<dd><code>scale</code> - Optional scale factor for the computed Laplacian values. By default, no scaling is
 applied. See #getDerivKernels for details.
 SEE:  Sobel, Scharr</dd>
</dl>
</li>
</ul>
<a name="Laplacian-org.opencv.core.Mat-org.opencv.core.Mat-int-int-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Laplacian</h4>
<pre>public static&nbsp;void&nbsp;Laplacian(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                             int&nbsp;ddepth,
                             int&nbsp;ksize,
                             double&nbsp;scale,
                             double&nbsp;delta)</pre>
<div class="block">Calculates the Laplacian of an image.

 The function calculates the Laplacian of the source image by adding up the second x and y
 derivatives calculated using the Sobel operator:

 \(\texttt{dst} =  \Delta \texttt{src} =  \frac{\partial^2 \texttt{src}}{\partial x^2} +  \frac{\partial^2 \texttt{src}}{\partial y^2}\)

 This is done when <code>ksize &amp;gt; 1</code>. When <code>ksize == 1</code>, the Laplacian is computed by filtering the image
 with the following \(3 \times 3\) aperture:

 \(\vecthreethree {0}{1}{0}{1}{-4}{1}{0}{1}{0}\)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Source image.</dd>
<dd><code>dst</code> - Destination image of the same size and the same number of channels as src .</dd>
<dd><code>ddepth</code> - Desired depth of the destination image, see REF: filter_depths "combinations".</dd>
<dd><code>ksize</code> - Aperture size used to compute the second-derivative filters. See #getDerivKernels for
 details. The size must be positive and odd.</dd>
<dd><code>scale</code> - Optional scale factor for the computed Laplacian values. By default, no scaling is
 applied. See #getDerivKernels for details.</dd>
<dd><code>delta</code> - Optional delta value that is added to the results prior to storing them in dst .
 SEE:  Sobel, Scharr</dd>
</dl>
</li>
</ul>
<a name="Laplacian-org.opencv.core.Mat-org.opencv.core.Mat-int-int-double-double-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Laplacian</h4>
<pre>public static&nbsp;void&nbsp;Laplacian(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                             int&nbsp;ddepth,
                             int&nbsp;ksize,
                             double&nbsp;scale,
                             double&nbsp;delta,
                             int&nbsp;borderType)</pre>
<div class="block">Calculates the Laplacian of an image.

 The function calculates the Laplacian of the source image by adding up the second x and y
 derivatives calculated using the Sobel operator:

 \(\texttt{dst} =  \Delta \texttt{src} =  \frac{\partial^2 \texttt{src}}{\partial x^2} +  \frac{\partial^2 \texttt{src}}{\partial y^2}\)

 This is done when <code>ksize &amp;gt; 1</code>. When <code>ksize == 1</code>, the Laplacian is computed by filtering the image
 with the following \(3 \times 3\) aperture:

 \(\vecthreethree {0}{1}{0}{1}{-4}{1}{0}{1}{0}\)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Source image.</dd>
<dd><code>dst</code> - Destination image of the same size and the same number of channels as src .</dd>
<dd><code>ddepth</code> - Desired depth of the destination image, see REF: filter_depths "combinations".</dd>
<dd><code>ksize</code> - Aperture size used to compute the second-derivative filters. See #getDerivKernels for
 details. The size must be positive and odd.</dd>
<dd><code>scale</code> - Optional scale factor for the computed Laplacian values. By default, no scaling is
 applied. See #getDerivKernels for details.</dd>
<dd><code>delta</code> - Optional delta value that is added to the results prior to storing them in dst .</dd>
<dd><code>borderType</code> - Pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported.
 SEE:  Sobel, Scharr</dd>
</dl>
</li>
</ul>
<a name="line-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Point-org.opencv.core.Scalar-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>line</h4>
<pre>public static&nbsp;void&nbsp;line(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt1,
                        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt2,
                        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color)</pre>
<div class="block">Draws a line segment connecting two points.

 The function line draws the line segment between pt1 and pt2 points in the image. The line is
 clipped by the image boundaries. For non-antialiased lines with integer coordinates, the 8-connected
 or 4-connected Bresenham algorithm is used. Thick lines are drawn with rounding endings. Antialiased
 lines are drawn using Gaussian filtering.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - Image.</dd>
<dd><code>pt1</code> - First point of the line segment.</dd>
<dd><code>pt2</code> - Second point of the line segment.</dd>
<dd><code>color</code> - Line color.</dd>
</dl>
</li>
</ul>
<a name="line-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Point-org.opencv.core.Scalar-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>line</h4>
<pre>public static&nbsp;void&nbsp;line(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt1,
                        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt2,
                        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
                        int&nbsp;thickness)</pre>
<div class="block">Draws a line segment connecting two points.

 The function line draws the line segment between pt1 and pt2 points in the image. The line is
 clipped by the image boundaries. For non-antialiased lines with integer coordinates, the 8-connected
 or 4-connected Bresenham algorithm is used. Thick lines are drawn with rounding endings. Antialiased
 lines are drawn using Gaussian filtering.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - Image.</dd>
<dd><code>pt1</code> - First point of the line segment.</dd>
<dd><code>pt2</code> - Second point of the line segment.</dd>
<dd><code>color</code> - Line color.</dd>
<dd><code>thickness</code> - Line thickness.</dd>
</dl>
</li>
</ul>
<a name="line-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Point-org.opencv.core.Scalar-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>line</h4>
<pre>public static&nbsp;void&nbsp;line(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt1,
                        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt2,
                        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
                        int&nbsp;thickness,
                        int&nbsp;lineType)</pre>
<div class="block">Draws a line segment connecting two points.

 The function line draws the line segment between pt1 and pt2 points in the image. The line is
 clipped by the image boundaries. For non-antialiased lines with integer coordinates, the 8-connected
 or 4-connected Bresenham algorithm is used. Thick lines are drawn with rounding endings. Antialiased
 lines are drawn using Gaussian filtering.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - Image.</dd>
<dd><code>pt1</code> - First point of the line segment.</dd>
<dd><code>pt2</code> - Second point of the line segment.</dd>
<dd><code>color</code> - Line color.</dd>
<dd><code>thickness</code> - Line thickness.</dd>
<dd><code>lineType</code> - Type of the line. See #LineTypes.</dd>
</dl>
</li>
</ul>
<a name="line-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Point-org.opencv.core.Scalar-int-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>line</h4>
<pre>public static&nbsp;void&nbsp;line(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt1,
                        <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt2,
                        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
                        int&nbsp;thickness,
                        int&nbsp;lineType,
                        int&nbsp;shift)</pre>
<div class="block">Draws a line segment connecting two points.

 The function line draws the line segment between pt1 and pt2 points in the image. The line is
 clipped by the image boundaries. For non-antialiased lines with integer coordinates, the 8-connected
 or 4-connected Bresenham algorithm is used. Thick lines are drawn with rounding endings. Antialiased
 lines are drawn using Gaussian filtering.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - Image.</dd>
<dd><code>pt1</code> - First point of the line segment.</dd>
<dd><code>pt2</code> - Second point of the line segment.</dd>
<dd><code>color</code> - Line color.</dd>
<dd><code>thickness</code> - Line thickness.</dd>
<dd><code>lineType</code> - Type of the line. See #LineTypes.</dd>
<dd><code>shift</code> - Number of fractional bits in the point coordinates.</dd>
</dl>
</li>
</ul>
<a name="matchShapes-org.opencv.core.Mat-org.opencv.core.Mat-int-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>matchShapes</h4>
<pre>public static&nbsp;double&nbsp;matchShapes(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;contour1,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;contour2,
                                 int&nbsp;method,
                                 double&nbsp;parameter)</pre>
<div class="block">Compares two shapes.

 The function compares two shapes. All three implemented methods use the Hu invariants (see #HuMoments)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>contour1</code> - First contour or grayscale image.</dd>
<dd><code>contour2</code> - Second contour or grayscale image.</dd>
<dd><code>method</code> - Comparison method, see #ShapeMatchModes</dd>
<dd><code>parameter</code> - Method-specific parameter (not supported now).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="matchTemplate-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>matchTemplate</h4>
<pre>public static&nbsp;void&nbsp;matchTemplate(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;templ,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;result,
                                 int&nbsp;method)</pre>
<div class="block">Compares a template against overlapped image regions.

 The function slides through image , compares the overlapped patches of size \(w \times h\) against
 templ using the specified method and stores the comparison results in result . #TemplateMatchModes
 describes the formulae for the available comparison methods ( \(I\) denotes image, \(T\)
 template, \(R\) result, \(M\) the optional mask ). The summation is done over template and/or
 the image patch: \(x' = 0...w-1, y' = 0...h-1\)

 After the function finishes the comparison, the best matches can be found as global minimums (when
 #TM_SQDIFF was used) or maximums (when #TM_CCORR or #TM_CCOEFF was used) using the
 #minMaxLoc function. In case of a color image, template summation in the numerator and each sum in
 the denominator is done over all of the channels and separate mean values are used for each channel.
 That is, the function can take a color template and a color image. The result will still be a
 single-channel image, which is easier to analyze.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - Image where the search is running. It must be 8-bit or 32-bit floating-point.</dd>
<dd><code>templ</code> - Searched template. It must be not greater than the source image and have the same
 data type.</dd>
<dd><code>result</code> - Map of comparison results. It must be single-channel 32-bit floating-point. If image
 is \(W \times H\) and templ is \(w \times h\) , then result is \((W-w+1) \times (H-h+1)\) .</dd>
<dd><code>method</code> - Parameter specifying the comparison method, see #TemplateMatchModes
             of channels as template or only one channel, which is then used for all template and
             image channels. If the data type is #CV_8U, the mask is interpreted as a binary mask,
             meaning only elements where mask is nonzero are used and are kept unchanged independent
             of the actual mask value (weight equals 1). For data tpye #CV_32F, the mask values are
             used as weights. The exact formulas are documented in #TemplateMatchModes.</dd>
</dl>
</li>
</ul>
<a name="matchTemplate-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>matchTemplate</h4>
<pre>public static&nbsp;void&nbsp;matchTemplate(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;templ,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;result,
                                 int&nbsp;method,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
<div class="block">Compares a template against overlapped image regions.

 The function slides through image , compares the overlapped patches of size \(w \times h\) against
 templ using the specified method and stores the comparison results in result . #TemplateMatchModes
 describes the formulae for the available comparison methods ( \(I\) denotes image, \(T\)
 template, \(R\) result, \(M\) the optional mask ). The summation is done over template and/or
 the image patch: \(x' = 0...w-1, y' = 0...h-1\)

 After the function finishes the comparison, the best matches can be found as global minimums (when
 #TM_SQDIFF was used) or maximums (when #TM_CCORR or #TM_CCOEFF was used) using the
 #minMaxLoc function. In case of a color image, template summation in the numerator and each sum in
 the denominator is done over all of the channels and separate mean values are used for each channel.
 That is, the function can take a color template and a color image. The result will still be a
 single-channel image, which is easier to analyze.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - Image where the search is running. It must be 8-bit or 32-bit floating-point.</dd>
<dd><code>templ</code> - Searched template. It must be not greater than the source image and have the same
 data type.</dd>
<dd><code>result</code> - Map of comparison results. It must be single-channel 32-bit floating-point. If image
 is \(W \times H\) and templ is \(w \times h\) , then result is \((W-w+1) \times (H-h+1)\) .</dd>
<dd><code>method</code> - Parameter specifying the comparison method, see #TemplateMatchModes</dd>
<dd><code>mask</code> - Optional mask. It must have the same size as templ. It must either have the same number
             of channels as template or only one channel, which is then used for all template and
             image channels. If the data type is #CV_8U, the mask is interpreted as a binary mask,
             meaning only elements where mask is nonzero are used and are kept unchanged independent
             of the actual mask value (weight equals 1). For data tpye #CV_32F, the mask values are
             used as weights. The exact formulas are documented in #TemplateMatchModes.</dd>
</dl>
</li>
</ul>
<a name="medianBlur-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>medianBlur</h4>
<pre>public static&nbsp;void&nbsp;medianBlur(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                              int&nbsp;ksize)</pre>
<div class="block">Blurs an image using the median filter.

 The function smoothes an image using the median filter with the \(\texttt{ksize} \times
 \texttt{ksize}\) aperture. Each channel of a multi-channel image is processed independently.
 In-place operation is supported.

 <b>Note:</b> The median filter uses #BORDER_REPLICATE internally to cope with border pixels, see #BorderTypes</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input 1-, 3-, or 4-channel image; when ksize is 3 or 5, the image depth should be
 CV_8U, CV_16U, or CV_32F, for larger aperture sizes, it can only be CV_8U.</dd>
<dd><code>dst</code> - destination array of the same size and type as src.</dd>
<dd><code>ksize</code> - aperture linear size; it must be odd and greater than 1, for example: 3, 5, 7 ...
 SEE:  bilateralFilter, blur, boxFilter, GaussianBlur</dd>
</dl>
</li>
</ul>
<a name="minAreaRect-org.opencv.core.MatOfPoint2f-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>minAreaRect</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/RotatedRect.html" title="class in org.opencv.core">RotatedRect</a>&nbsp;minAreaRect(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points)</pre>
<div class="block">Finds a rotated rectangle of the minimum area enclosing the input 2D point set.

 The function calculates and returns the minimum-area bounding rectangle (possibly rotated) for a
 specified point set. Developer should keep in mind that the returned RotatedRect can contain negative
 indices when data is close to the containing Mat element boundary.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points</code> - Input vector of 2D points, stored in std::vector&lt;&gt; or Mat</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="minEnclosingCircle-org.opencv.core.MatOfPoint2f-org.opencv.core.Point-float:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>minEnclosingCircle</h4>
<pre>public static&nbsp;void&nbsp;minEnclosingCircle(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;points,
                                      <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
                                      float[]&nbsp;radius)</pre>
<div class="block">Finds a circle of the minimum area enclosing a 2D point set.

 The function finds the minimal enclosing circle of a 2D point set using an iterative algorithm.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points</code> - Input vector of 2D points, stored in std::vector&lt;&gt; or Mat</dd>
<dd><code>center</code> - Output center of the circle.</dd>
<dd><code>radius</code> - Output radius of the circle.</dd>
</dl>
</li>
</ul>
<a name="minEnclosingTriangle-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>minEnclosingTriangle</h4>
<pre>public static&nbsp;double&nbsp;minEnclosingTriangle(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;points,
                                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;triangle)</pre>
<div class="block">Finds a triangle of minimum area enclosing a 2D point set and returns its area.

 The function finds a triangle of minimum area enclosing the given set of 2D points and returns its
 area. The output for a given 2D point set is shown in the image below. 2D points are depicted in
 red* and the enclosing triangle in *yellow*.

 ![Sample output of the minimum enclosing triangle function](pics/minenclosingtriangle.png)

 The implementation of the algorithm is based on O'Rourke's CITE: ORourke86 and Klee and Laskowski's
 CITE: KleeLaskowski85 papers. O'Rourke provides a \(\theta(n)\) algorithm for finding the minimal
 enclosing triangle of a 2D convex polygon with n vertices. Since the #minEnclosingTriangle function
 takes a 2D point set as input an additional preprocessing step of computing the convex hull of the
 2D point set is required. The complexity of the #convexHull function is \(O(n log(n))\) which is higher
 than \(\theta(n)\). Thus the overall complexity of the function is \(O(n log(n))\).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points</code> - Input vector of 2D points with depth CV_32S or CV_32F, stored in std::vector&lt;&gt; or Mat</dd>
<dd><code>triangle</code> - Output vector of three 2D points defining the vertices of the triangle. The depth
 of the OutputArray must be CV_32F.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="moments-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>moments</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/imgproc/Moments.html" title="class in org.opencv.imgproc">Moments</a>&nbsp;moments(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;array)</pre>
<div class="block">Calculates all of the moments up to the third order of a polygon or rasterized shape.

 The function computes moments, up to the 3rd order, of a vector shape or a rasterized shape. The
 results are returned in the structure cv::Moments.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>array</code> - Raster image (single-channel, 8-bit or floating-point 2D array) or an array (
 \(1 \times N\) or \(N \times 1\) ) of 2D points (Point or Point2f ).
 used for images only.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>moments.

 <b>Note:</b> Only applicable to contour moments calculations from Python bindings: Note that the numpy
 type for the input array should be either np.int32 or np.float32.

 SEE:  contourArea, arcLength</dd>
</dl>
</li>
</ul>
<a name="moments-org.opencv.core.Mat-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>moments</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/imgproc/Moments.html" title="class in org.opencv.imgproc">Moments</a>&nbsp;moments(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;array,
                              boolean&nbsp;binaryImage)</pre>
<div class="block">Calculates all of the moments up to the third order of a polygon or rasterized shape.

 The function computes moments, up to the 3rd order, of a vector shape or a rasterized shape. The
 results are returned in the structure cv::Moments.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>array</code> - Raster image (single-channel, 8-bit or floating-point 2D array) or an array (
 \(1 \times N\) or \(N \times 1\) ) of 2D points (Point or Point2f ).</dd>
<dd><code>binaryImage</code> - If it is true, all non-zero image pixels are treated as 1's. The parameter is
 used for images only.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>moments.

 <b>Note:</b> Only applicable to contour moments calculations from Python bindings: Note that the numpy
 type for the input array should be either np.int32 or np.float32.

 SEE:  contourArea, arcLength</dd>
</dl>
</li>
</ul>
<a name="morphologyEx-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>morphologyEx</h4>
<pre>public static&nbsp;void&nbsp;morphologyEx(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                int&nbsp;op,
                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel)</pre>
<div class="block">Performs advanced morphological transformations.

 The function cv::morphologyEx can perform advanced morphological transformations using an erosion and dilation as
 basic operations.

 Any of the operations can be done in-place. In case of multi-channel images, each channel is
 processed independently.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Source image. The number of channels can be arbitrary. The depth should be one of
 CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.</dd>
<dd><code>dst</code> - Destination image of the same size and type as source image.</dd>
<dd><code>op</code> - Type of a morphological operation, see #MorphTypes</dd>
<dd><code>kernel</code> - Structuring element. It can be created using #getStructuringElement.
 kernel center.
 meaning.
 SEE:  dilate, erode, getStructuringElement
 <b>Note:</b> The number of iterations is the number of times erosion or dilatation operation will be applied.
 For instance, an opening operation (#MORPH_OPEN) with two iterations is equivalent to apply
 successively: erode -&gt; erode -&gt; dilate -&gt; dilate (and not erode -&gt; dilate -&gt; erode -&gt; dilate).</dd>
</dl>
</li>
</ul>
<a name="morphologyEx-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Mat-org.opencv.core.Point-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>morphologyEx</h4>
<pre>public static&nbsp;void&nbsp;morphologyEx(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                int&nbsp;op,
                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel,
                                <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor)</pre>
<div class="block">Performs advanced morphological transformations.

 The function cv::morphologyEx can perform advanced morphological transformations using an erosion and dilation as
 basic operations.

 Any of the operations can be done in-place. In case of multi-channel images, each channel is
 processed independently.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Source image. The number of channels can be arbitrary. The depth should be one of
 CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.</dd>
<dd><code>dst</code> - Destination image of the same size and type as source image.</dd>
<dd><code>op</code> - Type of a morphological operation, see #MorphTypes</dd>
<dd><code>kernel</code> - Structuring element. It can be created using #getStructuringElement.</dd>
<dd><code>anchor</code> - Anchor position with the kernel. Negative values mean that the anchor is at the
 kernel center.
 meaning.
 SEE:  dilate, erode, getStructuringElement
 <b>Note:</b> The number of iterations is the number of times erosion or dilatation operation will be applied.
 For instance, an opening operation (#MORPH_OPEN) with two iterations is equivalent to apply
 successively: erode -&gt; erode -&gt; dilate -&gt; dilate (and not erode -&gt; dilate -&gt; erode -&gt; dilate).</dd>
</dl>
</li>
</ul>
<a name="morphologyEx-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Mat-org.opencv.core.Point-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>morphologyEx</h4>
<pre>public static&nbsp;void&nbsp;morphologyEx(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                int&nbsp;op,
                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel,
                                <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
                                int&nbsp;iterations)</pre>
<div class="block">Performs advanced morphological transformations.

 The function cv::morphologyEx can perform advanced morphological transformations using an erosion and dilation as
 basic operations.

 Any of the operations can be done in-place. In case of multi-channel images, each channel is
 processed independently.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Source image. The number of channels can be arbitrary. The depth should be one of
 CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.</dd>
<dd><code>dst</code> - Destination image of the same size and type as source image.</dd>
<dd><code>op</code> - Type of a morphological operation, see #MorphTypes</dd>
<dd><code>kernel</code> - Structuring element. It can be created using #getStructuringElement.</dd>
<dd><code>anchor</code> - Anchor position with the kernel. Negative values mean that the anchor is at the
 kernel center.</dd>
<dd><code>iterations</code> - Number of times erosion and dilation are applied.
 meaning.
 SEE:  dilate, erode, getStructuringElement
 <b>Note:</b> The number of iterations is the number of times erosion or dilatation operation will be applied.
 For instance, an opening operation (#MORPH_OPEN) with two iterations is equivalent to apply
 successively: erode -&gt; erode -&gt; dilate -&gt; dilate (and not erode -&gt; dilate -&gt; erode -&gt; dilate).</dd>
</dl>
</li>
</ul>
<a name="morphologyEx-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Mat-org.opencv.core.Point-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>morphologyEx</h4>
<pre>public static&nbsp;void&nbsp;morphologyEx(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                int&nbsp;op,
                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel,
                                <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
                                int&nbsp;iterations,
                                int&nbsp;borderType)</pre>
<div class="block">Performs advanced morphological transformations.

 The function cv::morphologyEx can perform advanced morphological transformations using an erosion and dilation as
 basic operations.

 Any of the operations can be done in-place. In case of multi-channel images, each channel is
 processed independently.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Source image. The number of channels can be arbitrary. The depth should be one of
 CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.</dd>
<dd><code>dst</code> - Destination image of the same size and type as source image.</dd>
<dd><code>op</code> - Type of a morphological operation, see #MorphTypes</dd>
<dd><code>kernel</code> - Structuring element. It can be created using #getStructuringElement.</dd>
<dd><code>anchor</code> - Anchor position with the kernel. Negative values mean that the anchor is at the
 kernel center.</dd>
<dd><code>iterations</code> - Number of times erosion and dilation are applied.</dd>
<dd><code>borderType</code> - Pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported.
 meaning.
 SEE:  dilate, erode, getStructuringElement
 <b>Note:</b> The number of iterations is the number of times erosion or dilatation operation will be applied.
 For instance, an opening operation (#MORPH_OPEN) with two iterations is equivalent to apply
 successively: erode -&gt; erode -&gt; dilate -&gt; dilate (and not erode -&gt; dilate -&gt; erode -&gt; dilate).</dd>
</dl>
</li>
</ul>
<a name="morphologyEx-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Mat-org.opencv.core.Point-int-int-org.opencv.core.Scalar-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>morphologyEx</h4>
<pre>public static&nbsp;void&nbsp;morphologyEx(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                int&nbsp;op,
                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernel,
                                <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
                                int&nbsp;iterations,
                                int&nbsp;borderType,
                                <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;borderValue)</pre>
<div class="block">Performs advanced morphological transformations.

 The function cv::morphologyEx can perform advanced morphological transformations using an erosion and dilation as
 basic operations.

 Any of the operations can be done in-place. In case of multi-channel images, each channel is
 processed independently.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Source image. The number of channels can be arbitrary. The depth should be one of
 CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.</dd>
<dd><code>dst</code> - Destination image of the same size and type as source image.</dd>
<dd><code>op</code> - Type of a morphological operation, see #MorphTypes</dd>
<dd><code>kernel</code> - Structuring element. It can be created using #getStructuringElement.</dd>
<dd><code>anchor</code> - Anchor position with the kernel. Negative values mean that the anchor is at the
 kernel center.</dd>
<dd><code>iterations</code> - Number of times erosion and dilation are applied.</dd>
<dd><code>borderType</code> - Pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported.</dd>
<dd><code>borderValue</code> - Border value in case of a constant border. The default value has a special
 meaning.
 SEE:  dilate, erode, getStructuringElement
 <b>Note:</b> The number of iterations is the number of times erosion or dilatation operation will be applied.
 For instance, an opening operation (#MORPH_OPEN) with two iterations is equivalent to apply
 successively: erode -&gt; erode -&gt; dilate -&gt; dilate (and not erode -&gt; dilate -&gt; erode -&gt; dilate).</dd>
</dl>
</li>
</ul>
<a name="phaseCorrelate-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>phaseCorrelate</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;phaseCorrelate(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2)</pre>
<div class="block">The function is used to detect translational shifts that occur between two images.

 The operation takes advantage of the Fourier shift theorem for detecting the translational shift in
 the frequency domain. It can be used for fast image registration as well as motion estimation. For
 more information please see &lt;http://en.wikipedia.org/wiki/Phase_correlation&gt;

 Calculates the cross-power spectrum of two supplied source arrays. The arrays are padded if needed
 with getOptimalDFTSize.

 The function performs the following equations:
 <ul>
   <li>
  First it applies a Hanning window (see &lt;http://en.wikipedia.org/wiki/Hann_function&gt;) to each
 image to remove possible edge effects. This window is cached until the array size changes to speed
 up processing time.
   </li>
   <li>
  Next it computes the forward DFTs of each source array:
 \(\mathbf{G}_a = \mathcal{F}\{src_1\}, \; \mathbf{G}_b = \mathcal{F}\{src_2\}\)
 where \(\mathcal{F}\) is the forward DFT.
   </li>
   <li>
  It then computes the cross-power spectrum of each frequency domain array:
 \(R = \frac{ \mathbf{G}_a \mathbf{G}_b^*}{|\mathbf{G}_a \mathbf{G}_b^*|}\)
   </li>
   <li>
  Next the cross-correlation is converted back into the time domain via the inverse DFT:
 \(r = \mathcal{F}^{-1}\{R\}\)
   </li>
   <li>
  Finally, it computes the peak location and computes a 5x5 weighted centroid around the peak to
 achieve sub-pixel accuracy.
 \((\Delta x, \Delta y) = \texttt{weightedCentroid} \{\arg \max_{(x, y)}\{r\}\}\)
   </li>
   <li>
  If non-zero, the response parameter is computed as the sum of the elements of r within the 5x5
 centroid around the peak location. It is normalized to a maximum of 1 (meaning there is a single
 peak) and will be smaller when there are multiple peaks.
   </li>
 </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - Source floating point array (CV_32FC1 or CV_64FC1)</dd>
<dd><code>src2</code> - Source floating point array (CV_32FC1 or CV_64FC1)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>detected phase shift (sub-pixel) between the two arrays.

 SEE: dft, getOptimalDFTSize, idft, mulSpectrums createHanningWindow</dd>
</dl>
</li>
</ul>
<a name="phaseCorrelate-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>phaseCorrelate</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;phaseCorrelate(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;window)</pre>
<div class="block">The function is used to detect translational shifts that occur between two images.

 The operation takes advantage of the Fourier shift theorem for detecting the translational shift in
 the frequency domain. It can be used for fast image registration as well as motion estimation. For
 more information please see &lt;http://en.wikipedia.org/wiki/Phase_correlation&gt;

 Calculates the cross-power spectrum of two supplied source arrays. The arrays are padded if needed
 with getOptimalDFTSize.

 The function performs the following equations:
 <ul>
   <li>
  First it applies a Hanning window (see &lt;http://en.wikipedia.org/wiki/Hann_function&gt;) to each
 image to remove possible edge effects. This window is cached until the array size changes to speed
 up processing time.
   </li>
   <li>
  Next it computes the forward DFTs of each source array:
 \(\mathbf{G}_a = \mathcal{F}\{src_1\}, \; \mathbf{G}_b = \mathcal{F}\{src_2\}\)
 where \(\mathcal{F}\) is the forward DFT.
   </li>
   <li>
  It then computes the cross-power spectrum of each frequency domain array:
 \(R = \frac{ \mathbf{G}_a \mathbf{G}_b^*}{|\mathbf{G}_a \mathbf{G}_b^*|}\)
   </li>
   <li>
  Next the cross-correlation is converted back into the time domain via the inverse DFT:
 \(r = \mathcal{F}^{-1}\{R\}\)
   </li>
   <li>
  Finally, it computes the peak location and computes a 5x5 weighted centroid around the peak to
 achieve sub-pixel accuracy.
 \((\Delta x, \Delta y) = \texttt{weightedCentroid} \{\arg \max_{(x, y)}\{r\}\}\)
   </li>
   <li>
  If non-zero, the response parameter is computed as the sum of the elements of r within the 5x5
 centroid around the peak location. It is normalized to a maximum of 1 (meaning there is a single
 peak) and will be smaller when there are multiple peaks.
   </li>
 </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - Source floating point array (CV_32FC1 or CV_64FC1)</dd>
<dd><code>src2</code> - Source floating point array (CV_32FC1 or CV_64FC1)</dd>
<dd><code>window</code> - Floating point array with windowing coefficients to reduce edge effects (optional).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>detected phase shift (sub-pixel) between the two arrays.

 SEE: dft, getOptimalDFTSize, idft, mulSpectrums createHanningWindow</dd>
</dl>
</li>
</ul>
<a name="phaseCorrelate-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>phaseCorrelate</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;phaseCorrelate(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;window,
                                   double[]&nbsp;response)</pre>
<div class="block">The function is used to detect translational shifts that occur between two images.

 The operation takes advantage of the Fourier shift theorem for detecting the translational shift in
 the frequency domain. It can be used for fast image registration as well as motion estimation. For
 more information please see &lt;http://en.wikipedia.org/wiki/Phase_correlation&gt;

 Calculates the cross-power spectrum of two supplied source arrays. The arrays are padded if needed
 with getOptimalDFTSize.

 The function performs the following equations:
 <ul>
   <li>
  First it applies a Hanning window (see &lt;http://en.wikipedia.org/wiki/Hann_function&gt;) to each
 image to remove possible edge effects. This window is cached until the array size changes to speed
 up processing time.
   </li>
   <li>
  Next it computes the forward DFTs of each source array:
 \(\mathbf{G}_a = \mathcal{F}\{src_1\}, \; \mathbf{G}_b = \mathcal{F}\{src_2\}\)
 where \(\mathcal{F}\) is the forward DFT.
   </li>
   <li>
  It then computes the cross-power spectrum of each frequency domain array:
 \(R = \frac{ \mathbf{G}_a \mathbf{G}_b^*}{|\mathbf{G}_a \mathbf{G}_b^*|}\)
   </li>
   <li>
  Next the cross-correlation is converted back into the time domain via the inverse DFT:
 \(r = \mathcal{F}^{-1}\{R\}\)
   </li>
   <li>
  Finally, it computes the peak location and computes a 5x5 weighted centroid around the peak to
 achieve sub-pixel accuracy.
 \((\Delta x, \Delta y) = \texttt{weightedCentroid} \{\arg \max_{(x, y)}\{r\}\}\)
   </li>
   <li>
  If non-zero, the response parameter is computed as the sum of the elements of r within the 5x5
 centroid around the peak location. It is normalized to a maximum of 1 (meaning there is a single
 peak) and will be smaller when there are multiple peaks.
   </li>
 </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - Source floating point array (CV_32FC1 or CV_64FC1)</dd>
<dd><code>src2</code> - Source floating point array (CV_32FC1 or CV_64FC1)</dd>
<dd><code>window</code> - Floating point array with windowing coefficients to reduce edge effects (optional).</dd>
<dd><code>response</code> - Signal power within the 5x5 centroid around the peak, between 0 and 1 (optional).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>detected phase shift (sub-pixel) between the two arrays.

 SEE: dft, getOptimalDFTSize, idft, mulSpectrums createHanningWindow</dd>
</dl>
</li>
</ul>
<a name="pointPolygonTest-org.opencv.core.MatOfPoint2f-org.opencv.core.Point-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pointPolygonTest</h4>
<pre>public static&nbsp;double&nbsp;pointPolygonTest(<a href="../../../org/opencv/core/MatOfPoint2f.html" title="class in org.opencv.core">MatOfPoint2f</a>&nbsp;contour,
                                      <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt,
                                      boolean&nbsp;measureDist)</pre>
<div class="block">Performs a point-in-contour test.

 The function determines whether the point is inside a contour, outside, or lies on an edge (or
 coincides with a vertex). It returns positive (inside), negative (outside), or zero (on an edge)
 value, correspondingly. When measureDist=false , the return value is +1, -1, and 0, respectively.
 Otherwise, the return value is a signed distance between the point and the nearest contour edge.

 See below a sample output of the function where each image pixel is tested against the contour:

 ![sample output](pics/pointpolygon.png)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>contour</code> - Input contour.</dd>
<dd><code>pt</code> - Point tested against the contour.</dd>
<dd><code>measureDist</code> - If true, the function estimates the signed distance from the point to the
 nearest contour edge. Otherwise, the function only checks if the point is inside a contour or not.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="polylines-org.opencv.core.Mat-java.util.List-boolean-org.opencv.core.Scalar-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>polylines</h4>
<pre>public static&nbsp;void&nbsp;polylines(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                             java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;pts,
                             boolean&nbsp;isClosed,
                             <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color)</pre>
<div class="block">Draws several polygonal curves.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - Image.</dd>
<dd><code>pts</code> - Array of polygonal curves.</dd>
<dd><code>isClosed</code> - Flag indicating whether the drawn polylines are closed or not. If they are closed,
 the function draws a line from the last vertex of each curve to its first vertex.</dd>
<dd><code>color</code> - Polyline color.

 The function cv::polylines draws one or more polygonal curves.</dd>
</dl>
</li>
</ul>
<a name="polylines-org.opencv.core.Mat-java.util.List-boolean-org.opencv.core.Scalar-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>polylines</h4>
<pre>public static&nbsp;void&nbsp;polylines(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                             java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;pts,
                             boolean&nbsp;isClosed,
                             <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
                             int&nbsp;thickness)</pre>
<div class="block">Draws several polygonal curves.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - Image.</dd>
<dd><code>pts</code> - Array of polygonal curves.</dd>
<dd><code>isClosed</code> - Flag indicating whether the drawn polylines are closed or not. If they are closed,
 the function draws a line from the last vertex of each curve to its first vertex.</dd>
<dd><code>color</code> - Polyline color.</dd>
<dd><code>thickness</code> - Thickness of the polyline edges.

 The function cv::polylines draws one or more polygonal curves.</dd>
</dl>
</li>
</ul>
<a name="polylines-org.opencv.core.Mat-java.util.List-boolean-org.opencv.core.Scalar-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>polylines</h4>
<pre>public static&nbsp;void&nbsp;polylines(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                             java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;pts,
                             boolean&nbsp;isClosed,
                             <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
                             int&nbsp;thickness,
                             int&nbsp;lineType)</pre>
<div class="block">Draws several polygonal curves.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - Image.</dd>
<dd><code>pts</code> - Array of polygonal curves.</dd>
<dd><code>isClosed</code> - Flag indicating whether the drawn polylines are closed or not. If they are closed,
 the function draws a line from the last vertex of each curve to its first vertex.</dd>
<dd><code>color</code> - Polyline color.</dd>
<dd><code>thickness</code> - Thickness of the polyline edges.</dd>
<dd><code>lineType</code> - Type of the line segments. See #LineTypes

 The function cv::polylines draws one or more polygonal curves.</dd>
</dl>
</li>
</ul>
<a name="polylines-org.opencv.core.Mat-java.util.List-boolean-org.opencv.core.Scalar-int-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>polylines</h4>
<pre>public static&nbsp;void&nbsp;polylines(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                             java.util.List&lt;<a href="../../../org/opencv/core/MatOfPoint.html" title="class in org.opencv.core">MatOfPoint</a>&gt;&nbsp;pts,
                             boolean&nbsp;isClosed,
                             <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
                             int&nbsp;thickness,
                             int&nbsp;lineType,
                             int&nbsp;shift)</pre>
<div class="block">Draws several polygonal curves.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - Image.</dd>
<dd><code>pts</code> - Array of polygonal curves.</dd>
<dd><code>isClosed</code> - Flag indicating whether the drawn polylines are closed or not. If they are closed,
 the function draws a line from the last vertex of each curve to its first vertex.</dd>
<dd><code>color</code> - Polyline color.</dd>
<dd><code>thickness</code> - Thickness of the polyline edges.</dd>
<dd><code>lineType</code> - Type of the line segments. See #LineTypes</dd>
<dd><code>shift</code> - Number of fractional bits in the vertex coordinates.

 The function cv::polylines draws one or more polygonal curves.</dd>
</dl>
</li>
</ul>
<a name="preCornerDetect-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>preCornerDetect</h4>
<pre>public static&nbsp;void&nbsp;preCornerDetect(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                   int&nbsp;ksize)</pre>
<div class="block">Calculates a feature map for corner detection.

 The function calculates the complex spatial derivative-based function of the source image

 \(\texttt{dst} = (D_x  \texttt{src} )^2  \cdot D_{yy}  \texttt{src} + (D_y  \texttt{src} )^2  \cdot D_{xx}  \texttt{src} - 2 D_x  \texttt{src} \cdot D_y  \texttt{src} \cdot D_{xy}  \texttt{src}\)

 where \(D_x\),\(D_y\) are the first image derivatives, \(D_{xx}\),\(D_{yy}\) are the second image
 derivatives, and \(D_{xy}\) is the mixed derivative.

 The corners can be found as local maximums of the functions, as shown below:
 <code>
     Mat corners, dilated_corners;
     preCornerDetect(image, corners, 3);
     // dilation with 3x3 rectangular structuring element
     dilate(corners, dilated_corners, Mat(), 1);
     Mat corner_mask = corners == dilated_corners;
 </code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Source single-channel 8-bit of floating-point image.</dd>
<dd><code>dst</code> - Output image that has the type CV_32F and the same size as src .</dd>
<dd><code>ksize</code> - %Aperture size of the Sobel .</dd>
</dl>
</li>
</ul>
<a name="preCornerDetect-org.opencv.core.Mat-org.opencv.core.Mat-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>preCornerDetect</h4>
<pre>public static&nbsp;void&nbsp;preCornerDetect(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                   int&nbsp;ksize,
                                   int&nbsp;borderType)</pre>
<div class="block">Calculates a feature map for corner detection.

 The function calculates the complex spatial derivative-based function of the source image

 \(\texttt{dst} = (D_x  \texttt{src} )^2  \cdot D_{yy}  \texttt{src} + (D_y  \texttt{src} )^2  \cdot D_{xx}  \texttt{src} - 2 D_x  \texttt{src} \cdot D_y  \texttt{src} \cdot D_{xy}  \texttt{src}\)

 where \(D_x\),\(D_y\) are the first image derivatives, \(D_{xx}\),\(D_{yy}\) are the second image
 derivatives, and \(D_{xy}\) is the mixed derivative.

 The corners can be found as local maximums of the functions, as shown below:
 <code>
     Mat corners, dilated_corners;
     preCornerDetect(image, corners, 3);
     // dilation with 3x3 rectangular structuring element
     dilate(corners, dilated_corners, Mat(), 1);
     Mat corner_mask = corners == dilated_corners;
 </code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Source single-channel 8-bit of floating-point image.</dd>
<dd><code>dst</code> - Output image that has the type CV_32F and the same size as src .</dd>
<dd><code>ksize</code> - %Aperture size of the Sobel .</dd>
<dd><code>borderType</code> - Pixel extrapolation method. See #BorderTypes. #BORDER_WRAP is not supported.</dd>
</dl>
</li>
</ul>
<a name="putText-org.opencv.core.Mat-java.lang.String-org.opencv.core.Point-int-double-org.opencv.core.Scalar-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>putText</h4>
<pre>public static&nbsp;void&nbsp;putText(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                           java.lang.String&nbsp;text,
                           <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;org,
                           int&nbsp;fontFace,
                           double&nbsp;fontScale,
                           <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color)</pre>
<div class="block">Draws a text string.

 The function cv::putText renders the specified text string in the image. Symbols that cannot be rendered
 using the specified font are replaced by question marks. See #getTextSize for a text rendering code
 example.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - Image.</dd>
<dd><code>text</code> - Text string to be drawn.</dd>
<dd><code>org</code> - Bottom-left corner of the text string in the image.</dd>
<dd><code>fontFace</code> - Font type, see #HersheyFonts.</dd>
<dd><code>fontScale</code> - Font scale factor that is multiplied by the font-specific base size.</dd>
<dd><code>color</code> - Text color.
 it is at the top-left corner.</dd>
</dl>
</li>
</ul>
<a name="putText-org.opencv.core.Mat-java.lang.String-org.opencv.core.Point-int-double-org.opencv.core.Scalar-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>putText</h4>
<pre>public static&nbsp;void&nbsp;putText(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                           java.lang.String&nbsp;text,
                           <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;org,
                           int&nbsp;fontFace,
                           double&nbsp;fontScale,
                           <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
                           int&nbsp;thickness)</pre>
<div class="block">Draws a text string.

 The function cv::putText renders the specified text string in the image. Symbols that cannot be rendered
 using the specified font are replaced by question marks. See #getTextSize for a text rendering code
 example.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - Image.</dd>
<dd><code>text</code> - Text string to be drawn.</dd>
<dd><code>org</code> - Bottom-left corner of the text string in the image.</dd>
<dd><code>fontFace</code> - Font type, see #HersheyFonts.</dd>
<dd><code>fontScale</code> - Font scale factor that is multiplied by the font-specific base size.</dd>
<dd><code>color</code> - Text color.</dd>
<dd><code>thickness</code> - Thickness of the lines used to draw a text.
 it is at the top-left corner.</dd>
</dl>
</li>
</ul>
<a name="putText-org.opencv.core.Mat-java.lang.String-org.opencv.core.Point-int-double-org.opencv.core.Scalar-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>putText</h4>
<pre>public static&nbsp;void&nbsp;putText(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                           java.lang.String&nbsp;text,
                           <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;org,
                           int&nbsp;fontFace,
                           double&nbsp;fontScale,
                           <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
                           int&nbsp;thickness,
                           int&nbsp;lineType)</pre>
<div class="block">Draws a text string.

 The function cv::putText renders the specified text string in the image. Symbols that cannot be rendered
 using the specified font are replaced by question marks. See #getTextSize for a text rendering code
 example.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - Image.</dd>
<dd><code>text</code> - Text string to be drawn.</dd>
<dd><code>org</code> - Bottom-left corner of the text string in the image.</dd>
<dd><code>fontFace</code> - Font type, see #HersheyFonts.</dd>
<dd><code>fontScale</code> - Font scale factor that is multiplied by the font-specific base size.</dd>
<dd><code>color</code> - Text color.</dd>
<dd><code>thickness</code> - Thickness of the lines used to draw a text.</dd>
<dd><code>lineType</code> - Line type. See #LineTypes
 it is at the top-left corner.</dd>
</dl>
</li>
</ul>
<a name="putText-org.opencv.core.Mat-java.lang.String-org.opencv.core.Point-int-double-org.opencv.core.Scalar-int-int-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>putText</h4>
<pre>public static&nbsp;void&nbsp;putText(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                           java.lang.String&nbsp;text,
                           <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;org,
                           int&nbsp;fontFace,
                           double&nbsp;fontScale,
                           <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
                           int&nbsp;thickness,
                           int&nbsp;lineType,
                           boolean&nbsp;bottomLeftOrigin)</pre>
<div class="block">Draws a text string.

 The function cv::putText renders the specified text string in the image. Symbols that cannot be rendered
 using the specified font are replaced by question marks. See #getTextSize for a text rendering code
 example.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - Image.</dd>
<dd><code>text</code> - Text string to be drawn.</dd>
<dd><code>org</code> - Bottom-left corner of the text string in the image.</dd>
<dd><code>fontFace</code> - Font type, see #HersheyFonts.</dd>
<dd><code>fontScale</code> - Font scale factor that is multiplied by the font-specific base size.</dd>
<dd><code>color</code> - Text color.</dd>
<dd><code>thickness</code> - Thickness of the lines used to draw a text.</dd>
<dd><code>lineType</code> - Line type. See #LineTypes</dd>
<dd><code>bottomLeftOrigin</code> - When true, the image data origin is at the bottom-left corner. Otherwise,
 it is at the top-left corner.</dd>
</dl>
</li>
</ul>
<a name="pyrDown-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pyrDown</h4>
<pre>public static&nbsp;void&nbsp;pyrDown(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block">Blurs an image and downsamples it.

 By default, size of the output image is computed as <code>Size((src.cols+1)/2, (src.rows+1)/2)</code>, but in
 any case, the following conditions should be satisfied:

 \(\begin{array}{l} | \texttt{dstsize.width} *2-src.cols| \leq 2 \\ | \texttt{dstsize.height} *2-src.rows| \leq 2 \end{array}\)

 The function performs the downsampling step of the Gaussian pyramid construction. First, it
 convolves the source image with the kernel:

 \(\frac{1}{256} \begin{bmatrix} 1 &amp; 4 &amp; 6 &amp; 4 &amp; 1  \\ 4 &amp; 16 &amp; 24 &amp; 16 &amp; 4  \\ 6 &amp; 24 &amp; 36 &amp; 24 &amp; 6  \\ 4 &amp; 16 &amp; 24 &amp; 16 &amp; 4  \\ 1 &amp; 4 &amp; 6 &amp; 4 &amp; 1 \end{bmatrix}\)

 Then, it downsamples the image by rejecting even rows and columns.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image.</dd>
<dd><code>dst</code> - output image; it has the specified size and the same type as src.</dd>
</dl>
</li>
</ul>
<a name="pyrDown-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pyrDown</h4>
<pre>public static&nbsp;void&nbsp;pyrDown(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                           <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dstsize)</pre>
<div class="block">Blurs an image and downsamples it.

 By default, size of the output image is computed as <code>Size((src.cols+1)/2, (src.rows+1)/2)</code>, but in
 any case, the following conditions should be satisfied:

 \(\begin{array}{l} | \texttt{dstsize.width} *2-src.cols| \leq 2 \\ | \texttt{dstsize.height} *2-src.rows| \leq 2 \end{array}\)

 The function performs the downsampling step of the Gaussian pyramid construction. First, it
 convolves the source image with the kernel:

 \(\frac{1}{256} \begin{bmatrix} 1 &amp; 4 &amp; 6 &amp; 4 &amp; 1  \\ 4 &amp; 16 &amp; 24 &amp; 16 &amp; 4  \\ 6 &amp; 24 &amp; 36 &amp; 24 &amp; 6  \\ 4 &amp; 16 &amp; 24 &amp; 16 &amp; 4  \\ 1 &amp; 4 &amp; 6 &amp; 4 &amp; 1 \end{bmatrix}\)

 Then, it downsamples the image by rejecting even rows and columns.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image.</dd>
<dd><code>dst</code> - output image; it has the specified size and the same type as src.</dd>
<dd><code>dstsize</code> - size of the output image.</dd>
</dl>
</li>
</ul>
<a name="pyrDown-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pyrDown</h4>
<pre>public static&nbsp;void&nbsp;pyrDown(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                           <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dstsize,
                           int&nbsp;borderType)</pre>
<div class="block">Blurs an image and downsamples it.

 By default, size of the output image is computed as <code>Size((src.cols+1)/2, (src.rows+1)/2)</code>, but in
 any case, the following conditions should be satisfied:

 \(\begin{array}{l} | \texttt{dstsize.width} *2-src.cols| \leq 2 \\ | \texttt{dstsize.height} *2-src.rows| \leq 2 \end{array}\)

 The function performs the downsampling step of the Gaussian pyramid construction. First, it
 convolves the source image with the kernel:

 \(\frac{1}{256} \begin{bmatrix} 1 &amp; 4 &amp; 6 &amp; 4 &amp; 1  \\ 4 &amp; 16 &amp; 24 &amp; 16 &amp; 4  \\ 6 &amp; 24 &amp; 36 &amp; 24 &amp; 6  \\ 4 &amp; 16 &amp; 24 &amp; 16 &amp; 4  \\ 1 &amp; 4 &amp; 6 &amp; 4 &amp; 1 \end{bmatrix}\)

 Then, it downsamples the image by rejecting even rows and columns.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image.</dd>
<dd><code>dst</code> - output image; it has the specified size and the same type as src.</dd>
<dd><code>dstsize</code> - size of the output image.</dd>
<dd><code>borderType</code> - Pixel extrapolation method, see #BorderTypes (#BORDER_CONSTANT isn't supported)</dd>
</dl>
</li>
</ul>
<a name="pyrMeanShiftFiltering-org.opencv.core.Mat-org.opencv.core.Mat-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pyrMeanShiftFiltering</h4>
<pre>public static&nbsp;void&nbsp;pyrMeanShiftFiltering(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                         double&nbsp;sp,
                                         double&nbsp;sr)</pre>
<div class="block">Performs initial step of meanshift segmentation of an image.

 The function implements the filtering stage of meanshift segmentation, that is, the output of the
 function is the filtered "posterized" image with color gradients and fine-grain texture flattened.
 At every pixel (X,Y) of the input image (or down-sized input image, see below) the function executes
 meanshift iterations, that is, the pixel (X,Y) neighborhood in the joint space-color hyperspace is
 considered:

 \((x,y): X- \texttt{sp} \le x  \le X+ \texttt{sp} , Y- \texttt{sp} \le y  \le Y+ \texttt{sp} , ||(R,G,B)-(r,g,b)||   \le \texttt{sr}\)

 where (R,G,B) and (r,g,b) are the vectors of color components at (X,Y) and (x,y), respectively
 (though, the algorithm does not depend on the color space used, so any 3-component color space can
 be used instead). Over the neighborhood the average spatial value (X',Y') and average color vector
 (R',G',B') are found and they act as the neighborhood center on the next iteration:

 \((X,Y)~(X',Y'), (R,G,B)~(R',G',B').\)

 After the iterations over, the color components of the initial pixel (that is, the pixel from where
 the iterations started) are set to the final value (average color at the last iteration):

 \(I(X,Y) &lt;- (R*,G*,B*)\)

 When maxLevel &gt; 0, the gaussian pyramid of maxLevel+1 levels is built, and the above procedure is
 run on the smallest layer first. After that, the results are propagated to the larger layer and the
 iterations are run again only on those pixels where the layer colors differ by more than sr from the
 lower-resolution layer of the pyramid. That makes boundaries of color regions sharper. Note that the
 results will be actually different from the ones obtained by running the meanshift procedure on the
 whole original image (i.e. when maxLevel==0).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - The source 8-bit, 3-channel image.</dd>
<dd><code>dst</code> - The destination image of the same format and the same size as the source.</dd>
<dd><code>sp</code> - The spatial window radius.</dd>
<dd><code>sr</code> - The color window radius.</dd>
</dl>
</li>
</ul>
<a name="pyrMeanShiftFiltering-org.opencv.core.Mat-org.opencv.core.Mat-double-double-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pyrMeanShiftFiltering</h4>
<pre>public static&nbsp;void&nbsp;pyrMeanShiftFiltering(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                         double&nbsp;sp,
                                         double&nbsp;sr,
                                         int&nbsp;maxLevel)</pre>
<div class="block">Performs initial step of meanshift segmentation of an image.

 The function implements the filtering stage of meanshift segmentation, that is, the output of the
 function is the filtered "posterized" image with color gradients and fine-grain texture flattened.
 At every pixel (X,Y) of the input image (or down-sized input image, see below) the function executes
 meanshift iterations, that is, the pixel (X,Y) neighborhood in the joint space-color hyperspace is
 considered:

 \((x,y): X- \texttt{sp} \le x  \le X+ \texttt{sp} , Y- \texttt{sp} \le y  \le Y+ \texttt{sp} , ||(R,G,B)-(r,g,b)||   \le \texttt{sr}\)

 where (R,G,B) and (r,g,b) are the vectors of color components at (X,Y) and (x,y), respectively
 (though, the algorithm does not depend on the color space used, so any 3-component color space can
 be used instead). Over the neighborhood the average spatial value (X',Y') and average color vector
 (R',G',B') are found and they act as the neighborhood center on the next iteration:

 \((X,Y)~(X',Y'), (R,G,B)~(R',G',B').\)

 After the iterations over, the color components of the initial pixel (that is, the pixel from where
 the iterations started) are set to the final value (average color at the last iteration):

 \(I(X,Y) &lt;- (R*,G*,B*)\)

 When maxLevel &gt; 0, the gaussian pyramid of maxLevel+1 levels is built, and the above procedure is
 run on the smallest layer first. After that, the results are propagated to the larger layer and the
 iterations are run again only on those pixels where the layer colors differ by more than sr from the
 lower-resolution layer of the pyramid. That makes boundaries of color regions sharper. Note that the
 results will be actually different from the ones obtained by running the meanshift procedure on the
 whole original image (i.e. when maxLevel==0).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - The source 8-bit, 3-channel image.</dd>
<dd><code>dst</code> - The destination image of the same format and the same size as the source.</dd>
<dd><code>sp</code> - The spatial window radius.</dd>
<dd><code>sr</code> - The color window radius.</dd>
<dd><code>maxLevel</code> - Maximum level of the pyramid for the segmentation.</dd>
</dl>
</li>
</ul>
<a name="pyrMeanShiftFiltering-org.opencv.core.Mat-org.opencv.core.Mat-double-double-int-org.opencv.core.TermCriteria-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pyrMeanShiftFiltering</h4>
<pre>public static&nbsp;void&nbsp;pyrMeanShiftFiltering(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                         double&nbsp;sp,
                                         double&nbsp;sr,
                                         int&nbsp;maxLevel,
                                         <a href="../../../org/opencv/core/TermCriteria.html" title="class in org.opencv.core">TermCriteria</a>&nbsp;termcrit)</pre>
<div class="block">Performs initial step of meanshift segmentation of an image.

 The function implements the filtering stage of meanshift segmentation, that is, the output of the
 function is the filtered "posterized" image with color gradients and fine-grain texture flattened.
 At every pixel (X,Y) of the input image (or down-sized input image, see below) the function executes
 meanshift iterations, that is, the pixel (X,Y) neighborhood in the joint space-color hyperspace is
 considered:

 \((x,y): X- \texttt{sp} \le x  \le X+ \texttt{sp} , Y- \texttt{sp} \le y  \le Y+ \texttt{sp} , ||(R,G,B)-(r,g,b)||   \le \texttt{sr}\)

 where (R,G,B) and (r,g,b) are the vectors of color components at (X,Y) and (x,y), respectively
 (though, the algorithm does not depend on the color space used, so any 3-component color space can
 be used instead). Over the neighborhood the average spatial value (X',Y') and average color vector
 (R',G',B') are found and they act as the neighborhood center on the next iteration:

 \((X,Y)~(X',Y'), (R,G,B)~(R',G',B').\)

 After the iterations over, the color components of the initial pixel (that is, the pixel from where
 the iterations started) are set to the final value (average color at the last iteration):

 \(I(X,Y) &lt;- (R*,G*,B*)\)

 When maxLevel &gt; 0, the gaussian pyramid of maxLevel+1 levels is built, and the above procedure is
 run on the smallest layer first. After that, the results are propagated to the larger layer and the
 iterations are run again only on those pixels where the layer colors differ by more than sr from the
 lower-resolution layer of the pyramid. That makes boundaries of color regions sharper. Note that the
 results will be actually different from the ones obtained by running the meanshift procedure on the
 whole original image (i.e. when maxLevel==0).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - The source 8-bit, 3-channel image.</dd>
<dd><code>dst</code> - The destination image of the same format and the same size as the source.</dd>
<dd><code>sp</code> - The spatial window radius.</dd>
<dd><code>sr</code> - The color window radius.</dd>
<dd><code>maxLevel</code> - Maximum level of the pyramid for the segmentation.</dd>
<dd><code>termcrit</code> - Termination criteria: when to stop meanshift iterations.</dd>
</dl>
</li>
</ul>
<a name="pyrUp-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pyrUp</h4>
<pre>public static&nbsp;void&nbsp;pyrUp(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block">Upsamples an image and then blurs it.

 By default, size of the output image is computed as <code>Size(src.cols\*2, (src.rows\*2)</code>, but in any
 case, the following conditions should be satisfied:

 \(\begin{array}{l} | \texttt{dstsize.width} -src.cols*2| \leq  ( \texttt{dstsize.width}   \mod  2)  \\ | \texttt{dstsize.height} -src.rows*2| \leq  ( \texttt{dstsize.height}   \mod  2) \end{array}\)

 The function performs the upsampling step of the Gaussian pyramid construction, though it can
 actually be used to construct the Laplacian pyramid. First, it upsamples the source image by
 injecting even zero rows and columns and then convolves the result with the same kernel as in
 pyrDown multiplied by 4.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image.</dd>
<dd><code>dst</code> - output image. It has the specified size and the same type as src .</dd>
</dl>
</li>
</ul>
<a name="pyrUp-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pyrUp</h4>
<pre>public static&nbsp;void&nbsp;pyrUp(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                         <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dstsize)</pre>
<div class="block">Upsamples an image and then blurs it.

 By default, size of the output image is computed as <code>Size(src.cols\*2, (src.rows\*2)</code>, but in any
 case, the following conditions should be satisfied:

 \(\begin{array}{l} | \texttt{dstsize.width} -src.cols*2| \leq  ( \texttt{dstsize.width}   \mod  2)  \\ | \texttt{dstsize.height} -src.rows*2| \leq  ( \texttt{dstsize.height}   \mod  2) \end{array}\)

 The function performs the upsampling step of the Gaussian pyramid construction, though it can
 actually be used to construct the Laplacian pyramid. First, it upsamples the source image by
 injecting even zero rows and columns and then convolves the result with the same kernel as in
 pyrDown multiplied by 4.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image.</dd>
<dd><code>dst</code> - output image. It has the specified size and the same type as src .</dd>
<dd><code>dstsize</code> - size of the output image.</dd>
</dl>
</li>
</ul>
<a name="pyrUp-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pyrUp</h4>
<pre>public static&nbsp;void&nbsp;pyrUp(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                         <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dstsize,
                         int&nbsp;borderType)</pre>
<div class="block">Upsamples an image and then blurs it.

 By default, size of the output image is computed as <code>Size(src.cols\*2, (src.rows\*2)</code>, but in any
 case, the following conditions should be satisfied:

 \(\begin{array}{l} | \texttt{dstsize.width} -src.cols*2| \leq  ( \texttt{dstsize.width}   \mod  2)  \\ | \texttt{dstsize.height} -src.rows*2| \leq  ( \texttt{dstsize.height}   \mod  2) \end{array}\)

 The function performs the upsampling step of the Gaussian pyramid construction, though it can
 actually be used to construct the Laplacian pyramid. First, it upsamples the source image by
 injecting even zero rows and columns and then convolves the result with the same kernel as in
 pyrDown multiplied by 4.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image.</dd>
<dd><code>dst</code> - output image. It has the specified size and the same type as src .</dd>
<dd><code>dstsize</code> - size of the output image.</dd>
<dd><code>borderType</code> - Pixel extrapolation method, see #BorderTypes (only #BORDER_DEFAULT is supported)</dd>
</dl>
</li>
</ul>
<a name="rectangle-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Point-org.opencv.core.Scalar-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>rectangle</h4>
<pre>public static&nbsp;void&nbsp;rectangle(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                             <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt1,
                             <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt2,
                             <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color)</pre>
<div class="block">Draws a simple, thick, or filled up-right rectangle.

 The function cv::rectangle draws a rectangle outline or a filled rectangle whose two opposite corners
 are pt1 and pt2.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - Image.</dd>
<dd><code>pt1</code> - Vertex of the rectangle.</dd>
<dd><code>pt2</code> - Vertex of the rectangle opposite to pt1 .</dd>
<dd><code>color</code> - Rectangle color or brightness (grayscale image).
 mean that the function has to draw a filled rectangle.</dd>
</dl>
</li>
</ul>
<a name="rectangle-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Point-org.opencv.core.Scalar-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>rectangle</h4>
<pre>public static&nbsp;void&nbsp;rectangle(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                             <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt1,
                             <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt2,
                             <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
                             int&nbsp;thickness)</pre>
<div class="block">Draws a simple, thick, or filled up-right rectangle.

 The function cv::rectangle draws a rectangle outline or a filled rectangle whose two opposite corners
 are pt1 and pt2.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - Image.</dd>
<dd><code>pt1</code> - Vertex of the rectangle.</dd>
<dd><code>pt2</code> - Vertex of the rectangle opposite to pt1 .</dd>
<dd><code>color</code> - Rectangle color or brightness (grayscale image).</dd>
<dd><code>thickness</code> - Thickness of lines that make up the rectangle. Negative values, like #FILLED,
 mean that the function has to draw a filled rectangle.</dd>
</dl>
</li>
</ul>
<a name="rectangle-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Point-org.opencv.core.Scalar-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>rectangle</h4>
<pre>public static&nbsp;void&nbsp;rectangle(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                             <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt1,
                             <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt2,
                             <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
                             int&nbsp;thickness,
                             int&nbsp;lineType)</pre>
<div class="block">Draws a simple, thick, or filled up-right rectangle.

 The function cv::rectangle draws a rectangle outline or a filled rectangle whose two opposite corners
 are pt1 and pt2.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - Image.</dd>
<dd><code>pt1</code> - Vertex of the rectangle.</dd>
<dd><code>pt2</code> - Vertex of the rectangle opposite to pt1 .</dd>
<dd><code>color</code> - Rectangle color or brightness (grayscale image).</dd>
<dd><code>thickness</code> - Thickness of lines that make up the rectangle. Negative values, like #FILLED,
 mean that the function has to draw a filled rectangle.</dd>
<dd><code>lineType</code> - Type of the line. See #LineTypes</dd>
</dl>
</li>
</ul>
<a name="rectangle-org.opencv.core.Mat-org.opencv.core.Point-org.opencv.core.Point-org.opencv.core.Scalar-int-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>rectangle</h4>
<pre>public static&nbsp;void&nbsp;rectangle(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                             <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt1,
                             <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;pt2,
                             <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
                             int&nbsp;thickness,
                             int&nbsp;lineType,
                             int&nbsp;shift)</pre>
<div class="block">Draws a simple, thick, or filled up-right rectangle.

 The function cv::rectangle draws a rectangle outline or a filled rectangle whose two opposite corners
 are pt1 and pt2.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - Image.</dd>
<dd><code>pt1</code> - Vertex of the rectangle.</dd>
<dd><code>pt2</code> - Vertex of the rectangle opposite to pt1 .</dd>
<dd><code>color</code> - Rectangle color or brightness (grayscale image).</dd>
<dd><code>thickness</code> - Thickness of lines that make up the rectangle. Negative values, like #FILLED,
 mean that the function has to draw a filled rectangle.</dd>
<dd><code>lineType</code> - Type of the line. See #LineTypes</dd>
<dd><code>shift</code> - Number of fractional bits in the point coordinates.</dd>
</dl>
</li>
</ul>
<a name="rectangle-org.opencv.core.Mat-org.opencv.core.Rect-org.opencv.core.Scalar-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>rectangle</h4>
<pre>public static&nbsp;void&nbsp;rectangle(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                             <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;rec,
                             <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color)</pre>
<div class="block">use <code>rec</code> parameter as alternative specification of the drawn rectangle: `r.tl() and
 r.br()-Point(1,1)` are opposite corners</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - automatically generated</dd>
<dd><code>rec</code> - automatically generated</dd>
<dd><code>color</code> - automatically generated</dd>
</dl>
</li>
</ul>
<a name="rectangle-org.opencv.core.Mat-org.opencv.core.Rect-org.opencv.core.Scalar-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>rectangle</h4>
<pre>public static&nbsp;void&nbsp;rectangle(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                             <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;rec,
                             <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
                             int&nbsp;thickness)</pre>
<div class="block">use <code>rec</code> parameter as alternative specification of the drawn rectangle: `r.tl() and
 r.br()-Point(1,1)` are opposite corners</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - automatically generated</dd>
<dd><code>rec</code> - automatically generated</dd>
<dd><code>color</code> - automatically generated</dd>
<dd><code>thickness</code> - automatically generated</dd>
</dl>
</li>
</ul>
<a name="rectangle-org.opencv.core.Mat-org.opencv.core.Rect-org.opencv.core.Scalar-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>rectangle</h4>
<pre>public static&nbsp;void&nbsp;rectangle(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                             <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;rec,
                             <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
                             int&nbsp;thickness,
                             int&nbsp;lineType)</pre>
<div class="block">use <code>rec</code> parameter as alternative specification of the drawn rectangle: `r.tl() and
 r.br()-Point(1,1)` are opposite corners</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - automatically generated</dd>
<dd><code>rec</code> - automatically generated</dd>
<dd><code>color</code> - automatically generated</dd>
<dd><code>thickness</code> - automatically generated</dd>
<dd><code>lineType</code> - automatically generated</dd>
</dl>
</li>
</ul>
<a name="rectangle-org.opencv.core.Mat-org.opencv.core.Rect-org.opencv.core.Scalar-int-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>rectangle</h4>
<pre>public static&nbsp;void&nbsp;rectangle(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;img,
                             <a href="../../../org/opencv/core/Rect.html" title="class in org.opencv.core">Rect</a>&nbsp;rec,
                             <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;color,
                             int&nbsp;thickness,
                             int&nbsp;lineType,
                             int&nbsp;shift)</pre>
<div class="block">use <code>rec</code> parameter as alternative specification of the drawn rectangle: `r.tl() and
 r.br()-Point(1,1)` are opposite corners</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>img</code> - automatically generated</dd>
<dd><code>rec</code> - automatically generated</dd>
<dd><code>color</code> - automatically generated</dd>
<dd><code>thickness</code> - automatically generated</dd>
<dd><code>lineType</code> - automatically generated</dd>
<dd><code>shift</code> - automatically generated</dd>
</dl>
</li>
</ul>
<a name="remap-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>remap</h4>
<pre>public static&nbsp;void&nbsp;remap(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map1,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map2,
                         int&nbsp;interpolation)</pre>
<div class="block">Applies a generic geometrical transformation to an image.

 The function remap transforms the source image using the specified map:

 \(\texttt{dst} (x,y) =  \texttt{src} (map_x(x,y),map_y(x,y))\)

 where values of pixels with non-integer coordinates are computed using one of available
 interpolation methods. \(map_x\) and \(map_y\) can be encoded as separate floating-point maps
 in \(map_1\) and \(map_2\) respectively, or interleaved floating-point maps of \((x,y)\) in
 \(map_1\), or fixed-point maps created by using #convertMaps. The reason you might want to
 convert from floating to fixed-point representations of a map is that they can yield much faster
 (\~2x) remapping operations. In the converted case, \(map_1\) contains pairs (cvFloor(x),
 cvFloor(y)) and \(map_2\) contains indices in a table of interpolation coefficients.

 This function cannot operate in-place.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Source image.</dd>
<dd><code>dst</code> - Destination image. It has the same size as map1 and the same type as src .</dd>
<dd><code>map1</code> - The first map of either (x,y) points or just x values having the type CV_16SC2 ,
 CV_32FC1, or CV_32FC2. See #convertMaps for details on converting a floating point
 representation to fixed-point for speed.</dd>
<dd><code>map2</code> - The second map of y values having the type CV_16UC1, CV_32FC1, or none (empty map
 if map1 is (x,y) points), respectively.</dd>
<dd><code>interpolation</code> - Interpolation method (see #InterpolationFlags). The methods #INTER_AREA
 and #INTER_LINEAR_EXACT are not supported by this function.
 borderMode=#BORDER_TRANSPARENT, it means that the pixels in the destination image that
 corresponds to the "outliers" in the source image are not modified by the function.
 <b>Note:</b>
 Due to current implementation limitations the size of an input and output images should be less than 32767x32767.</dd>
</dl>
</li>
</ul>
<a name="remap-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>remap</h4>
<pre>public static&nbsp;void&nbsp;remap(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map1,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map2,
                         int&nbsp;interpolation,
                         int&nbsp;borderMode)</pre>
<div class="block">Applies a generic geometrical transformation to an image.

 The function remap transforms the source image using the specified map:

 \(\texttt{dst} (x,y) =  \texttt{src} (map_x(x,y),map_y(x,y))\)

 where values of pixels with non-integer coordinates are computed using one of available
 interpolation methods. \(map_x\) and \(map_y\) can be encoded as separate floating-point maps
 in \(map_1\) and \(map_2\) respectively, or interleaved floating-point maps of \((x,y)\) in
 \(map_1\), or fixed-point maps created by using #convertMaps. The reason you might want to
 convert from floating to fixed-point representations of a map is that they can yield much faster
 (\~2x) remapping operations. In the converted case, \(map_1\) contains pairs (cvFloor(x),
 cvFloor(y)) and \(map_2\) contains indices in a table of interpolation coefficients.

 This function cannot operate in-place.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Source image.</dd>
<dd><code>dst</code> - Destination image. It has the same size as map1 and the same type as src .</dd>
<dd><code>map1</code> - The first map of either (x,y) points or just x values having the type CV_16SC2 ,
 CV_32FC1, or CV_32FC2. See #convertMaps for details on converting a floating point
 representation to fixed-point for speed.</dd>
<dd><code>map2</code> - The second map of y values having the type CV_16UC1, CV_32FC1, or none (empty map
 if map1 is (x,y) points), respectively.</dd>
<dd><code>interpolation</code> - Interpolation method (see #InterpolationFlags). The methods #INTER_AREA
 and #INTER_LINEAR_EXACT are not supported by this function.</dd>
<dd><code>borderMode</code> - Pixel extrapolation method (see #BorderTypes). When
 borderMode=#BORDER_TRANSPARENT, it means that the pixels in the destination image that
 corresponds to the "outliers" in the source image are not modified by the function.
 <b>Note:</b>
 Due to current implementation limitations the size of an input and output images should be less than 32767x32767.</dd>
</dl>
</li>
</ul>
<a name="remap-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-int-org.opencv.core.Scalar-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>remap</h4>
<pre>public static&nbsp;void&nbsp;remap(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map1,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;map2,
                         int&nbsp;interpolation,
                         int&nbsp;borderMode,
                         <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;borderValue)</pre>
<div class="block">Applies a generic geometrical transformation to an image.

 The function remap transforms the source image using the specified map:

 \(\texttt{dst} (x,y) =  \texttt{src} (map_x(x,y),map_y(x,y))\)

 where values of pixels with non-integer coordinates are computed using one of available
 interpolation methods. \(map_x\) and \(map_y\) can be encoded as separate floating-point maps
 in \(map_1\) and \(map_2\) respectively, or interleaved floating-point maps of \((x,y)\) in
 \(map_1\), or fixed-point maps created by using #convertMaps. The reason you might want to
 convert from floating to fixed-point representations of a map is that they can yield much faster
 (\~2x) remapping operations. In the converted case, \(map_1\) contains pairs (cvFloor(x),
 cvFloor(y)) and \(map_2\) contains indices in a table of interpolation coefficients.

 This function cannot operate in-place.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Source image.</dd>
<dd><code>dst</code> - Destination image. It has the same size as map1 and the same type as src .</dd>
<dd><code>map1</code> - The first map of either (x,y) points or just x values having the type CV_16SC2 ,
 CV_32FC1, or CV_32FC2. See #convertMaps for details on converting a floating point
 representation to fixed-point for speed.</dd>
<dd><code>map2</code> - The second map of y values having the type CV_16UC1, CV_32FC1, or none (empty map
 if map1 is (x,y) points), respectively.</dd>
<dd><code>interpolation</code> - Interpolation method (see #InterpolationFlags). The methods #INTER_AREA
 and #INTER_LINEAR_EXACT are not supported by this function.</dd>
<dd><code>borderMode</code> - Pixel extrapolation method (see #BorderTypes). When
 borderMode=#BORDER_TRANSPARENT, it means that the pixels in the destination image that
 corresponds to the "outliers" in the source image are not modified by the function.</dd>
<dd><code>borderValue</code> - Value used in case of a constant border. By default, it is 0.
 <b>Note:</b>
 Due to current implementation limitations the size of an input and output images should be less than 32767x32767.</dd>
</dl>
</li>
</ul>
<a name="resize-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>resize</h4>
<pre>public static&nbsp;void&nbsp;resize(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                          <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dsize)</pre>
<div class="block">Resizes an image.

 The function resize resizes the image src down to or up to the specified size. Note that the
 initial dst type or size are not taken into account. Instead, the size and type are derived from
 the <code>src</code>,<code>dsize</code>,<code>fx</code>, and <code>fy</code>. If you want to resize src so that it fits the pre-created dst,
 you may call the function as follows:
 <code>
     // explicitly specify dsize=dst.size(); fx and fy will be computed from that.
     resize(src, dst, dst.size(), 0, 0, interpolation);
 </code>
 If you want to decimate the image by factor of 2 in each direction, you can call the function this
 way:
 <code>
     // specify fx and fy and let the function compute the destination image size.
     resize(src, dst, Size(), 0.5, 0.5, interpolation);
 </code>
 To shrink an image, it will generally look best with #INTER_AREA interpolation, whereas to
 enlarge an image, it will generally look best with #INTER_CUBIC (slow) or #INTER_LINEAR
 (faster but still looks OK).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image.</dd>
<dd><code>dst</code> - output image; it has the size dsize (when it is non-zero) or the size computed from
 src.size(), fx, and fy; the type of dst is the same as of src.</dd>
<dd><code>dsize</code> - output image size; if it equals zero (<code>None</code> in Python), it is computed as:
  \(\texttt{dsize = Size(round(fx*src.cols), round(fy*src.rows))}\)
  Either dsize or both fx and fy must be non-zero.
 \(\texttt{(double)dsize.width/src.cols}\)
 \(\texttt{(double)dsize.height/src.rows}\)

 SEE:  warpAffine, warpPerspective, remap</dd>
</dl>
</li>
</ul>
<a name="resize-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>resize</h4>
<pre>public static&nbsp;void&nbsp;resize(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                          <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dsize,
                          double&nbsp;fx)</pre>
<div class="block">Resizes an image.

 The function resize resizes the image src down to or up to the specified size. Note that the
 initial dst type or size are not taken into account. Instead, the size and type are derived from
 the <code>src</code>,<code>dsize</code>,<code>fx</code>, and <code>fy</code>. If you want to resize src so that it fits the pre-created dst,
 you may call the function as follows:
 <code>
     // explicitly specify dsize=dst.size(); fx and fy will be computed from that.
     resize(src, dst, dst.size(), 0, 0, interpolation);
 </code>
 If you want to decimate the image by factor of 2 in each direction, you can call the function this
 way:
 <code>
     // specify fx and fy and let the function compute the destination image size.
     resize(src, dst, Size(), 0.5, 0.5, interpolation);
 </code>
 To shrink an image, it will generally look best with #INTER_AREA interpolation, whereas to
 enlarge an image, it will generally look best with #INTER_CUBIC (slow) or #INTER_LINEAR
 (faster but still looks OK).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image.</dd>
<dd><code>dst</code> - output image; it has the size dsize (when it is non-zero) or the size computed from
 src.size(), fx, and fy; the type of dst is the same as of src.</dd>
<dd><code>dsize</code> - output image size; if it equals zero (<code>None</code> in Python), it is computed as:
  \(\texttt{dsize = Size(round(fx*src.cols), round(fy*src.rows))}\)
  Either dsize or both fx and fy must be non-zero.</dd>
<dd><code>fx</code> - scale factor along the horizontal axis; when it equals 0, it is computed as
 \(\texttt{(double)dsize.width/src.cols}\)
 \(\texttt{(double)dsize.height/src.rows}\)

 SEE:  warpAffine, warpPerspective, remap</dd>
</dl>
</li>
</ul>
<a name="resize-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>resize</h4>
<pre>public static&nbsp;void&nbsp;resize(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                          <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dsize,
                          double&nbsp;fx,
                          double&nbsp;fy)</pre>
<div class="block">Resizes an image.

 The function resize resizes the image src down to or up to the specified size. Note that the
 initial dst type or size are not taken into account. Instead, the size and type are derived from
 the <code>src</code>,<code>dsize</code>,<code>fx</code>, and <code>fy</code>. If you want to resize src so that it fits the pre-created dst,
 you may call the function as follows:
 <code>
     // explicitly specify dsize=dst.size(); fx and fy will be computed from that.
     resize(src, dst, dst.size(), 0, 0, interpolation);
 </code>
 If you want to decimate the image by factor of 2 in each direction, you can call the function this
 way:
 <code>
     // specify fx and fy and let the function compute the destination image size.
     resize(src, dst, Size(), 0.5, 0.5, interpolation);
 </code>
 To shrink an image, it will generally look best with #INTER_AREA interpolation, whereas to
 enlarge an image, it will generally look best with #INTER_CUBIC (slow) or #INTER_LINEAR
 (faster but still looks OK).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image.</dd>
<dd><code>dst</code> - output image; it has the size dsize (when it is non-zero) or the size computed from
 src.size(), fx, and fy; the type of dst is the same as of src.</dd>
<dd><code>dsize</code> - output image size; if it equals zero (<code>None</code> in Python), it is computed as:
  \(\texttt{dsize = Size(round(fx*src.cols), round(fy*src.rows))}\)
  Either dsize or both fx and fy must be non-zero.</dd>
<dd><code>fx</code> - scale factor along the horizontal axis; when it equals 0, it is computed as
 \(\texttt{(double)dsize.width/src.cols}\)</dd>
<dd><code>fy</code> - scale factor along the vertical axis; when it equals 0, it is computed as
 \(\texttt{(double)dsize.height/src.rows}\)

 SEE:  warpAffine, warpPerspective, remap</dd>
</dl>
</li>
</ul>
<a name="resize-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-double-double-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>resize</h4>
<pre>public static&nbsp;void&nbsp;resize(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                          <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dsize,
                          double&nbsp;fx,
                          double&nbsp;fy,
                          int&nbsp;interpolation)</pre>
<div class="block">Resizes an image.

 The function resize resizes the image src down to or up to the specified size. Note that the
 initial dst type or size are not taken into account. Instead, the size and type are derived from
 the <code>src</code>,<code>dsize</code>,<code>fx</code>, and <code>fy</code>. If you want to resize src so that it fits the pre-created dst,
 you may call the function as follows:
 <code>
     // explicitly specify dsize=dst.size(); fx and fy will be computed from that.
     resize(src, dst, dst.size(), 0, 0, interpolation);
 </code>
 If you want to decimate the image by factor of 2 in each direction, you can call the function this
 way:
 <code>
     // specify fx and fy and let the function compute the destination image size.
     resize(src, dst, Size(), 0.5, 0.5, interpolation);
 </code>
 To shrink an image, it will generally look best with #INTER_AREA interpolation, whereas to
 enlarge an image, it will generally look best with #INTER_CUBIC (slow) or #INTER_LINEAR
 (faster but still looks OK).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image.</dd>
<dd><code>dst</code> - output image; it has the size dsize (when it is non-zero) or the size computed from
 src.size(), fx, and fy; the type of dst is the same as of src.</dd>
<dd><code>dsize</code> - output image size; if it equals zero (<code>None</code> in Python), it is computed as:
  \(\texttt{dsize = Size(round(fx*src.cols), round(fy*src.rows))}\)
  Either dsize or both fx and fy must be non-zero.</dd>
<dd><code>fx</code> - scale factor along the horizontal axis; when it equals 0, it is computed as
 \(\texttt{(double)dsize.width/src.cols}\)</dd>
<dd><code>fy</code> - scale factor along the vertical axis; when it equals 0, it is computed as
 \(\texttt{(double)dsize.height/src.rows}\)</dd>
<dd><code>interpolation</code> - interpolation method, see #InterpolationFlags

 SEE:  warpAffine, warpPerspective, remap</dd>
</dl>
</li>
</ul>
<a name="rotatedRectangleIntersection-org.opencv.core.RotatedRect-org.opencv.core.RotatedRect-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>rotatedRectangleIntersection</h4>
<pre>public static&nbsp;int&nbsp;rotatedRectangleIntersection(<a href="../../../org/opencv/core/RotatedRect.html" title="class in org.opencv.core">RotatedRect</a>&nbsp;rect1,
                                               <a href="../../../org/opencv/core/RotatedRect.html" title="class in org.opencv.core">RotatedRect</a>&nbsp;rect2,
                                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;intersectingRegion)</pre>
<div class="block">Finds out if there is any intersection between two rotated rectangles.

 If there is then the vertices of the intersecting region are returned as well.

 Below are some examples of intersection configurations. The hatched pattern indicates the
 intersecting region and the red vertices are returned by the function.

 ![intersection examples](pics/intersection.png)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>rect1</code> - First rectangle</dd>
<dd><code>rect2</code> - Second rectangle</dd>
<dd><code>intersectingRegion</code> - The output array of the vertices of the intersecting region. It returns
 at most 8 vertices. Stored as std::vector&lt;cv::Point2f&gt; or cv::Mat as Mx1 of type CV_32FC2.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>One of #RectanglesIntersectTypes</dd>
</dl>
</li>
</ul>
<a name="Scharr-org.opencv.core.Mat-org.opencv.core.Mat-int-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Scharr</h4>
<pre>public static&nbsp;void&nbsp;Scharr(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                          int&nbsp;ddepth,
                          int&nbsp;dx,
                          int&nbsp;dy)</pre>
<div class="block">Calculates the first x- or y- image derivative using Scharr operator.

 The function computes the first x- or y- spatial image derivative using the Scharr operator. The
 call

 \(\texttt{Scharr(src, dst, ddepth, dx, dy, scale, delta, borderType)}\)

 is equivalent to

 \(\texttt{Sobel(src, dst, ddepth, dx, dy, FILTER_SCHARR, scale, delta, borderType)} .\)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image.</dd>
<dd><code>dst</code> - output image of the same size and the same number of channels as src.</dd>
<dd><code>ddepth</code> - output image depth, see REF: filter_depths "combinations"</dd>
<dd><code>dx</code> - order of the derivative x.</dd>
<dd><code>dy</code> - order of the derivative y.
 applied (see #getDerivKernels for details).
 SEE:  cartToPolar</dd>
</dl>
</li>
</ul>
<a name="Scharr-org.opencv.core.Mat-org.opencv.core.Mat-int-int-int-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Scharr</h4>
<pre>public static&nbsp;void&nbsp;Scharr(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                          int&nbsp;ddepth,
                          int&nbsp;dx,
                          int&nbsp;dy,
                          double&nbsp;scale)</pre>
<div class="block">Calculates the first x- or y- image derivative using Scharr operator.

 The function computes the first x- or y- spatial image derivative using the Scharr operator. The
 call

 \(\texttt{Scharr(src, dst, ddepth, dx, dy, scale, delta, borderType)}\)

 is equivalent to

 \(\texttt{Sobel(src, dst, ddepth, dx, dy, FILTER_SCHARR, scale, delta, borderType)} .\)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image.</dd>
<dd><code>dst</code> - output image of the same size and the same number of channels as src.</dd>
<dd><code>ddepth</code> - output image depth, see REF: filter_depths "combinations"</dd>
<dd><code>dx</code> - order of the derivative x.</dd>
<dd><code>dy</code> - order of the derivative y.</dd>
<dd><code>scale</code> - optional scale factor for the computed derivative values; by default, no scaling is
 applied (see #getDerivKernels for details).
 SEE:  cartToPolar</dd>
</dl>
</li>
</ul>
<a name="Scharr-org.opencv.core.Mat-org.opencv.core.Mat-int-int-int-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Scharr</h4>
<pre>public static&nbsp;void&nbsp;Scharr(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                          int&nbsp;ddepth,
                          int&nbsp;dx,
                          int&nbsp;dy,
                          double&nbsp;scale,
                          double&nbsp;delta)</pre>
<div class="block">Calculates the first x- or y- image derivative using Scharr operator.

 The function computes the first x- or y- spatial image derivative using the Scharr operator. The
 call

 \(\texttt{Scharr(src, dst, ddepth, dx, dy, scale, delta, borderType)}\)

 is equivalent to

 \(\texttt{Sobel(src, dst, ddepth, dx, dy, FILTER_SCHARR, scale, delta, borderType)} .\)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image.</dd>
<dd><code>dst</code> - output image of the same size and the same number of channels as src.</dd>
<dd><code>ddepth</code> - output image depth, see REF: filter_depths "combinations"</dd>
<dd><code>dx</code> - order of the derivative x.</dd>
<dd><code>dy</code> - order of the derivative y.</dd>
<dd><code>scale</code> - optional scale factor for the computed derivative values; by default, no scaling is
 applied (see #getDerivKernels for details).</dd>
<dd><code>delta</code> - optional delta value that is added to the results prior to storing them in dst.
 SEE:  cartToPolar</dd>
</dl>
</li>
</ul>
<a name="Scharr-org.opencv.core.Mat-org.opencv.core.Mat-int-int-int-double-double-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Scharr</h4>
<pre>public static&nbsp;void&nbsp;Scharr(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                          int&nbsp;ddepth,
                          int&nbsp;dx,
                          int&nbsp;dy,
                          double&nbsp;scale,
                          double&nbsp;delta,
                          int&nbsp;borderType)</pre>
<div class="block">Calculates the first x- or y- image derivative using Scharr operator.

 The function computes the first x- or y- spatial image derivative using the Scharr operator. The
 call

 \(\texttt{Scharr(src, dst, ddepth, dx, dy, scale, delta, borderType)}\)

 is equivalent to

 \(\texttt{Sobel(src, dst, ddepth, dx, dy, FILTER_SCHARR, scale, delta, borderType)} .\)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image.</dd>
<dd><code>dst</code> - output image of the same size and the same number of channels as src.</dd>
<dd><code>ddepth</code> - output image depth, see REF: filter_depths "combinations"</dd>
<dd><code>dx</code> - order of the derivative x.</dd>
<dd><code>dy</code> - order of the derivative y.</dd>
<dd><code>scale</code> - optional scale factor for the computed derivative values; by default, no scaling is
 applied (see #getDerivKernels for details).</dd>
<dd><code>delta</code> - optional delta value that is added to the results prior to storing them in dst.</dd>
<dd><code>borderType</code> - pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported.
 SEE:  cartToPolar</dd>
</dl>
</li>
</ul>
<a name="sepFilter2D-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sepFilter2D</h4>
<pre>public static&nbsp;void&nbsp;sepFilter2D(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                               int&nbsp;ddepth,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernelX,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernelY)</pre>
<div class="block">Applies a separable linear filter to an image.

 The function applies a separable linear filter to the image. That is, first, every row of src is
 filtered with the 1D kernel kernelX. Then, every column of the result is filtered with the 1D
 kernel kernelY. The final result shifted by delta is stored in dst .</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Source image.</dd>
<dd><code>dst</code> - Destination image of the same size and the same number of channels as src .</dd>
<dd><code>ddepth</code> - Destination image depth, see REF: filter_depths "combinations"</dd>
<dd><code>kernelX</code> - Coefficients for filtering each row.</dd>
<dd><code>kernelY</code> - Coefficients for filtering each column.
 is at the kernel center.
 SEE:  filter2D, Sobel, GaussianBlur, boxFilter, blur</dd>
</dl>
</li>
</ul>
<a name="sepFilter2D-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Point-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sepFilter2D</h4>
<pre>public static&nbsp;void&nbsp;sepFilter2D(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                               int&nbsp;ddepth,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernelX,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernelY,
                               <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor)</pre>
<div class="block">Applies a separable linear filter to an image.

 The function applies a separable linear filter to the image. That is, first, every row of src is
 filtered with the 1D kernel kernelX. Then, every column of the result is filtered with the 1D
 kernel kernelY. The final result shifted by delta is stored in dst .</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Source image.</dd>
<dd><code>dst</code> - Destination image of the same size and the same number of channels as src .</dd>
<dd><code>ddepth</code> - Destination image depth, see REF: filter_depths "combinations"</dd>
<dd><code>kernelX</code> - Coefficients for filtering each row.</dd>
<dd><code>kernelY</code> - Coefficients for filtering each column.</dd>
<dd><code>anchor</code> - Anchor position within the kernel. The default value \((-1,-1)\) means that the anchor
 is at the kernel center.
 SEE:  filter2D, Sobel, GaussianBlur, boxFilter, blur</dd>
</dl>
</li>
</ul>
<a name="sepFilter2D-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Point-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sepFilter2D</h4>
<pre>public static&nbsp;void&nbsp;sepFilter2D(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                               int&nbsp;ddepth,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernelX,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernelY,
                               <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
                               double&nbsp;delta)</pre>
<div class="block">Applies a separable linear filter to an image.

 The function applies a separable linear filter to the image. That is, first, every row of src is
 filtered with the 1D kernel kernelX. Then, every column of the result is filtered with the 1D
 kernel kernelY. The final result shifted by delta is stored in dst .</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Source image.</dd>
<dd><code>dst</code> - Destination image of the same size and the same number of channels as src .</dd>
<dd><code>ddepth</code> - Destination image depth, see REF: filter_depths "combinations"</dd>
<dd><code>kernelX</code> - Coefficients for filtering each row.</dd>
<dd><code>kernelY</code> - Coefficients for filtering each column.</dd>
<dd><code>anchor</code> - Anchor position within the kernel. The default value \((-1,-1)\) means that the anchor
 is at the kernel center.</dd>
<dd><code>delta</code> - Value added to the filtered results before storing them.
 SEE:  filter2D, Sobel, GaussianBlur, boxFilter, blur</dd>
</dl>
</li>
</ul>
<a name="sepFilter2D-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Point-double-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sepFilter2D</h4>
<pre>public static&nbsp;void&nbsp;sepFilter2D(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                               int&nbsp;ddepth,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernelX,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;kernelY,
                               <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
                               double&nbsp;delta,
                               int&nbsp;borderType)</pre>
<div class="block">Applies a separable linear filter to an image.

 The function applies a separable linear filter to the image. That is, first, every row of src is
 filtered with the 1D kernel kernelX. Then, every column of the result is filtered with the 1D
 kernel kernelY. The final result shifted by delta is stored in dst .</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Source image.</dd>
<dd><code>dst</code> - Destination image of the same size and the same number of channels as src .</dd>
<dd><code>ddepth</code> - Destination image depth, see REF: filter_depths "combinations"</dd>
<dd><code>kernelX</code> - Coefficients for filtering each row.</dd>
<dd><code>kernelY</code> - Coefficients for filtering each column.</dd>
<dd><code>anchor</code> - Anchor position within the kernel. The default value \((-1,-1)\) means that the anchor
 is at the kernel center.</dd>
<dd><code>delta</code> - Value added to the filtered results before storing them.</dd>
<dd><code>borderType</code> - Pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported.
 SEE:  filter2D, Sobel, GaussianBlur, boxFilter, blur</dd>
</dl>
</li>
</ul>
<a name="Sobel-org.opencv.core.Mat-org.opencv.core.Mat-int-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Sobel</h4>
<pre>public static&nbsp;void&nbsp;Sobel(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                         int&nbsp;ddepth,
                         int&nbsp;dx,
                         int&nbsp;dy)</pre>
<div class="block">Calculates the first, second, third, or mixed image derivatives using an extended Sobel operator.

 In all cases except one, the \(\texttt{ksize} \times \texttt{ksize}\) separable kernel is used to
 calculate the derivative. When \(\texttt{ksize = 1}\), the \(3 \times 1\) or \(1 \times 3\)
 kernel is used (that is, no Gaussian smoothing is done). <code>ksize = 1</code> can only be used for the first
 or the second x- or y- derivatives.

 There is also the special value <code>ksize = #FILTER_SCHARR (-1)</code> that corresponds to the \(3\times3\) Scharr
 filter that may give more accurate results than the \(3\times3\) Sobel. The Scharr aperture is

 \(\vecthreethree{-3}{0}{3}{-10}{0}{10}{-3}{0}{3}\)

 for the x-derivative, or transposed for the y-derivative.

 The function calculates an image derivative by convolving the image with the appropriate kernel:

 \(\texttt{dst} =  \frac{\partial^{xorder+yorder} \texttt{src}}{\partial x^{xorder} \partial y^{yorder}}\)

 The Sobel operators combine Gaussian smoothing and differentiation, so the result is more or less
 resistant to the noise. Most often, the function is called with ( xorder = 1, yorder = 0, ksize = 3)
 or ( xorder = 0, yorder = 1, ksize = 3) to calculate the first x- or y- image derivative. The first
 case corresponds to a kernel of:

 \(\vecthreethree{-1}{0}{1}{-2}{0}{2}{-1}{0}{1}\)

 The second case corresponds to a kernel of:

 \(\vecthreethree{-1}{-2}{-1}{0}{0}{0}{1}{2}{1}\)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image.</dd>
<dd><code>dst</code> - output image of the same size and the same number of channels as src .</dd>
<dd><code>ddepth</code> - output image depth, see REF: filter_depths "combinations"; in the case of
     8-bit input images it will result in truncated derivatives.</dd>
<dd><code>dx</code> - order of the derivative x.</dd>
<dd><code>dy</code> - order of the derivative y.
 applied (see #getDerivKernels for details).
 SEE:  Scharr, Laplacian, sepFilter2D, filter2D, GaussianBlur, cartToPolar</dd>
</dl>
</li>
</ul>
<a name="Sobel-org.opencv.core.Mat-org.opencv.core.Mat-int-int-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Sobel</h4>
<pre>public static&nbsp;void&nbsp;Sobel(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                         int&nbsp;ddepth,
                         int&nbsp;dx,
                         int&nbsp;dy,
                         int&nbsp;ksize)</pre>
<div class="block">Calculates the first, second, third, or mixed image derivatives using an extended Sobel operator.

 In all cases except one, the \(\texttt{ksize} \times \texttt{ksize}\) separable kernel is used to
 calculate the derivative. When \(\texttt{ksize = 1}\), the \(3 \times 1\) or \(1 \times 3\)
 kernel is used (that is, no Gaussian smoothing is done). <code>ksize = 1</code> can only be used for the first
 or the second x- or y- derivatives.

 There is also the special value <code>ksize = #FILTER_SCHARR (-1)</code> that corresponds to the \(3\times3\) Scharr
 filter that may give more accurate results than the \(3\times3\) Sobel. The Scharr aperture is

 \(\vecthreethree{-3}{0}{3}{-10}{0}{10}{-3}{0}{3}\)

 for the x-derivative, or transposed for the y-derivative.

 The function calculates an image derivative by convolving the image with the appropriate kernel:

 \(\texttt{dst} =  \frac{\partial^{xorder+yorder} \texttt{src}}{\partial x^{xorder} \partial y^{yorder}}\)

 The Sobel operators combine Gaussian smoothing and differentiation, so the result is more or less
 resistant to the noise. Most often, the function is called with ( xorder = 1, yorder = 0, ksize = 3)
 or ( xorder = 0, yorder = 1, ksize = 3) to calculate the first x- or y- image derivative. The first
 case corresponds to a kernel of:

 \(\vecthreethree{-1}{0}{1}{-2}{0}{2}{-1}{0}{1}\)

 The second case corresponds to a kernel of:

 \(\vecthreethree{-1}{-2}{-1}{0}{0}{0}{1}{2}{1}\)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image.</dd>
<dd><code>dst</code> - output image of the same size and the same number of channels as src .</dd>
<dd><code>ddepth</code> - output image depth, see REF: filter_depths "combinations"; in the case of
     8-bit input images it will result in truncated derivatives.</dd>
<dd><code>dx</code> - order of the derivative x.</dd>
<dd><code>dy</code> - order of the derivative y.</dd>
<dd><code>ksize</code> - size of the extended Sobel kernel; it must be 1, 3, 5, or 7.
 applied (see #getDerivKernels for details).
 SEE:  Scharr, Laplacian, sepFilter2D, filter2D, GaussianBlur, cartToPolar</dd>
</dl>
</li>
</ul>
<a name="Sobel-org.opencv.core.Mat-org.opencv.core.Mat-int-int-int-int-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Sobel</h4>
<pre>public static&nbsp;void&nbsp;Sobel(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                         int&nbsp;ddepth,
                         int&nbsp;dx,
                         int&nbsp;dy,
                         int&nbsp;ksize,
                         double&nbsp;scale)</pre>
<div class="block">Calculates the first, second, third, or mixed image derivatives using an extended Sobel operator.

 In all cases except one, the \(\texttt{ksize} \times \texttt{ksize}\) separable kernel is used to
 calculate the derivative. When \(\texttt{ksize = 1}\), the \(3 \times 1\) or \(1 \times 3\)
 kernel is used (that is, no Gaussian smoothing is done). <code>ksize = 1</code> can only be used for the first
 or the second x- or y- derivatives.

 There is also the special value <code>ksize = #FILTER_SCHARR (-1)</code> that corresponds to the \(3\times3\) Scharr
 filter that may give more accurate results than the \(3\times3\) Sobel. The Scharr aperture is

 \(\vecthreethree{-3}{0}{3}{-10}{0}{10}{-3}{0}{3}\)

 for the x-derivative, or transposed for the y-derivative.

 The function calculates an image derivative by convolving the image with the appropriate kernel:

 \(\texttt{dst} =  \frac{\partial^{xorder+yorder} \texttt{src}}{\partial x^{xorder} \partial y^{yorder}}\)

 The Sobel operators combine Gaussian smoothing and differentiation, so the result is more or less
 resistant to the noise. Most often, the function is called with ( xorder = 1, yorder = 0, ksize = 3)
 or ( xorder = 0, yorder = 1, ksize = 3) to calculate the first x- or y- image derivative. The first
 case corresponds to a kernel of:

 \(\vecthreethree{-1}{0}{1}{-2}{0}{2}{-1}{0}{1}\)

 The second case corresponds to a kernel of:

 \(\vecthreethree{-1}{-2}{-1}{0}{0}{0}{1}{2}{1}\)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image.</dd>
<dd><code>dst</code> - output image of the same size and the same number of channels as src .</dd>
<dd><code>ddepth</code> - output image depth, see REF: filter_depths "combinations"; in the case of
     8-bit input images it will result in truncated derivatives.</dd>
<dd><code>dx</code> - order of the derivative x.</dd>
<dd><code>dy</code> - order of the derivative y.</dd>
<dd><code>ksize</code> - size of the extended Sobel kernel; it must be 1, 3, 5, or 7.</dd>
<dd><code>scale</code> - optional scale factor for the computed derivative values; by default, no scaling is
 applied (see #getDerivKernels for details).
 SEE:  Scharr, Laplacian, sepFilter2D, filter2D, GaussianBlur, cartToPolar</dd>
</dl>
</li>
</ul>
<a name="Sobel-org.opencv.core.Mat-org.opencv.core.Mat-int-int-int-int-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Sobel</h4>
<pre>public static&nbsp;void&nbsp;Sobel(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                         int&nbsp;ddepth,
                         int&nbsp;dx,
                         int&nbsp;dy,
                         int&nbsp;ksize,
                         double&nbsp;scale,
                         double&nbsp;delta)</pre>
<div class="block">Calculates the first, second, third, or mixed image derivatives using an extended Sobel operator.

 In all cases except one, the \(\texttt{ksize} \times \texttt{ksize}\) separable kernel is used to
 calculate the derivative. When \(\texttt{ksize = 1}\), the \(3 \times 1\) or \(1 \times 3\)
 kernel is used (that is, no Gaussian smoothing is done). <code>ksize = 1</code> can only be used for the first
 or the second x- or y- derivatives.

 There is also the special value <code>ksize = #FILTER_SCHARR (-1)</code> that corresponds to the \(3\times3\) Scharr
 filter that may give more accurate results than the \(3\times3\) Sobel. The Scharr aperture is

 \(\vecthreethree{-3}{0}{3}{-10}{0}{10}{-3}{0}{3}\)

 for the x-derivative, or transposed for the y-derivative.

 The function calculates an image derivative by convolving the image with the appropriate kernel:

 \(\texttt{dst} =  \frac{\partial^{xorder+yorder} \texttt{src}}{\partial x^{xorder} \partial y^{yorder}}\)

 The Sobel operators combine Gaussian smoothing and differentiation, so the result is more or less
 resistant to the noise. Most often, the function is called with ( xorder = 1, yorder = 0, ksize = 3)
 or ( xorder = 0, yorder = 1, ksize = 3) to calculate the first x- or y- image derivative. The first
 case corresponds to a kernel of:

 \(\vecthreethree{-1}{0}{1}{-2}{0}{2}{-1}{0}{1}\)

 The second case corresponds to a kernel of:

 \(\vecthreethree{-1}{-2}{-1}{0}{0}{0}{1}{2}{1}\)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image.</dd>
<dd><code>dst</code> - output image of the same size and the same number of channels as src .</dd>
<dd><code>ddepth</code> - output image depth, see REF: filter_depths "combinations"; in the case of
     8-bit input images it will result in truncated derivatives.</dd>
<dd><code>dx</code> - order of the derivative x.</dd>
<dd><code>dy</code> - order of the derivative y.</dd>
<dd><code>ksize</code> - size of the extended Sobel kernel; it must be 1, 3, 5, or 7.</dd>
<dd><code>scale</code> - optional scale factor for the computed derivative values; by default, no scaling is
 applied (see #getDerivKernels for details).</dd>
<dd><code>delta</code> - optional delta value that is added to the results prior to storing them in dst.
 SEE:  Scharr, Laplacian, sepFilter2D, filter2D, GaussianBlur, cartToPolar</dd>
</dl>
</li>
</ul>
<a name="Sobel-org.opencv.core.Mat-org.opencv.core.Mat-int-int-int-int-double-double-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Sobel</h4>
<pre>public static&nbsp;void&nbsp;Sobel(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                         int&nbsp;ddepth,
                         int&nbsp;dx,
                         int&nbsp;dy,
                         int&nbsp;ksize,
                         double&nbsp;scale,
                         double&nbsp;delta,
                         int&nbsp;borderType)</pre>
<div class="block">Calculates the first, second, third, or mixed image derivatives using an extended Sobel operator.

 In all cases except one, the \(\texttt{ksize} \times \texttt{ksize}\) separable kernel is used to
 calculate the derivative. When \(\texttt{ksize = 1}\), the \(3 \times 1\) or \(1 \times 3\)
 kernel is used (that is, no Gaussian smoothing is done). <code>ksize = 1</code> can only be used for the first
 or the second x- or y- derivatives.

 There is also the special value <code>ksize = #FILTER_SCHARR (-1)</code> that corresponds to the \(3\times3\) Scharr
 filter that may give more accurate results than the \(3\times3\) Sobel. The Scharr aperture is

 \(\vecthreethree{-3}{0}{3}{-10}{0}{10}{-3}{0}{3}\)

 for the x-derivative, or transposed for the y-derivative.

 The function calculates an image derivative by convolving the image with the appropriate kernel:

 \(\texttt{dst} =  \frac{\partial^{xorder+yorder} \texttt{src}}{\partial x^{xorder} \partial y^{yorder}}\)

 The Sobel operators combine Gaussian smoothing and differentiation, so the result is more or less
 resistant to the noise. Most often, the function is called with ( xorder = 1, yorder = 0, ksize = 3)
 or ( xorder = 0, yorder = 1, ksize = 3) to calculate the first x- or y- image derivative. The first
 case corresponds to a kernel of:

 \(\vecthreethree{-1}{0}{1}{-2}{0}{2}{-1}{0}{1}\)

 The second case corresponds to a kernel of:

 \(\vecthreethree{-1}{-2}{-1}{0}{0}{0}{1}{2}{1}\)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image.</dd>
<dd><code>dst</code> - output image of the same size and the same number of channels as src .</dd>
<dd><code>ddepth</code> - output image depth, see REF: filter_depths "combinations"; in the case of
     8-bit input images it will result in truncated derivatives.</dd>
<dd><code>dx</code> - order of the derivative x.</dd>
<dd><code>dy</code> - order of the derivative y.</dd>
<dd><code>ksize</code> - size of the extended Sobel kernel; it must be 1, 3, 5, or 7.</dd>
<dd><code>scale</code> - optional scale factor for the computed derivative values; by default, no scaling is
 applied (see #getDerivKernels for details).</dd>
<dd><code>delta</code> - optional delta value that is added to the results prior to storing them in dst.</dd>
<dd><code>borderType</code> - pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported.
 SEE:  Scharr, Laplacian, sepFilter2D, filter2D, GaussianBlur, cartToPolar</dd>
</dl>
</li>
</ul>
<a name="spatialGradient-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>spatialGradient</h4>
<pre>public static&nbsp;void&nbsp;spatialGradient(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dx,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dy)</pre>
<div class="block">Calculates the first order image derivative in both x and y using a Sobel operator

 Equivalent to calling:

 <code>
 Sobel( src, dx, CV_16SC1, 1, 0, 3 );
 Sobel( src, dy, CV_16SC1, 0, 1, 3 );
 </code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image.</dd>
<dd><code>dx</code> - output image with first-order derivative in x.</dd>
<dd><code>dy</code> - output image with first-order derivative in y.
                   Only #BORDER_DEFAULT=#BORDER_REFLECT_101 and #BORDER_REPLICATE are supported.

 SEE: Sobel</dd>
</dl>
</li>
</ul>
<a name="spatialGradient-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>spatialGradient</h4>
<pre>public static&nbsp;void&nbsp;spatialGradient(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dx,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dy,
                                   int&nbsp;ksize)</pre>
<div class="block">Calculates the first order image derivative in both x and y using a Sobel operator

 Equivalent to calling:

 <code>
 Sobel( src, dx, CV_16SC1, 1, 0, 3 );
 Sobel( src, dy, CV_16SC1, 0, 1, 3 );
 </code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image.</dd>
<dd><code>dx</code> - output image with first-order derivative in x.</dd>
<dd><code>dy</code> - output image with first-order derivative in y.</dd>
<dd><code>ksize</code> - size of Sobel kernel. It must be 3.
                   Only #BORDER_DEFAULT=#BORDER_REFLECT_101 and #BORDER_REPLICATE are supported.

 SEE: Sobel</dd>
</dl>
</li>
</ul>
<a name="spatialGradient-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>spatialGradient</h4>
<pre>public static&nbsp;void&nbsp;spatialGradient(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dx,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dy,
                                   int&nbsp;ksize,
                                   int&nbsp;borderType)</pre>
<div class="block">Calculates the first order image derivative in both x and y using a Sobel operator

 Equivalent to calling:

 <code>
 Sobel( src, dx, CV_16SC1, 1, 0, 3 );
 Sobel( src, dy, CV_16SC1, 0, 1, 3 );
 </code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image.</dd>
<dd><code>dx</code> - output image with first-order derivative in x.</dd>
<dd><code>dy</code> - output image with first-order derivative in y.</dd>
<dd><code>ksize</code> - size of Sobel kernel. It must be 3.</dd>
<dd><code>borderType</code> - pixel extrapolation method, see #BorderTypes.
                   Only #BORDER_DEFAULT=#BORDER_REFLECT_101 and #BORDER_REPLICATE are supported.

 SEE: Sobel</dd>
</dl>
</li>
</ul>
<a name="sqrBoxFilter-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Size-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sqrBoxFilter</h4>
<pre>public static&nbsp;void&nbsp;sqrBoxFilter(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                int&nbsp;ddepth,
                                <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize)</pre>
<div class="block">Calculates the normalized sum of squares of the pixel values overlapping the filter.

 For every pixel \( (x, y) \) in the source image, the function calculates the sum of squares of those neighboring
 pixel values which overlap the filter placed over the pixel \( (x, y) \).

 The unnormalized square box filter can be useful in computing local image statistics such as the local
 variance and standard deviation around the neighborhood of a pixel.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image</dd>
<dd><code>dst</code> - output image of the same size and type as src</dd>
<dd><code>ddepth</code> - the output image depth (-1 to use src.depth())</dd>
<dd><code>ksize</code> - kernel size
 center.
 SEE: boxFilter</dd>
</dl>
</li>
</ul>
<a name="sqrBoxFilter-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Size-org.opencv.core.Point-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sqrBoxFilter</h4>
<pre>public static&nbsp;void&nbsp;sqrBoxFilter(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                int&nbsp;ddepth,
                                <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
                                <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor)</pre>
<div class="block">Calculates the normalized sum of squares of the pixel values overlapping the filter.

 For every pixel \( (x, y) \) in the source image, the function calculates the sum of squares of those neighboring
 pixel values which overlap the filter placed over the pixel \( (x, y) \).

 The unnormalized square box filter can be useful in computing local image statistics such as the local
 variance and standard deviation around the neighborhood of a pixel.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image</dd>
<dd><code>dst</code> - output image of the same size and type as src</dd>
<dd><code>ddepth</code> - the output image depth (-1 to use src.depth())</dd>
<dd><code>ksize</code> - kernel size</dd>
<dd><code>anchor</code> - kernel anchor point. The default value of Point(-1, -1) denotes that the anchor is at the kernel
 center.
 SEE: boxFilter</dd>
</dl>
</li>
</ul>
<a name="sqrBoxFilter-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Size-org.opencv.core.Point-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sqrBoxFilter</h4>
<pre>public static&nbsp;void&nbsp;sqrBoxFilter(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                int&nbsp;ddepth,
                                <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
                                <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
                                boolean&nbsp;normalize)</pre>
<div class="block">Calculates the normalized sum of squares of the pixel values overlapping the filter.

 For every pixel \( (x, y) \) in the source image, the function calculates the sum of squares of those neighboring
 pixel values which overlap the filter placed over the pixel \( (x, y) \).

 The unnormalized square box filter can be useful in computing local image statistics such as the local
 variance and standard deviation around the neighborhood of a pixel.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image</dd>
<dd><code>dst</code> - output image of the same size and type as src</dd>
<dd><code>ddepth</code> - the output image depth (-1 to use src.depth())</dd>
<dd><code>ksize</code> - kernel size</dd>
<dd><code>anchor</code> - kernel anchor point. The default value of Point(-1, -1) denotes that the anchor is at the kernel
 center.</dd>
<dd><code>normalize</code> - flag, specifying whether the kernel is to be normalized by it's area or not.
 SEE: boxFilter</dd>
</dl>
</li>
</ul>
<a name="sqrBoxFilter-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Size-org.opencv.core.Point-boolean-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sqrBoxFilter</h4>
<pre>public static&nbsp;void&nbsp;sqrBoxFilter(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                int&nbsp;ddepth,
                                <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize,
                                <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;anchor,
                                boolean&nbsp;normalize,
                                int&nbsp;borderType)</pre>
<div class="block">Calculates the normalized sum of squares of the pixel values overlapping the filter.

 For every pixel \( (x, y) \) in the source image, the function calculates the sum of squares of those neighboring
 pixel values which overlap the filter placed over the pixel \( (x, y) \).

 The unnormalized square box filter can be useful in computing local image statistics such as the local
 variance and standard deviation around the neighborhood of a pixel.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image</dd>
<dd><code>dst</code> - output image of the same size and type as src</dd>
<dd><code>ddepth</code> - the output image depth (-1 to use src.depth())</dd>
<dd><code>ksize</code> - kernel size</dd>
<dd><code>anchor</code> - kernel anchor point. The default value of Point(-1, -1) denotes that the anchor is at the kernel
 center.</dd>
<dd><code>normalize</code> - flag, specifying whether the kernel is to be normalized by it's area or not.</dd>
<dd><code>borderType</code> - border mode used to extrapolate pixels outside of the image, see #BorderTypes. #BORDER_WRAP is not supported.
 SEE: boxFilter</dd>
</dl>
</li>
</ul>
<a name="stackBlur-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>stackBlur</h4>
<pre>public static&nbsp;void&nbsp;stackBlur(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                             <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;ksize)</pre>
<div class="block">Blurs an image using the stackBlur.

 The function applies and stackBlur to an image.
 stackBlur can generate similar results as Gaussian blur, and the time consumption does not increase with the increase of kernel size.
 It creates a kind of moving stack of colors whilst scanning through the image. Thereby it just has to add one new block of color to the right side
 of the stack and remove the leftmost color. The remaining colors on the topmost layer of the stack are either added on or reduced by one,
 depending on if they are on the right or on the left side of the stack. The only supported borderType is BORDER_REPLICATE.
 Original paper was proposed by Mario Klingemann, which can be found http://underdestruction.com/2004/02/25/stackblur-2004.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image. The number of channels can be arbitrary, but the depth should be one of
 CV_8U, CV_16U, CV_16S or CV_32F.</dd>
<dd><code>dst</code> - output image of the same size and type as src.</dd>
<dd><code>ksize</code> - stack-blurring kernel size. The ksize.width and ksize.height can differ but they both must be
 positive and odd.</dd>
</dl>
</li>
</ul>
<a name="threshold-org.opencv.core.Mat-org.opencv.core.Mat-double-double-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>threshold</h4>
<pre>public static&nbsp;double&nbsp;threshold(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                               double&nbsp;thresh,
                               double&nbsp;maxval,
                               int&nbsp;type)</pre>
<div class="block">Applies a fixed-level threshold to each array element.

 The function applies fixed-level thresholding to a multiple-channel array. The function is typically
 used to get a bi-level (binary) image out of a grayscale image ( #compare could be also used for
 this purpose) or for removing a noise, that is, filtering out pixels with too small or too large
 values. There are several types of thresholding supported by the function. They are determined by
 type parameter.

 Also, the special values #THRESH_OTSU or #THRESH_TRIANGLE may be combined with one of the
 above values. In these cases, the function determines the optimal threshold value using the Otsu's
 or Triangle algorithm and uses it instead of the specified thresh.

 <b>Note:</b> Currently, the Otsu's and Triangle methods are implemented only for 8-bit single-channel images.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input array (multiple-channel, 8-bit or 32-bit floating point).</dd>
<dd><code>dst</code> - output array of the same size  and type and the same number of channels as src.</dd>
<dd><code>thresh</code> - threshold value.</dd>
<dd><code>maxval</code> - maximum value to use with the #THRESH_BINARY and #THRESH_BINARY_INV thresholding
 types.</dd>
<dd><code>type</code> - thresholding type (see #ThresholdTypes).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the computed threshold value if Otsu's or Triangle methods used.

 SEE:  adaptiveThreshold, findContours, compare, min, max</dd>
</dl>
</li>
</ul>
<a name="warpAffine-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>warpAffine</h4>
<pre>public static&nbsp;void&nbsp;warpAffine(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;M,
                              <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dsize)</pre>
<div class="block">Applies an affine transformation to an image.

 The function warpAffine transforms the source image using the specified matrix:

 \(\texttt{dst} (x,y) =  \texttt{src} ( \texttt{M} _{11} x +  \texttt{M} _{12} y +  \texttt{M} _{13}, \texttt{M} _{21} x +  \texttt{M} _{22} y +  \texttt{M} _{23})\)

 when the flag #WARP_INVERSE_MAP is set. Otherwise, the transformation is first inverted
 with #invertAffineTransform and then put in the formula above instead of M. The function cannot
 operate in-place.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image.</dd>
<dd><code>dst</code> - output image that has the size dsize and the same type as src .</dd>
<dd><code>M</code> - \(2\times 3\) transformation matrix.</dd>
<dd><code>dsize</code> - size of the output image.
 flag #WARP_INVERSE_MAP that means that M is the inverse transformation (
 \(\texttt{dst}\rightarrow\texttt{src}\) ).
 borderMode=#BORDER_TRANSPARENT, it means that the pixels in the destination image corresponding to
 the "outliers" in the source image are not modified by the function.

 SEE:  warpPerspective, resize, remap, getRectSubPix, transform</dd>
</dl>
</li>
</ul>
<a name="warpAffine-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>warpAffine</h4>
<pre>public static&nbsp;void&nbsp;warpAffine(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;M,
                              <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dsize,
                              int&nbsp;flags)</pre>
<div class="block">Applies an affine transformation to an image.

 The function warpAffine transforms the source image using the specified matrix:

 \(\texttt{dst} (x,y) =  \texttt{src} ( \texttt{M} _{11} x +  \texttt{M} _{12} y +  \texttt{M} _{13}, \texttt{M} _{21} x +  \texttt{M} _{22} y +  \texttt{M} _{23})\)

 when the flag #WARP_INVERSE_MAP is set. Otherwise, the transformation is first inverted
 with #invertAffineTransform and then put in the formula above instead of M. The function cannot
 operate in-place.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image.</dd>
<dd><code>dst</code> - output image that has the size dsize and the same type as src .</dd>
<dd><code>M</code> - \(2\times 3\) transformation matrix.</dd>
<dd><code>dsize</code> - size of the output image.</dd>
<dd><code>flags</code> - combination of interpolation methods (see #InterpolationFlags) and the optional
 flag #WARP_INVERSE_MAP that means that M is the inverse transformation (
 \(\texttt{dst}\rightarrow\texttt{src}\) ).
 borderMode=#BORDER_TRANSPARENT, it means that the pixels in the destination image corresponding to
 the "outliers" in the source image are not modified by the function.

 SEE:  warpPerspective, resize, remap, getRectSubPix, transform</dd>
</dl>
</li>
</ul>
<a name="warpAffine-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>warpAffine</h4>
<pre>public static&nbsp;void&nbsp;warpAffine(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;M,
                              <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dsize,
                              int&nbsp;flags,
                              int&nbsp;borderMode)</pre>
<div class="block">Applies an affine transformation to an image.

 The function warpAffine transforms the source image using the specified matrix:

 \(\texttt{dst} (x,y) =  \texttt{src} ( \texttt{M} _{11} x +  \texttt{M} _{12} y +  \texttt{M} _{13}, \texttt{M} _{21} x +  \texttt{M} _{22} y +  \texttt{M} _{23})\)

 when the flag #WARP_INVERSE_MAP is set. Otherwise, the transformation is first inverted
 with #invertAffineTransform and then put in the formula above instead of M. The function cannot
 operate in-place.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image.</dd>
<dd><code>dst</code> - output image that has the size dsize and the same type as src .</dd>
<dd><code>M</code> - \(2\times 3\) transformation matrix.</dd>
<dd><code>dsize</code> - size of the output image.</dd>
<dd><code>flags</code> - combination of interpolation methods (see #InterpolationFlags) and the optional
 flag #WARP_INVERSE_MAP that means that M is the inverse transformation (
 \(\texttt{dst}\rightarrow\texttt{src}\) ).</dd>
<dd><code>borderMode</code> - pixel extrapolation method (see #BorderTypes); when
 borderMode=#BORDER_TRANSPARENT, it means that the pixels in the destination image corresponding to
 the "outliers" in the source image are not modified by the function.

 SEE:  warpPerspective, resize, remap, getRectSubPix, transform</dd>
</dl>
</li>
</ul>
<a name="warpAffine-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-int-int-org.opencv.core.Scalar-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>warpAffine</h4>
<pre>public static&nbsp;void&nbsp;warpAffine(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;M,
                              <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dsize,
                              int&nbsp;flags,
                              int&nbsp;borderMode,
                              <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;borderValue)</pre>
<div class="block">Applies an affine transformation to an image.

 The function warpAffine transforms the source image using the specified matrix:

 \(\texttt{dst} (x,y) =  \texttt{src} ( \texttt{M} _{11} x +  \texttt{M} _{12} y +  \texttt{M} _{13}, \texttt{M} _{21} x +  \texttt{M} _{22} y +  \texttt{M} _{23})\)

 when the flag #WARP_INVERSE_MAP is set. Otherwise, the transformation is first inverted
 with #invertAffineTransform and then put in the formula above instead of M. The function cannot
 operate in-place.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image.</dd>
<dd><code>dst</code> - output image that has the size dsize and the same type as src .</dd>
<dd><code>M</code> - \(2\times 3\) transformation matrix.</dd>
<dd><code>dsize</code> - size of the output image.</dd>
<dd><code>flags</code> - combination of interpolation methods (see #InterpolationFlags) and the optional
 flag #WARP_INVERSE_MAP that means that M is the inverse transformation (
 \(\texttt{dst}\rightarrow\texttt{src}\) ).</dd>
<dd><code>borderMode</code> - pixel extrapolation method (see #BorderTypes); when
 borderMode=#BORDER_TRANSPARENT, it means that the pixels in the destination image corresponding to
 the "outliers" in the source image are not modified by the function.</dd>
<dd><code>borderValue</code> - value used in case of a constant border; by default, it is 0.

 SEE:  warpPerspective, resize, remap, getRectSubPix, transform</dd>
</dl>
</li>
</ul>
<a name="warpPerspective-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>warpPerspective</h4>
<pre>public static&nbsp;void&nbsp;warpPerspective(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;M,
                                   <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dsize)</pre>
<div class="block">Applies a perspective transformation to an image.

 The function warpPerspective transforms the source image using the specified matrix:

 \(\texttt{dst} (x,y) =  \texttt{src} \left ( \frac{M_{11} x + M_{12} y + M_{13}}{M_{31} x + M_{32} y + M_{33}} ,
      \frac{M_{21} x + M_{22} y + M_{23}}{M_{31} x + M_{32} y + M_{33}} \right )\)

 when the flag #WARP_INVERSE_MAP is set. Otherwise, the transformation is first inverted with invert
 and then put in the formula above instead of M. The function cannot operate in-place.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image.</dd>
<dd><code>dst</code> - output image that has the size dsize and the same type as src .</dd>
<dd><code>M</code> - \(3\times 3\) transformation matrix.</dd>
<dd><code>dsize</code> - size of the output image.
 optional flag #WARP_INVERSE_MAP, that sets M as the inverse transformation (
 \(\texttt{dst}\rightarrow\texttt{src}\) ).

 SEE:  warpAffine, resize, remap, getRectSubPix, perspectiveTransform</dd>
</dl>
</li>
</ul>
<a name="warpPerspective-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>warpPerspective</h4>
<pre>public static&nbsp;void&nbsp;warpPerspective(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;M,
                                   <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dsize,
                                   int&nbsp;flags)</pre>
<div class="block">Applies a perspective transformation to an image.

 The function warpPerspective transforms the source image using the specified matrix:

 \(\texttt{dst} (x,y) =  \texttt{src} \left ( \frac{M_{11} x + M_{12} y + M_{13}}{M_{31} x + M_{32} y + M_{33}} ,
      \frac{M_{21} x + M_{22} y + M_{23}}{M_{31} x + M_{32} y + M_{33}} \right )\)

 when the flag #WARP_INVERSE_MAP is set. Otherwise, the transformation is first inverted with invert
 and then put in the formula above instead of M. The function cannot operate in-place.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image.</dd>
<dd><code>dst</code> - output image that has the size dsize and the same type as src .</dd>
<dd><code>M</code> - \(3\times 3\) transformation matrix.</dd>
<dd><code>dsize</code> - size of the output image.</dd>
<dd><code>flags</code> - combination of interpolation methods (#INTER_LINEAR or #INTER_NEAREST) and the
 optional flag #WARP_INVERSE_MAP, that sets M as the inverse transformation (
 \(\texttt{dst}\rightarrow\texttt{src}\) ).

 SEE:  warpAffine, resize, remap, getRectSubPix, perspectiveTransform</dd>
</dl>
</li>
</ul>
<a name="warpPerspective-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>warpPerspective</h4>
<pre>public static&nbsp;void&nbsp;warpPerspective(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;M,
                                   <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dsize,
                                   int&nbsp;flags,
                                   int&nbsp;borderMode)</pre>
<div class="block">Applies a perspective transformation to an image.

 The function warpPerspective transforms the source image using the specified matrix:

 \(\texttt{dst} (x,y) =  \texttt{src} \left ( \frac{M_{11} x + M_{12} y + M_{13}}{M_{31} x + M_{32} y + M_{33}} ,
      \frac{M_{21} x + M_{22} y + M_{23}}{M_{31} x + M_{32} y + M_{33}} \right )\)

 when the flag #WARP_INVERSE_MAP is set. Otherwise, the transformation is first inverted with invert
 and then put in the formula above instead of M. The function cannot operate in-place.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image.</dd>
<dd><code>dst</code> - output image that has the size dsize and the same type as src .</dd>
<dd><code>M</code> - \(3\times 3\) transformation matrix.</dd>
<dd><code>dsize</code> - size of the output image.</dd>
<dd><code>flags</code> - combination of interpolation methods (#INTER_LINEAR or #INTER_NEAREST) and the
 optional flag #WARP_INVERSE_MAP, that sets M as the inverse transformation (
 \(\texttt{dst}\rightarrow\texttt{src}\) ).</dd>
<dd><code>borderMode</code> - pixel extrapolation method (#BORDER_CONSTANT or #BORDER_REPLICATE).

 SEE:  warpAffine, resize, remap, getRectSubPix, perspectiveTransform</dd>
</dl>
</li>
</ul>
<a name="warpPerspective-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-int-int-org.opencv.core.Scalar-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>warpPerspective</h4>
<pre>public static&nbsp;void&nbsp;warpPerspective(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;M,
                                   <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dsize,
                                   int&nbsp;flags,
                                   int&nbsp;borderMode,
                                   <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;borderValue)</pre>
<div class="block">Applies a perspective transformation to an image.

 The function warpPerspective transforms the source image using the specified matrix:

 \(\texttt{dst} (x,y) =  \texttt{src} \left ( \frac{M_{11} x + M_{12} y + M_{13}}{M_{31} x + M_{32} y + M_{33}} ,
      \frac{M_{21} x + M_{22} y + M_{23}}{M_{31} x + M_{32} y + M_{33}} \right )\)

 when the flag #WARP_INVERSE_MAP is set. Otherwise, the transformation is first inverted with invert
 and then put in the formula above instead of M. The function cannot operate in-place.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input image.</dd>
<dd><code>dst</code> - output image that has the size dsize and the same type as src .</dd>
<dd><code>M</code> - \(3\times 3\) transformation matrix.</dd>
<dd><code>dsize</code> - size of the output image.</dd>
<dd><code>flags</code> - combination of interpolation methods (#INTER_LINEAR or #INTER_NEAREST) and the
 optional flag #WARP_INVERSE_MAP, that sets M as the inverse transformation (
 \(\texttt{dst}\rightarrow\texttt{src}\) ).</dd>
<dd><code>borderMode</code> - pixel extrapolation method (#BORDER_CONSTANT or #BORDER_REPLICATE).</dd>
<dd><code>borderValue</code> - value used in case of a constant border; by default, it equals 0.

 SEE:  warpAffine, resize, remap, getRectSubPix, perspectiveTransform</dd>
</dl>
</li>
</ul>
<a name="warpPolar-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Size-org.opencv.core.Point-double-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>warpPolar</h4>
<pre>public static&nbsp;void&nbsp;warpPolar(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                             <a href="../../../org/opencv/core/Size.html" title="class in org.opencv.core">Size</a>&nbsp;dsize,
                             <a href="../../../org/opencv/core/Point.html" title="class in org.opencv.core">Point</a>&nbsp;center,
                             double&nbsp;maxRadius,
                             int&nbsp;flags)</pre>
<div class="block">Remaps an image to polar or semilog-polar coordinates space

  polar_remaps_reference_image
 ![Polar remaps reference](pics/polar_remap_doc.png)

 Transform the source image using the following transformation:
 \(
 dst(\rho , \phi ) = src(x,y)
 \)

 where
 \(
 \begin{array}{l}
 \vec{I} = (x - center.x, \;y - center.y) \\
 \phi = Kangle \cdot \texttt{angle} (\vec{I}) \\
 \rho = \left\{\begin{matrix}
 Klin \cdot \texttt{magnitude} (\vec{I}) &amp; default \\
 Klog \cdot log_e(\texttt{magnitude} (\vec{I})) &amp; if \; semilog \\
 \end{matrix}\right.
 \end{array}
 \)

 and
 \(
 \begin{array}{l}
 Kangle = dsize.height / 2\Pi \\
 Klin = dsize.width / maxRadius \\
 Klog = dsize.width / log_e(maxRadius) \\
 \end{array}
 \)


 \par Linear vs semilog mapping

 Polar mapping can be linear or semi-log. Add one of #WarpPolarMode to <code>flags</code> to specify the polar mapping mode.

 Linear is the default mode.

 The semilog mapping emulates the human "foveal" vision that permit very high acuity on the line of sight (central vision)
 in contrast to peripheral vision where acuity is minor.

 \par Option on <code>dsize</code>:

 <ul>
   <li>
  if both values in <code>dsize &amp;lt;=0 </code> (default),
 the destination image will have (almost) same area of source bounding circle:
 \(\begin{array}{l}
 dsize.area  \leftarrow (maxRadius^2 \cdot \Pi) \\
 dsize.width = \texttt{cvRound}(maxRadius) \\
 dsize.height = \texttt{cvRound}(maxRadius \cdot \Pi) \\
 \end{array}\)
   </li>
 </ul>


 <ul>
   <li>
  if only <code>dsize.height &amp;lt;= 0</code>,
 the destination image area will be proportional to the bounding circle area but scaled by <code>Kx * Kx</code>:
 \(\begin{array}{l}
 dsize.height = \texttt{cvRound}(dsize.width \cdot \Pi) \\
 \end{array}
 \)
   </li>
 </ul>

 <ul>
   <li>
  if both values in <code>dsize &amp;gt; 0 </code>,
 the destination image will have the given size therefore the area of the bounding circle will be scaled to <code>dsize</code>.
   </li>
 </ul>


 \par Reverse mapping

 You can get reverse mapping adding #WARP_INVERSE_MAP to <code>flags</code>
 \snippet polar_transforms.cpp InverseMap

 In addiction, to calculate the original coordinate from a polar mapped coordinate \((rho, phi)-&gt;(x, y)\):
 \snippet polar_transforms.cpp InverseCoordinate</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Source image.</dd>
<dd><code>dst</code> - Destination image. It will have same type as src.</dd>
<dd><code>dsize</code> - The destination image size (see description for valid options).</dd>
<dd><code>center</code> - The transformation center.</dd>
<dd><code>maxRadius</code> - The radius of the bounding circle to transform. It determines the inverse magnitude scale parameter too.</dd>
<dd><code>flags</code> - A combination of interpolation methods, #InterpolationFlags + #WarpPolarMode.
 <ul>
   <li>
              Add #WARP_POLAR_LINEAR to select linear polar mapping (default)
   </li>
   <li>
              Add #WARP_POLAR_LOG to select semilog polar mapping
   </li>
   <li>
              Add #WARP_INVERSE_MAP for reverse mapping.
   </li>
 </ul>
 <b>Note:</b>
 <ul>
   <li>
   The function can not operate in-place.
   </li>
   <li>
   To calculate magnitude and angle in degrees #cartToPolar is used internally thus angles are measured from 0 to 360 with accuracy about 0.3 degrees.
   </li>
   <li>
   This function uses #remap. Due to current implementation limitations the size of an input and output images should be less than 32767x32767.
   </li>
 </ul>

 SEE: cv::remap</dd>
</dl>
</li>
</ul>
<a name="watershed-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>watershed</h4>
<pre>public static&nbsp;void&nbsp;watershed(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;image,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;markers)</pre>
<div class="block">Performs a marker-based image segmentation using the watershed algorithm.

 The function implements one of the variants of watershed, non-parametric marker-based segmentation
 algorithm, described in CITE: Meyer92 .

 Before passing the image to the function, you have to roughly outline the desired regions in the
 image markers with positive (&gt;0) indices. So, every region is represented as one or more connected
 components with the pixel values 1, 2, 3, and so on. Such markers can be retrieved from a binary
 mask using #findContours and #drawContours (see the watershed.cpp demo). The markers are "seeds" of
 the future image regions. All the other pixels in markers , whose relation to the outlined regions
 is not known and should be defined by the algorithm, should be set to 0's. In the function output,
 each pixel in markers is set to a value of the "seed" components or to -1 at boundaries between the
 regions.

 <b>Note:</b> Any two neighbor connected components are not necessarily separated by a watershed boundary
 (-1's pixels); for example, they can touch each other in the initial marker image passed to the
 function.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>image</code> - Input 8-bit 3-channel image.</dd>
<dd><code>markers</code> - Input/output 32-bit single-channel image (map) of markers. It should have the same
 size as image .

 SEE: findContours</dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
<div class="aboutLanguage">
            <script>
              var url = window.location.href;
              var pos = url.lastIndexOf('/javadoc/');
              url = pos >= 0 ? (url.substring(0, pos) + '/javadoc/mymath.js') : (window.location.origin + '/mymath.js');
              var script = document.createElement('script');
              script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML,' + url;
              document.getElementsByTagName('head')[0].appendChild(script);
            </script>
</div>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../org/opencv/imgproc/GeneralizedHoughGuil.html" title="class in org.opencv.imgproc"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../org/opencv/imgproc/IntelligentScissorsMB.html" title="class in org.opencv.imgproc"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?org/opencv/imgproc/Imgproc.html" target="_top">Frames</a></li>
<li><a href="Imgproc.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small>Generated on 2023-06-28 12:47:21 / OpenCV 4.8.0</small></p>
</body>
</html>
